{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#materialy","title":"Materi\u00e1ly","text":"<ul> <li>AG1 courses</li> <li>Online FIT</li> </ul>"},{"location":"#github","title":"GitHub","text":""},{"location":"#contributors","title":"Contributors","text":""},{"location":"#truepeak-et-al","title":"Truepeak et. al.","text":""},{"location":"issues/","title":"Issues","text":""},{"location":"issues/#you-can-report-any-issues-here","title":"You can report any issues here","text":""},{"location":"issues/#notes-on-reporting","title":"Notes on reporting","text":"<ol> <li>Specify where (section number - ex. 4.2) and what the problem is - for example: <code>4.2 - typo in proof of theorem 4.1</code></li> <li>Add any relevant description if needed</li> <li>Create the issue</li> </ol>"},{"location":"issues/#creating-a-pull-request","title":"Creating a Pull request","text":"<p>You can also fix the issue yourself with a pull request</p> <ol> <li>Create a fork of the repository</li> <li>Fix the issue in your fork<ul> <li>please try to prefix all your commits with <code>fix: (commit message)</code> </li> </ul> </li> <li>Request merge to <code>main</code> branch of <code>truepeak78/ag1</code></li> </ol>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.1_Z%C3%A1kladn%C3%AD_pojmy/","title":"1.1 Z\u00e1kladn\u00ed pojmy","text":"<p>Definice 1.1 (Neorientovan\u00fd Graf)</p> <p></p> <p>Definice 1.2 (Sousedi a incidence)</p> <ul> <li>Mno\u017einu v\u0161ech dvouprvkov\u00fdch podmno\u017ein mno\u017einy \\(V\\) (tedy v\u0161ech mo\u017en\u00fdch hran) budeme ozna\u010dovat \\(\\binom{V}{2}\\).</li> <li>Obvykle budeme \u0159\u00edkat jen graf, tj. ne\u0159\u00edk\u00e1me neorientovan\u00fd.</li> <li>Nech\u0165 \\(G\\) je graf, pak:<ul> <li>jeho mno\u017einu vrchol\u016f a hran budeme zna\u010dit \\(V(G)\\) a \\(E(G)\\), </li> <li>po\u010det jeho vrchol\u016f a hran budeme obvykle zna\u010dit \\(n = |V (G)|\\) a \\(m = |E(G)|\\).</li> </ul> </li> </ul> <p></p> <p>Definice 1.3 (Sled a Cesta)</p>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.1_Z%C3%A1kladn%C3%AD_pojmy/#def-1.1","title":"Neorientovan\u00fd Graf","text":"<p>Neorientovan\u00fd graf je uspo\u0159\u00e1dan\u00e1 dvojice \\(( V , E )\\), kde:</p> <ul> <li>\\(V\\) je nepr\u00e1zdn\u00e1 kone\u010dn\u00e1 mno\u017eina vrchol\u016f</li> <li>\\(E\\) je mno\u017eina hran<ul> <li>Hrana je dvouprvkov\u00e1 podmno\u017eina \\(V\\) (\u010dili neuspo\u0159\u00e1dan\u00e1 dvojice vrchol\u016f)</li> <li>Zna\u010d\u00edme {\\(u\\) , \\(v\\)}</li> </ul> </li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.1_Z%C3%A1kladn%C3%AD_pojmy/#def-1.2","title":"Sousedi a incidence","text":"<p>Nech\u0165 \\(e\\) = {\\(u\\), \\(v\\)} je hrana v grafu \\(G\\). Pak \u0159ekneme, \u017ee: </p> <ul> <li>vrcholy \\(u\\) a \\(v\\) jsou koncov\u00e9 vrcholy hrany \\(e\\)</li> <li>\\(u\\) je sousedem \\(v\\) v \\(G\\) (a naopak), </li> <li>\\(u\\) i \\(v\\) jsou incidentn\u00ed s hranou \\(e\\). </li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.1_Z%C3%A1kladn%C3%AD_pojmy/#def-1.3","title":"Sled a Cesta","text":"<ul> <li>Sled d\u00e9lky \\(k\\) v grafu \\(G\\) je sekvence \\(v_{0}\\), \\(e_{1}\\), \\(v_{1}\\), \\(e_{2}\\), ... , \\(e_{k}\\), \\(v_{k}\\) takov\u00e1, \u017ee \\(e_{i}\\) = {\\(v_{i\u22121}, v_{i}\\)} a \\(e_{i}\\) \u2208 \\(E(G)\\) pro v\u0161echna \\(i\\) = 1, ... , \\(k\\).</li> <li>Cesta v grafu \\(G\\) je sled, ve kter\u00e9m se neopakuj\u00ed vrcholy (a tedy ani hrany).</li> <li>M\u00e1-li cesta P v grafu \\(G\\) koncov\u00e9 vrcholy \\(s = v_{0}\\) a \\(t = v_{k}\\), mluv\u00edme o cest\u011b z \\(s\\) do \\(t\\), nebo o s-t-cest\u011b. (P\u0159ipou\u0161t\u00edme \\(s = t\\), cesta tedy m\u016f\u017ee m\u00edt nulovou d\u00e9lku).</li> <li>D\u00e9lka s-t-cesty je po\u010det hran v t\u00e9to cest\u011b (v grafu \\(G\\)).</li> <li>Vzd\u00e1lenost \\(s\\) a \\(t\\) \\(d(s, t)\\) je d\u00e9lka nejkrat\u0161\u00ed \\(s\\)-\\(t\\)-cesty</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.2_BFS/","title":"1.2 BFS","text":"<p>Algoritmus 1.1 (BFS)</p> <p></p> <p>V\u011bta 1.1 (O kone\u010dnosti algoritmu BFS)</p> D\u016fkaz v\u011bty 1.1 <ol> <li>Ka\u017ed\u00fd vrchol je p\u0159id\u00e1n do fronty \\(Q\\) nejv\u00fd\u0161e jednou, nebo\u0165 je p\u0159edt\u00edm otev\u0159en a nem\u016f\u017ee u\u017e tedy v\u00edcekr\u00e1t splnit podm\u00ednku na \u0159\u00e1dku \\((10)\\), \u017ee je nenalezen\u00fd.</li> <li>V ka\u017ed\u00e9 iteraci cyklu \\((7)\u2013(15)\\) je jeden vrchol odebr\u00e1n z fronty.</li> <li>Algoritmus se tedy zastav\u00ed nejv\u00fd\u0161e po \\(|V (G)|\\) iterac\u00edch cyklu \\((7)\u2013(15)\\)</li> </ol> <p>Pokud v\u00edme, \u017ee se algoritmus BFS(G, s) v\u017edy zastav\u00ed, m\u016f\u017eeme (a mus\u00edme) uk\u00e1zat, \u017ee v\u017edy vyd\u00e1 spr\u00e1vn\u00fd (o\u010dek\u00e1van\u00fd) v\u00fdsledek. To znamen\u00e1 dok\u00e1zat jeho 3 vlastnosti.</p> <p></p> <p>V\u011bta 1.2 (O spr\u00e1vnosti algoritmu BFS)</p> <p>P\u0159ed dokon\u010den\u00edm d\u016fkazu spr\u00e1vnosti definujme BFS f\u00e1ze a hladiny.</p> <p></p> <p>Definice 1.4 (BFS f\u00e1ze \\(F_{i}\\) a BFS hladiny \\(H_{i}\\))</p> D\u016fkaz Vlastnosti 1 <p>Po skon\u010den\u00ed BFS\\((G, s)\\) jsou uzav\u0159en\u00e9 pr\u00e1v\u011b ty vrcholy, do kter\u00fdch vede cesta ze startu s a ostatn\u00ed vrcholy z\u016fstanou nenalezen\u00e9.</p> <ol> <li>Prvn\u00edm otev\u0159en\u00fdm a n\u00e1sledn\u011b uzav\u0159en\u00fdm vrcholem je start \\(s\\).</li> <li>BFS otv\u00edr\u00e1 na \u0159\u00e1dku \\((11)\\) v\u0161echny nov\u00e9 sousedy d\u0159\u00edve otev\u0159en\u00fdch vrchol\u016f.</li> <li>(\u2287) Vrchol tedy bude otev\u0159en (a pozd\u011bji pak uzav\u0159en) pouze tehdy, kdy\u017e do n\u011bho ze startu \\(s\\) vede posloupnost sousedn\u00edch hran.</li> <li>(\u2286) Naopak, existuje-li do vrcholu n\u011bjak\u00e1 posloupnost sousedn\u00edch hran z \\(s\\), bude v pr\u016fb\u011bhu algoritmu n\u011bkdy otev\u0159en.</li> </ol> <p>Neform\u00e1ln\u00ed definice holubn\u00edkov\u00e9ho principu (v\u011bta z BI-DML)</p> <p>Jestli\u017ee n holub\u016f vlet\u00ed do k hn\u00edzd, p\u0159i\u010dem\u017e k &lt; n, pak v n\u011bkter\u00e9m hn\u00edzd\u011b mus\u00ed b\u00fdt alespo\u0148 dva holubi.</p> D\u016fkaz Vlastnosti 2 <p>Pro v\u0161echny uzav\u0159en\u00e9 vrcholy \\(v\\) plat\u00ed \\(D[v] = d(s, v) =\\) d\u00e9lka nejkrat\u0161\u00ed cesty ze startu \\(s\\) do vrcholu \\(v\\)</p> <ol> <li>Trivi\u00e1ln\u011b plat\u00ed ve f\u00e1zi \\(F_{0}\\). Uva\u017eujme f\u00e1zi \\(F_{i}\\), \\(i &gt; 0\\).</li> <li>Pokud \\(v \\in H_{i}\\), pak \\(D[v] = i\\) a tedy z \\(s\\) do \\(v\\) mus\u00ed existovat cesta o \\(i\\) hran\u00e1ch. Proto je vzd\u00e1lenost \\(d(s, v) \u2264 i\\).</li> <li>Uk\u00e1\u017eeme nyn\u00ed, \u017ee nem\u016f\u017ee existovat s-v-cesta krat\u0161\u00ed ne\u017e \\(i\\). Pro spor, nech\u0165 existuje cesta \\(P\\) z \\(s\\) do \\(v\\) d\u00e9lky \\(j\\), kde \\(j &lt; i\\).</li> <li>Proto\u017ee \\(j &lt; i\\), mus\u00ed dle holubn\u00edkov\u00e9ho principu na \\(P\\) existovat dva sousedn\u00ed vrcholy \\(w\\) a \\(w\u2032\\) a dv\u011b nesousedn\u00ed hladiny \\(H_{k}\\) a \\(H_{l}\\) (tedy \\(|k \u2212 \u2113| &gt; 1\\)) tak, \u017ee \\(w \\in H_{k}\\)\u00a0a\u00a0\\(w\u2032 \\in H_{l}\\).</li> <li>To v\u0161ak nen\u00ed mo\u017en\u00e9, nebo\u0165 dva sousedn\u00ed vrcholy na \\(P\\) nutn\u011b mus\u00ed le\u017eet ve dvou sousedn\u00edch hladin\u00e1ch. SPOR.</li> <li>Proto \\(d(s, v) = i = D[v]\\)</li> </ol>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.2_BFS/#algo-1.1","title":"Algoritmus BFS","text":"<p>Breadth-first search (prohled\u00e1v\u00e1n\u00ed grafu do \u0161\u00ed\u0159ky)</p> <p></p> <p>Vstup</p> <p>Neorientovan\u00fd graf \\(G = (V, E)\\) a vrchol \\(s \\in V\\)</p> <p>V\u00fdstup</p> <p>Pole vzd\u00e1lenost\u00ed \\(D\\) takov\u00e9, \u017ee:</p> \\[ D [v] = \\begin{cases}  k &amp; k \\text{ je d\u00e9lka nejkrat\u0161\u00ed s-v-cesty v } G, \\\\ \\text{undef.} &amp; \\text{neexistuje \u017e\u00e1dn\u00e1 s-v-cesta v } G   \\end{cases} \\] <p>Pole p\u0159edch\u016fdc\u016f \\(P\\) takov\u00e9, \u017ee:</p> \\[ P [v] = \\begin{cases}  w &amp; w \\text{ je p\u0159ed } v \\text{ na n\u011bjak\u00e9 nejkrat\u0161\u00ed s-v-cest\u011b v } G, \\\\ \\text{undef.} &amp; \\text{neexistuje \u017e\u00e1dn\u00e1 s-v-cesta v } G   \\end{cases} \\] <p>Algoritmus</p> <p>Algoritmus BFS(graf \\(G\\), vrchol \\(s\\))</p> <pre><code>Pro ka\u017ed\u00fd vrchol v \u2208 V (G):\n    stav[v] := nenalezen\u00fd\n    D[v] := P[v] := undef\nQ := fronta obsahuj\u00edc\u00ed jedin\u00fd vrchol s\nstav[s] := otev\u0159en\u00fd\nD[s] := 0, P[s] := \u22a5\nDokud je fronta Q nepr\u00e1zdn\u00e1:\n    Odeber z Q prvn\u00ed vrchol, nech\u0165 to je v\n    Pro v\u0161echny sousedy w vrcholu v:\n        Pokud stav[w] = nenalezen\u00fd:\n            stav[w] := otev\u0159en\u00fd\n            D[w] := D[v] + 1\n            P[w] := v\n            P\u0159idej w na konec fronty Q\n    stav[v] := uzav\u0159en\u00fd\nVra\u0165 (D, P)\n</code></pre>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.2_BFS/#theorem-1.1","title":"V\u011bta o kone\u010dnosti BFS","text":"<p>Algoritmus BFS\\((G, s)\\) se v\u017edy zastav\u00ed.</p>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.2_BFS/#theorem-1.2","title":"V\u011bta o spr\u00e1vnosti BFS","text":"<ul> <li>Vlastnost 1: Po skon\u010den\u00ed BFS\\((G, s)\\) jsou uzav\u0159en\u00e9 pr\u00e1v\u011b ty vrcholy, do kter\u00fdch vede cesta ze startu \\(s\\) a ostatn\u00ed vrcholy z\u016fstanou nenalezen\u00e9.</li> <li>Vlastnost 2: Pro v\u0161echny uzav\u0159en\u00e9 vrcholy \\(v\\) plat\u00ed \\(D[v] = d(s, v) =\\) d\u00e9lka nejkrat\u0161\u00ed cesty ze startu \\(s\\) do vrcholu \\(v\\).</li> <li>Vlastnost 3: Pro v\u0161echny uzav\u0159en\u00e9 vrcholy \\(v\\) plat\u00ed \\(P [v] = w\\), kde \\(w\\) je p\u0159edch\u016fdce \\(v\\) na n\u011bjak\u00e9 nejkrat\u0161\u00ed cest\u011b ze startu \\(s\\) do vrcholu \\(v\\).</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.2_BFS/#def-1.4","title":"F\u00e1ze a Hladiny BFS","text":"<ul> <li>Hladina \\(H_{0}\\) = {\\(s\\)}.</li> <li>F\u00e1ze \\(F_{0}\\) trv\u00e1 od odebr\u00e1n\u00ed \\(s\\) z \\(Q\\), otev\u0159en\u00ed a vlo\u017een\u00ed v\u0161ech jeho soused\u016f do \\(Q\\) a\u017e do uzav\u0159en\u00ed \\(s\\).</li> <li>Hladina \\(H_{i}\\) je mno\u017eina v\u0161ech vrchol\u016f otev\u0159en\u00fdch a vlo\u017een\u00fdch do  \\(Q\\) ve f\u00e1zi \\(F_{i\u22121}\\).</li> <li>F\u00e1ze \\(F_{i}\\) trv\u00e1 od konce f\u00e1ze \\(F_{i\u22121}\\) a\u017e po uzav\u0159en\u00ed v\u0161ech vrchol\u016f z \\(H_{i}\\) (zahrnuje tedy vybr\u00e1n\u00ed v\u0161ech vrchol\u016f z \\(H_{i}\\) z \\(Q\\), otev\u0159en\u00ed jejich dosud nenalezen\u00fdch soused\u016f a vlo\u017een\u00ed t\u011bchto soused\u016f do \\(Q\\)).</li> <li>Nech\u0165 \\(h\\) je \u010d\u00edslo posledn\u00ed f\u00e1ze BFS\\((G, s)\\) (po n\u00ed se BFS\\((G, s)\\) zastav\u00ed).</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/","title":"1.3 B\u011b\u017en\u00e9 grafy","text":"<p>Definice 1.5 (\u00dapln\u00fd graf \\(K_{n}\\)  Klika)</p> <p></p> <p>Definice 1.6 (\u00dapln\u00fd bipartitn\u00ed graf \\(K_{n_{1},n_{2}}\\))</p> <p></p> <p>Definice 1.7 (Cesta \\(P_{n}\\))</p> <p></p> <p>Definice 1.8 (Kru\u017enice \\(C_{n}\\))</p> <p></p> <p>Definice 1.9 (Dopln\u011bk grafu)</p> <p></p> <p>Definice 1.10 (Okol\u00ed vrcholu, stupe\u0148 vrcholu)</p> <p>Plat\u00ed tedy \\(deg_{G}(v) = |N_{G}(v)|\\)</p> <p></p> <p>Definice 1.11 (Regul\u00e1rn\u00ed graf)</p> <p></p> <p>Definice 1.12 (Izolovan\u00fd vrchol)</p> <p>K zamy\u0161len\u00ed</p> <ul> <li>Jak vypad\u00e1 0-regul\u00e1rn\u00ed graf o n vrcholech?</li> <li>Jak vypad\u00e1 1-regul\u00e1rn\u00ed graf o n vrcholech?</li> <li>Existuje 1-regul\u00e1rn\u00ed graf s lich\u00fdm po\u010dtem vrchol\u016f?</li> <li>Jak vypad\u00e1 2-regul\u00e1rn\u00ed graf o n vrcholech?</li> <li>Existuje 2-regul\u00e1rn\u00ed graf s lich\u00fdm po\u010dtem vrchol\u016f?</li> <li>Kolik existuje neizomorfn\u00edch 2-regul\u00e1rn\u00edch graf\u016f o n vrcholech?</li> </ul> <p></p> <p>V\u011bta 1.3 (O principu sudosti)</p> D\u016fkaz V\u011bty 1.3 <p>Pos\u010d\u00edt\u00e1me-li stupn\u011b v\u0161ech vrchol\u016f, zapo\u010d\u00edt\u00e1me ka\u017edou hranu p\u0159esn\u011b dvakr\u00e1t, co\u017e d\u00e1v\u00e1 sou\u010det \\(2|E|\\).</p> \\[ \\begin{align} &amp; \\sum_{v \\in V}{deg_{G}(v)} = \\sum_{v \\in V}{|N_{G}(v)|} = \\sum_{v \\in V}{|\\{u \\in V | \\{u,v\\} \\in E \\}|} \\\\ \\\\ &amp; = \\sum_{v \\in V}{|\\{e \\in E | v \\in e \\}|} = \\sum_{v \\in V}{}\\sum_{e \\in E | v \\in e}{1} = \\sum_{e \\in E}{\\sum_{v \\in e}{1}} = \\sum_{e \\in E}{2} = 2 |E| \\end{align} \\] <p>D\u016fsledek 1.1</p> <p>V\u011bta o principu sudosti m\u00e1 \u0159adu d\u016fsledk\u016f.</p> <ol> <li>V ka\u017ed\u00e9m grafu je po\u010det vrchol\u016f lich\u00e9ho stupn\u011b sud\u00fd.</li> <li>Ka\u017ed\u00fd regul\u00e1rn\u00ed graf lich\u00e9ho stupn\u011b mus\u00ed m\u00edt sud\u00fd po\u010det vrchol\u016f.</li> </ol> <p></p> <p>Definice 1.13 (Podgraf)</p> <p></p> <p>Definice 1.14 (Bipartitn\u00ed graf)</p> <p></p> <p>Definice 1.15 (Klika v grafu \\(G\\))</p> <p></p> <p>Definice 1.16 (Orientovan\u00fd graf)</p>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.5","title":"\u00dapln\u00fd graf - Klika","text":"<ul> <li>Nech\u0165 \\(n \u2265 1\\).</li> <li>\u00dapln\u00fd graf na \\(n\\) vrcholech \\(K_{n}\\) je graf \\((V, \\binom{V}{2} )\\), kde \\(|V| = n\\).</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.6","title":"\u00dapln\u00fd bipartitn\u00ed graf","text":"<ul> <li>Nech\u0165 \\(n_{1} \u2265 1\\) a \\(n_{2} \u2265 1\\).</li> <li>\u00dapln\u00fd bipartitn\u00ed graf \\(K_{n_{1},n_{2}}\\) tvo\u0159en\u00fd dv\u011bma partitami o \\(n_{1}\\) a \\(n_{2}\\) vrcholech je graf \\((A \\cup B\\), {{\\(a\\), \\(b\\)} | \\(a \\in A, b \\in B\\)}), kde \\(A \\cap B = \\emptyset, |A| = n_{1}\\) a \\(|B| = n_{2}\\).</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.7","title":"Cesta","text":"<ul> <li>Nech\u0165 \\(n \u2265 1\\).</li> <li>Cesta s \\(n\\) vrcholy (s \\(n \u2212 1\\) hranami) \\(P_{n}\\) je graf:  ({\\(1, . . . , n\\)}, {{\\(i, i + 1\\)} | \\(i \\in\\) {\\(1, . . . , n \u2212 1\\)}}).</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.8","title":"Kru\u017enice","text":"<ul> <li>Nech\u0165 \\(n \u2265 3\\)</li> <li>Kru\u017enice d\u00e9lky \\(n\\) (s \\(n\\) vrcholy) \\(C_{n}\\) je graf ({\\(1, . . . , n\\)}, {{\\(i, i + 1\\)} | \\(i \\in\\) {\\(1, . . . , n \u2212 1\\)}} \\(\\cup\\) {{\\(n, 1\\)}})</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.9","title":"Dopln\u011bk grafu","text":"<p>Dopln\u011bk \\(\\overline{G}\\) grafu \\(G = (V, E)\\) je graf \\((V, (\\binom{V}{2}) \\setminus E)\\).</p>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.10","title":"Okol\u00ed vrcholu a stupe\u0148 vrcholu","text":"<p>Nech\u0165 \\(G = (V, E)\\) je graf a \\(v \\in V\\) jeho vrchol.</p> <ul> <li>Symbolem \\(deg_{G}(v)\\) ozna\u010d\u00edme po\u010det hran grafu \\(G\\) obsahuj\u00edc\u00edch vrchol \\(v\\).  Toto \u010d\u00edslo nazveme stupn\u011bm vrcholu \\(v\\) v grafu \\(G\\).</li> <li>Symbolem \\(N_{G}(v)\\) ozna\u010d\u00edme mno\u017einu v\u0161ech soused\u016f vrcholu \\(v\\) v grafu \\(G\\).  Tuto mno\u017einu nazveme (otev\u0159en\u00e9) okol\u00ed vrcholu \\(v\\) v grafu \\(G\\).</li> <li>Mno\u017einu \\(N_{G}[v] = N_{G}(v) \\cup \\{v\\}\\) nazveme uzav\u0159en\u00fdm okol\u00edm vrcholu \\(v\\) v grafu \\(G\\).</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.11","title":"Regul\u00e1rn\u00ed graf","text":"<ul> <li>Graf je r-regul\u00e1rn\u00ed, pokud stupe\u0148 ka\u017ed\u00e9ho jeho vrcholu je \\(r\\).</li> <li>Graf je regul\u00e1rn\u00ed, pokud je r-regul\u00e1rn\u00ed pro n\u011bjak\u00e9 \\(r\\).</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.12","title":"Izolovan\u00fd vrchol","text":"<ul> <li>Vrchol stupn\u011b \\(0\\) nazveme izolovan\u00fd (nem\u00e1 \u017e\u00e1dn\u00e9 sousedy).</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#theorem-1.3","title":"V\u011bta o principu sudosti","text":"<p>Pro ka\u017ed\u00fd graf \\(G = (V, E)\\) plat\u00ed:</p> \\[ \\sum_{v \\in V}{deg_{G}(v) = 2|E|} \\]"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.13","title":"Podgraf","text":"<ul> <li>Graf \\(H\\) je podgrafem grafu \\(G\\), kdy\u017e \\(V (H) \\subseteq V (G)\\) a \\(E(H) \\subseteq E(G)\\). </li> <li>Graf \\(H\\) je indukovan\u00fdm podgrafem grafu \\(G\\), kdy\u017e \\(V (H) \\subseteq V (G)\\) a \\(E(H) = E(G) \\cap \\binom{V(H)}{2}\\). </li> <li>Je-li \\(G = (V, E)\\) a \\(V' \\subseteq V\\) , pak \\(G[V']\\) ozna\u010duje graf s mno\u017einou vrchol\u016f \\(V'\\) a mno\u017einou hran \\(E(G) \\cap \\binom{V'}{2}\\).  \u0158\u00edk\u00e1me, \u017ee \\(G[V']\\) je podgraf indukovan\u00fd mno\u017einou vrchol\u016f \\(V'\\).  Graf \\(G[V \\setminus V']\\) budeme zapisovat zkr\u00e1cen\u011b \\(G \u2212 V'\\).  A speci\u00e1ln\u011b, pokud \\(V' = \\{v\\}\\), pak p\u00ed\u0161eme \\(G \u2212 v\\) m\u00edsto \\(G \u2212 \\{v\\}\\)</li> </ul>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.14","title":"Bipartitn\u00ed graf","text":"<p>Podgraf \u00fapln\u00e9ho bipartitn\u00edho grafu je bipartitn\u00ed graf</p>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.15","title":"Klika v grafu G","text":"<p>Klika v grafu G je podmno\u017eina vrchol\u016f, z nich\u017e ka\u017ed\u00e9 dva jsou sousedn\u00ed (\u010dili spojeny hranou).</p>"},{"location":"01_Z%C3%A1klady_graf%C5%AF/1.3_B%C4%9B%C5%BEn%C3%A9_grafy/#def-1.16","title":"Orientovan\u00fd graf","text":"<p>Orientovan\u00fd graf \\(G\\) je uspo\u0159\u00e1dan\u00e1 dvojice \\((V, E)\\), kde</p> <ul> <li>\\(V\\) je nepr\u00e1zdn\u00e1 kone\u010dn\u00e1 mno\u017eina vrchol\u016f a</li> <li>\\(E\\) je mno\u017eina orientovan\u00fdch hran (zobrazujeme jako \u0161ipky).</li> </ul> <p>Orientovan\u00e1 hrana \\((u, v) \\in E\\) je uspo\u0159\u00e1dan\u00e1 dvojice vrchol\u016f \\(u, v \\in V\\) .  \u0158\u00edk\u00e1me, \u017ee \\(u\\) je p\u0159edch\u016fdce \\(v\\) a \\(v\\) je n\u00e1sledn\u00edk \\(u\\).  \u0158\u00edk\u00e1me, \u017ee orientovan\u00e1 hrana \\((u, u)\\) je smy\u010dka.</p>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/","title":"2.1 Souvislost graf\u016f","text":""},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#souvislost-neorientovanych-grafu","title":"Souvislost (neorientovan\u00fdch) graf\u016f","text":"<p>Definice 2.1 (Souvislost grafu)</p> <p></p> <p>Definice 2.2 (Souvisl\u00e1 komponenta)</p> <p>Pozorov\u00e1n\u00ed</p> <p>Graf je souvisl\u00fd pr\u00e1v\u011b tehdy, kdy\u017e obsahuje jedinou souvislou komponentu.</p> D\u016fkaz <ul> <li> <p>\\(\\Rightarrow\\) Sporem. Je-li souvisl\u00fd, pak nem\u016f\u017ee obsahovat v\u00edce ne\u017e jednu souvislou komponentu, proto\u017ee vrcholy a hrany komponent jsou disjunktn\u00ed, a pokud by existovaly alespo\u0148 dv\u011b komponenty, pak by existovaly dva vrcholy v jednotliv\u00fdch komponent\u00e1ch tak, \u017ee by mezi nimi neexistovala cesta, a tedy dan\u00fd graf by nebyl souvisl\u00fd.</p> </li> <li> <p>\\(\\Leftarrow\\) Obsahuje-li graf jedinou souvislou komponentu, pak je z definice komponenty souvisl\u00fd.</p> </li> </ul> <p>Tvrzen\u00ed</p> <p>Bin\u00e1rn\u00ed relace \\(\\leftrightsquigarrow\\) nad vrcholy grafu \\(G\\) definovan\u00e1 p\u0159edpisem</p> \\[ u \\leftrightsquigarrow v \\iff \\exists\\text{ } u\\text{-}v\\text{-cesta v } G \\] <p>je ekvivalence, jej\u00ed\u017e t\u0159\u00eddy ekvivalence indukuj\u00ed souvisl\u00e9 komponenty grafu \\(G\\).</p>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#def-2.1","title":"Souvislost grafu","text":"<p>Graf \\(G\\) je souvisl\u00fd, jestli\u017ee v n\u011bm pro ka\u017ed\u00e9 jeho dva vrcholy \\(u\\), \\(v\\) existuje u-v-cesta.  Jinak je \\(G\\) nesouvisl\u00fd.</p>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#def-2.2","title":"Souvisl\u00e1 komponenta","text":"<p>Indukovan\u00fd podgraf \\(H\\) grafu \\(G\\) je souvislou komponentou, pokud:</p> <ul> <li>je souvisl\u00fd a </li> <li>neexistuje \u017e\u00e1dn\u00fd souvisl\u00fd podgraf \\(F\\) , \\(F \\neq H\\), grafu \\(G\\) takov\u00fd, \u017ee \\(H \\subseteq F\\).</li> </ul> <p>Souvisl\u00e1 komponenta je tedy v inkluzi maxim\u00e1ln\u00ed souvisl\u00fd podgraf grafu \\(G\\).</p>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#souvislost-orientovanych-grafu","title":"Souvislost orientovan\u00fdch graf\u016f","text":"<ul> <li>Pojmy souvislost a souvisl\u00e1 komponenta neorientovan\u00fdch graf\u016f nelze jednodu\u0161e pou\u017e\u00edt pro orientovan\u00e9 grafy.</li> </ul> <p>Definice 2.3 (Symetrizace orientovan\u00e9ho grafu)</p> <p>Symetrizace tedy odstran\u00ed z grafu informace o orientaci hran.</p> <p></p> <p>Definice 2.4 (Slab\u00e1 souvislost orientovan\u00e9ho grafu)</p> <p>Testovat slabou souvislost orientovan\u00e9ho grafu tedy znamen\u00e1 testovat, nap\u0159. pomoc\u00ed algoritmu BFS, souvislost jeho symetrizace, co\u017e je neorientovan\u00fd graf.</p> <p></p> <p>Definice 2.5 (Siln\u00e1 souvislost orientovan\u00e9ho grafu)</p>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#def-2.3","title":"Symetrizace orientovan\u00e9ho grafu","text":"<p>Symetrizace orientovan\u00e9ho grafu \\(G = (V, E)\\) je neorientovan\u00fd graf  sym\\((G) = (V, E')\\), kde:  \\(\\phantom{XXXX}\\{u, v\\} \\in E'\\) pr\u00e1v\u011b tehdy, kdy\u017e \\((u, v) \\in E\\) nebo \\((v, u) \\in E\\).</p>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#def-2.4","title":"Slab\u00e1 souvislost orientovan\u00e9ho grafu","text":"<p>Orientovan\u00fd graf \\(G = (V, E)\\) nazveme slab\u011b souvisl\u00fd, pokud je souvisl\u00e1 jeho symetrizace sym\\((G)\\).</p>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#def-2.5","title":"Siln\u00e1 souvislost orientovan\u00e9ho grafu","text":"<p>Orientovan\u00fd graf \\(G = (V, E)\\) nazveme siln\u011b souvisl\u00fd, pokud pro ka\u017ed\u00e9 dva vrcholy \\(u, v \\in V\\) existuje v \\(G\\) orientovan\u00e1 cesta z \\(u\\) do \\(v\\) a sou\u010dasn\u011b orientovan\u00e1 cesta z \\(v\\) do \\(u\\).</p>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#vysetrovani-souvislosti-grafu","title":"Vy\u0161et\u0159ov\u00e1n\u00ed souvislosti grafu","text":"<p>\u00daloha vy\u0161et\u0159ov\u00e1n\u00ed souvislosti grafu \\(G\\) m\u00e1 r\u016fzn\u00e9 podoby, nap\u0159.:</p> <ol> <li>Zjistit, zda je \\(G\\) souvisl\u00fd.</li> <li>Pokud nen\u00ed, identifikovat v\u0161echny souvisl\u00e9 komponenty.</li> <li>Je-li zad\u00e1n vrchol \\(s\\), zkonstruovat souvislou komponentu, do kter\u00e9 \\(s\\) pat\u0159\u00ed.</li> </ol> <p>Vstup: Graf \\(G\\).  V\u00fdstup: Graf \\(s\\) ozna\u010den\u00fdmi souvisl\u00fdmi komponentami.</p> <p></p> <p>Algoritmus 2.1 (BFS_graf)</p> <p>Vstup: Graf \\(G\\) a jeden jeho vrchol \\(s\\).  V\u00fdstup: Graf \\(s\\) ozna\u010denou souvislou komponentou, ve kter\u00e9 le\u017e\u00ed vrchol \\(s\\).</p> <p></p> <p>Algoritmus 2.2 (DFS_graf)</p>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#algo-2.1","title":"BFS_graf","text":"Algoritmus BFS_graf (graf G):<pre><code>Pro ka\u017ed\u00fd vrchol u \u2208 V (G):\n    stav[u] := nenalezen\u00fd\n    D[u] := P[u] := undef\nPro ka\u017ed\u00fd vrchol s \u2208 V (G):\n    Pokud stav[s] = nenalezen\u00fd:\n        BFS(G, s) \n</code></pre> BFS(graf G, vrchol s):<pre><code>Q := fronta obsahuj\u00edc\u00ed s\nstav[s] := otev\u0159en\u00fd, D[s] := 0, P[s] := \u22a5\nDokud je fronta Q nepr\u00e1zdn\u00e1:\n    Odeber z Q prvn\u00ed vrchol \u2192 v\n    Pro v\u0161echny sousedy w vrcholu v:\n        Pokud stav[w] = nenalezen\u00fd:\n            stav[w]:= otev\u0159en\u00fd\n            D[w]:= D[v]+1, P[w]:= v\n            P\u0159idej w na konec Q\n    stav[v] := uzav\u0159en\u00fd\n</code></pre>"},{"location":"02_Souvislost_graf%C5%AF/2.1_Souvislost_graf%C5%AF/#algo-2.2","title":"DFS_graf","text":"Algoritmus DFS_graf (graf G, vrchol s):<pre><code>Pro ka\u017ed\u00fd vrchol u \u2208 V (G):\n    stav[u] := nenalezen\u00fd\nDFS(s)\n</code></pre> DFS (vrchol v):<pre><code>Pokud stav[v] = otev\u0159en\u00fd nebo uzav\u0159en\u00fd:\n    return\nstav[v] := otev\u0159en\u00fd\nPro ka\u017ed\u00e9ho souseda u vrcholu v:\n    DFS(u)\nstav[v] := uzav\u0159en\u00fd\n</code></pre>"},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/","title":"2.2 Reprezentace graf\u016f","text":""},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/#ram-a-slozitost","title":"RAM a slo\u017eitost","text":"<p>Definice 2.6 (V\u00fdpo\u010detn\u00ed model RAM)</p> <p></p> <p>Definice 2.7 (Slo\u017eitost programu)</p>"},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/#def-2.6","title":"V\u00fdpo\u010detn\u00ed model RAM","text":"<p>Random Access Machine</p> <ul> <li>Pam\u011b\u0165 RAMu tvo\u0159\u00ed pole celo\u010d\u00edseln\u00fdch pam\u011b\u0165ov\u00fdch bun\u011bk adresovateln\u00fdch cel\u00fdmi \u010d\u00edsly.</li> <li>Program je kone\u010dn\u00e1 posloupnost sekven\u010dn\u011b prov\u00e1d\u011bn\u00fdch instrukc\u00ed dvou typ\u016f:   aritmeticko-logick\u00fdch a \u0159\u00eddic\u00edch.</li> <li>Aritmeticko-logick\u00e9 instrukce maj\u00ed obvykle dva vstupn\u00ed argumenty a jeden v\u00fdstupn\u00ed argument. Argument m\u016f\u017ee b\u00fdt:<ul> <li>p\u0159\u00edm\u00e1 konstanta (s v\u00fdjimkou v\u00fdstupn\u00edho argumentu),</li> <li>p\u0159\u00edmo adresovan\u00e1 pam\u011b\u0165ov\u00e1 bu\u0148ka (adresa je p\u0159\u00edmo zad\u00e1na),</li> <li>nep\u0159\u00edmo adresovan\u00e1 pam\u011b\u0165ov\u00e1 bu\u0148ka (jej\u00ed adresa je ulo\u017eena v p\u0159\u00edmo adresovan\u00e9 bu\u0148ce).</li> </ul> </li> <li>\u0158\u00eddic\u00ed instrukce jsou skoky (na konkr\u00e9tn\u00ed instrukci programu), podm\u00edn\u011bn\u00e9 skoky (nap\u0159\u00edklad kdy\u017e se dva argumenty instrukce rovnaj\u00ed) a instrukci zastaven\u00ed programu.</li> </ul> <ul> <li>Na za\u010d\u00e1tku v\u00fdpo\u010dtu obsahuje pam\u011b\u0165 v ur\u010den\u00fdch bu\u0148k\u00e1ch vstup a obsah ostatn\u00edch bun\u011bk je nedefinov\u00e1n.</li> <li>Potom je program sekven\u010dn\u011b prov\u00e1d\u011bn, instrukce za instrukc\u00ed.</li> <li>Procesor v ka\u017ed\u00e9m kroku provede pr\u00e1v\u011b jednu instrukci.</li> <li>Po zastaven\u00ed programu je obsah pam\u011bti v ur\u010den\u00fdch bu\u0148k\u00e1ch interpretov\u00e1n jako v\u00fdstup programu</li> </ul>"},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/#def-2.7","title":"Slo\u017eitost programu","text":"<ul> <li>Velikost vstupu je po\u010det pam\u011b\u0165ov\u00fdch bun\u011bk, kter\u00e9 vstup zab\u00edr\u00e1.</li> <li>\u010casov\u00e1 slo\u017eitost programu (v nejhor\u0161\u00edm p\u0159\u00edpad\u011b) pro vstup velikosti \\(N\\) je maximum z po\u010dtu vykonan\u00fdch instrukc\u00ed p\u0159es v\u0161echny mo\u017en\u00e9 (povolen\u00e9) vstupy velikosti nejv\u00fd\u0161e \\(N\\).</li> <li>Pam\u011b\u0165ov\u00e1 slo\u017eitost programu (v nejhor\u0161\u00edm p\u0159\u00edpad\u011b) pro vstup velikosti \\(N\\) je maximum z po\u010dtu pou\u017eit\u00fdch pam\u011b\u0165ov\u00fdch bun\u011bk p\u0159es v\u0161echny mo\u017en\u00e9 (povolen\u00e9) vstupy velikosti nejv\u00fd\u0161e \\(N\\).</li> </ul>"},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/#reprezentace-grafu","title":"Reprezentace grafu","text":"<p>Jak reprezentovat (neorientovan\u00e9) grafy v pam\u011bti po\u010d\u00edta\u010de?</p> <ul> <li>Matice sousednosti</li> <li>Seznam soused\u016f</li> </ul> <p></p> <p>Definice 2.8 (Matice sousednosti)</p> <p>Pozorov\u00e1n\u00ed</p> <ul> <li>\\(A_{G}\\) je symetrick\u00e1 matice</li> <li>Pam\u011b\u0165ov\u00e1 n\u00e1ro\u010dnost reprezentace: \\(O(n^{2})\\)</li> </ul> <p></p> <p>Definice 2.9 (Seznam soused\u016f)</p> <p>Pozorov\u00e1n\u00ed</p> <p>Celkem tedy pam\u011b\u0165ov\u00e1 slo\u017eitost: \\(O(n + m)\\).</p>"},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/#def-2.8","title":"Matice sousednosti","text":"<p>Nech\u0165 \\(G = (V, E)\\) je graf s \\(V = \\{v_{1}, v_{2}, ... , v_{n}\\}\\).  Matice sousednosti grafu \\(G\\) je \u010dtvercov\u00e1 matice \\(A_{G} = (a_{i,j} )^{n}_{i,j=1}\\) </p> \\[ a_{i,j} = \\begin{cases}  1 &amp; \\text{kdy\u017e } \\{v_{i}, v_{j}\\} \\in E, \\\\ 0 &amp; \\text{jinak} \\\\ \\end{cases} \\]"},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/#def-2.9","title":"Seznam soused\u016f","text":"<p>Pro ka\u017ed\u00fd vrchol v grafu \\(G = (V, E)\\) uchov\u00e1v\u00e1me seznam jeho soused\u016f (nap\u0159. spojov\u00fd seznam).  Pam\u011b\u0165ov\u00e1 slo\u017eitost: \\(|V|\\) za\u010d\u00e1tk\u016f seznam\u016f a dohromady \\(2|E|\\) prvk\u016f v seznamech (ka\u017ed\u00e1 hrana znamen\u00e1 dva v\u00fdskyty).</p>"},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/#orientovany-graf","title":"Orientovan\u00fd graf","text":"<p>Orientovan\u00e9 grafy reprezentujeme ve stejn\u00fdch struktur\u00e1ch jako neorientovan\u00e9 grafy:</p> <ul> <li>matic\u00ed sousednosti</li> <li>seznamem soused\u016f</li> </ul> <p>pouze m\u00edsto seznamu soused\u016f \u0159\u00edk\u00e1me seznam n\u00e1sledn\u00edk\u016f:</p>"},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/#analyza-casove-slozitosti-bfs","title":"Anal\u00fdza \u010dasov\u00e9 slo\u017eitosti BFS","text":"<p>V\u011bta 2.1 (O \u010dasov\u00e9 slo\u017eitosti algoritmu BFS_graf)</p> D\u016fkaz V\u011bty 2.1 <ol> <li>V glob\u00e1ln\u00edm seznamu stavu vrchol\u016f se ka\u017ed\u00fd vrchol vyjme nanejv\u00fd\u0161 jednou a pot\u00e9 se pust\u00ed BFS z n\u011bho.</li> <li>Ka\u017ed\u00fd vrchol je p\u0159id\u00e1n do fronty \\(Q\\) nejv\u00fd\u0161e jednou.</li> <li>V ka\u017ed\u00e9 iteraci cyklu \\((9)\\)\u2013\\((16)\\) je jeden vrchol odebr\u00e1n z fronty, tento cyklus m\u00e1 tedy nejv\u00fd\u0161e \\(|V|\\) iterac\u00ed.</li> <li>Celkov\u00fd po\u010det iterac\u00ed cyklu \\((11)\\)\u2013\\((15)\\) je nejv\u00fd\u0161e dvakr\u00e1t tolik, kolik je v grafu hran  (nebo\u0165 pro ka\u017ed\u00fd vrchol proch\u00e1z\u00edme jen hrany a vrcholy v jeho komponent\u011b souvislosti).</li> <li>Celkov\u00e1 \u010dasov\u00e1 slo\u017eitost je tedy \\(O(|V| + |E|)\\).</li> </ol>"},{"location":"02_Souvislost_graf%C5%AF/2.2_Reprezentace_graf%C5%AF/#veta-o-casove-slozitosti-bfs","title":"V\u011bta o \u010dasov\u00e9 slo\u017eitosti BFS","text":"<p>Algoritmus BFS_graf(\\(G\\)) m\u00e1 p\u0159i reprezentaci grafu \\(G\\) seznamem soused\u016f \u010dasovou slo\u017eitost \\(O(|V| + |E|)\\).</p>"},{"location":"02_Souvislost_graf%C5%AF/2.3_Izomorfismus/","title":"2.3 Izomorfismus","text":"<p>Definice 2.10 (Izomorfismus graf\u016f)</p> <p></p> <p>Definice 2.11 (Automorfismus grafu)</p> <ul> <li>Neform\u00e1ln\u011b \u0159e\u010deno: Automorfismus je permutace vrchol\u016f, zachov\u00e1vaj\u00edc\u00ed \"b\u00fdti hranou\". </li> <li>Automorfismy ukazuj\u00ed \"symetrie\" grafu. </li> <li>Mno\u017estv\u00ed automorfism\u016f tedy ukazuje na m\u00edru pravidelnosti grafu.</li> </ul> <p></p> <p>Pozorov\u00e1n\u00ed 2.1 (O po\u010dtu graf\u016f)</p>"},{"location":"02_Souvislost_graf%C5%AF/2.3_Izomorfismus/#def-2.10","title":"Izomorfismus graf\u016f","text":"<p>Nech\u0165 \\(G\\) a \\(H\\) jsou dva grafy.  Funkce \\(f : V (G) \u2192 V (H)\\) je izomorfismus graf\u016f \\(G\\) a \\(H\\), pokud</p> <ul> <li>\\(f\\) je bijekce</li> <li>a pro ka\u017edou dvojici vrchol\u016f \\(u\\), \\(v\\) z \\(V(G)\\) plat\u00ed  \\(\\{u, v\\} \\in E(G)\\) pr\u00e1v\u011b tehdy, kdy\u017e \\(\\{f (u), f (v)\\} \\in E(H)\\).</li> </ul> <p>Dva grafy \\(G\\) a \\(H\\) jsou izomorfn\u00ed, pokud existuje izomorfismus graf\u016f \\(G\\) a \\(H\\).  Tento fakt zna\u010d\u00edme \\(G \\simeq H\\)</p>"},{"location":"02_Souvislost_graf%C5%AF/2.3_Izomorfismus/#def-2.11","title":"Automorfismus grafu","text":"<p>Automorfismus grafu \\(G\\) je izomorfismus se sebou sam\u00fdm,  tedy funkce \\(f : V (G) \\to V (G)\\) takov\u00e1, \u017ee</p> <ul> <li>\\(f\\) je bijekce</li> <li>a pro ka\u017edou dvojici vrchol\u016f \\(u, v \\in V(G)\\) plat\u00ed  \\(\\{u, v\\} \\in E(G)\\) pr\u00e1v\u011b tehdy, kdy\u017e \\(\\{f (u), f (v)\\} \\in E(G)\\).</li> </ul>"},{"location":"02_Souvislost_graf%C5%AF/2.3_Izomorfismus/#implication-2.1","title":"Pozorov\u00e1n\u00ed o po\u010dtu graf\u016f","text":"<p>Na \\(n\\)-prvkov\u00e9 mno\u017ein\u011b vrchol\u016f \\(V\\) je pr\u00e1v\u011b \\(2^{\\binom{n}{2}}\\) r\u016fzn\u00fdch graf\u016f</p> <ul> <li>Navz\u00e1jem neizomorfn\u00edch graf\u016f na \\(V\\) je m\u00e9n\u011b.</li> <li>Nap\u0159. pro \\(V = \\{1, 2, 3\\}\\) dost\u00e1v\u00e1me \\(2^\\binom{3}{2}\\) = \\(2^{3}\\) = 8 v\u0161ech graf\u016f, z nich\u017e ale jen 4 jsou neizomorfn\u00ed.</li> <li>Pozn.: Binomi\u00e1ln\u00ed \u010d\u00edslo \\(\\binom{n}{k}\\) ozna\u010duje po\u010det \\(k\\)-prvkov\u00fdch podmno\u017ein z \\(n\\)-prvkov\u00e9 mno\u017einy.</li> </ul>"},{"location":"03_Stromy/3.1_Z%C3%A1kladn%C3%AD_pojmy/","title":"3.1 Z\u00e1kladn\u00ed pojmy","text":""},{"location":"03_Stromy/3.1_Z%C3%A1kladn%C3%AD_pojmy/#strom-les-list","title":"Strom, Les, List","text":"<p>Definice 3.1 (Strom)</p> <p></p> <p>Definice 3.2 (Les)</p> <p></p> <p>Definice 3.3 (List)</p> <p></p> <p>V\u011bta 3.1 (o existenci list\u016f)</p> D\u016fkaz V\u011bty 3.1 <ol> <li>Nech\u0165 \\(P\\) je nejdel\u0161\u00ed cesta v \\(T\\).</li> <li>Nech\u0165 \\(u\\) a \\(v\\) jsou jej\u00ed koncov\u00e9 vrcholy.</li> <li>Sporem uk\u00e1\u017eeme, \u017ee \\(u\\) a \\(v\\) jsou listy.</li> <li>Kdyby z \\(u\\) vedly aspo\u0148 dv\u011b hrany, jedna z nich bude pat\u0159it do \\(u\\)-\\(v\\)-cesty \\(P\\) a zb\u00fdvat bude je\u0161t\u011b aspo\u0148 jedna hrana \\(e = \\{u, w\\}\\).</li> <li>Kdyby \\(w \\in V(P)\\), byla by v \\(T\\) kru\u017enice.</li> <li>Kdyby \\(w \\notin V(P)\\), cesta \\(P\\) by \u0161la prodlou\u017eit a nebyla by tedy nejdel\u0161\u00ed.</li> <li>To sam\u00e9 plat\u00ed pro koncov\u00fd vrchol \\(v\\) - SPOR.</li> </ol> <p>D\u016fsledek</p> <p>Proto\u017ee cesty jsou stromy, existuj\u00ed stromy, maj\u00edc\u00ed pr\u00e1v\u011b dva listy.</p>"},{"location":"03_Stromy/3.1_Z%C3%A1kladn%C3%AD_pojmy/#def-3.1","title":"Strom","text":"<p>Graf \\(G\\) nazveme stromem, pokud je souvisl\u00fd a neobsahuje \u017e\u00e1dnou kru\u017enici (\u010dili je acyklick\u00fd).</p>"},{"location":"03_Stromy/3.1_Z%C3%A1kladn%C3%AD_pojmy/#def-3.2","title":"Les","text":"<p>Graf \\(G\\) nazveme lesem, pokud neobsahuje \u017e\u00e1dnou kru\u017enici. </p>"},{"location":"03_Stromy/3.1_Z%C3%A1kladn%C3%AD_pojmy/#def-3.3","title":"List","text":"<p>Vrchol v grafu \\(G\\) nazveme listem, pokud \\(deg_{G}(v) = 1\\).</p>"},{"location":"03_Stromy/3.1_Z%C3%A1kladn%C3%AD_pojmy/#theorem-3.1","title":"V\u011bta o existenci list\u016f","text":"<p>Ka\u017ed\u00fd strom \\(T\\) s aspo\u0148 \\(2\\) vrcholy obsahuje aspo\u0148 dva listy.</p>"},{"location":"03_Stromy/3.1_Z%C3%A1kladn%C3%AD_pojmy/#listy-kruznice-a-souvislost-v-grafech","title":"Listy, kru\u017enice a souvislost v grafech","text":"<ul> <li>Uva\u017eujme graf \\(G = (V, E)\\), ve kter\u00e9m existuje list \\(v\\). Ozna\u010dme  \\(w\\) jeho souseda v \\(G\\). Pak odebr\u00e1n\u00ed listu \\(v\\) z \\(G\\)   je operace, kterou vznikne graf \\(G \u2212 v = (V \\setminus \\{v\\}, E \\setminus \\{\\{w, v\\}\\})\\).</li> <li>Uva\u017eujme graf \\(G = (V, E)\\) a zvolme \\(w \\in V\\) . Pak p\u0159id\u00e1n\u00ed listu \\(v\\) k vrcholu \\(w, v \\notin V\\) , ke grafu \\(G\\) je   operace, kterou vznikne graf \\(G + v = (V \\cup \\{v\\}, E \\cup \\{\\{w, v\\}\\})\\).</li> </ul> <p>V\u011bta 3.2 (o trh\u00e1n\u00ed list\u016f)</p> D\u016fkaz V\u011bty 3.2 <p>(1) \\(G\\) je strom \\(\\implies\\) (2) \\(G \u2212 v\\) je strom:</p> <p>(1) \\(G \u2212 v\\) je souvisl\u00fd:</p> <ul> <li>Zvolme libovoln\u011b dva vrcholy \\(x, y \\in V \\setminus \\{v\\}\\) a cestu \\(P\\) mezi nimi v \\(G\\) (ta existuje, proto\u017ee \\(G\\) je souvisl\u00fd).</li> <li>\\(P\\) nem\u016f\u017ee obsahovat jin\u00e9 vrcholy stupn\u011b 1 ne\u017e \\(x\\), \\(y\\); tedy speci\u00e1ln\u011b neobsahuje \\(v\\)</li> <li>Dost\u00e1v\u00e1me tedy \\(P \\subseteq G \u2212 v\\) a tedy \\(G \u2212 v\\) je souvisl\u00fd.</li> </ul> <p>(2) \\(G \u2212 v\\) je bez kru\u017enic:</p> <ul> <li>\\(G \u2212 v\\) je podgraf \\(G\\) a tedy neobsahuje kru\u017enici.</li> </ul> <p>Tedy \\(G \u2212 v\\) je strom</p> <p>(2) \\(G - v\\) je strom \\(\\implies\\) (1) \\(G\\) je strom:</p> <p>(1) \\(G\\) je bez kru\u017enic:</p> <ul> <li>Vr\u00e1cen\u00edm listu \\(v\\) do grafu \\(G\\) (p\u0159id\u00e1n\u00edm listu ke stromu \\(G \u2212 v\\))  zjevn\u011b nevytvo\u0159\u00edme kru\u017enici.</li> </ul> <p>(2) \\(G\\) je souvisl\u00fd:</p> <ul> <li>Mezi ka\u017ed\u00fdmi dv\u011bma \\(x, y \\in V \\setminus \\{v\\}\\) vede cesta v \\(G \u2212 v\\).</li> <li>Cesta v \\(G\\) z libovoln\u00e9ho vrcholu \\(x\\) do \\(v\\) vznikne prodlou\u017een\u00edm cesty mezi \\(x\\) a \\(w\\) do vrcholu \\(v\\), kde \\(w\\) je (jedin\u00fd) soused listu \\(v\\).</li> </ul> <p>Tedy \\(G\\) je strom</p>"},{"location":"03_Stromy/3.1_Z%C3%A1kladn%C3%AD_pojmy/#theorem-3.2","title":"V\u011bta o trh\u00e1n\u00ed list\u016f","text":"<p>Nech\u0165 \\(G = (V, E)\\) je graf na aspo\u0148 2 vrcholech a nech\u0165 \\(v \\in V\\) je jeho list. Pak jsou n\u00e1sleduj\u00edc\u00ed tvrzen\u00ed ekvivalentn\u00ed: </p> <ol> <li>\\(G\\) je strom.</li> <li>\\(G \u2212 v\\) je strom</li> </ol>"},{"location":"03_Stromy/3.2_Charakterizace_strom%C5%AF/","title":"3.2 Charakterizace strom\u016f","text":"<p>Kombinace acykli\u010dnosti a souvislosti d\u00e1v\u00e1 strom\u016fm n\u011bkolik  unik\u00e1tn\u00edch vlastnost\u00ed a to umo\u017e\u0148uje n\u011bkolik alternativn\u00edch  charakterizac\u00ed strom\u016f.</p> <p></p> <p>V\u011bta 3.3 (o charakterizaci strom\u016f)</p> D\u016fkaz (1) \\(\\implies\\) (2) <p>(1) \\(G\\) je strom \\(\\implies\\) (2) \\(\\forall\\) 2 vrcholy \\(u, v \\in V\\) \\(\\exists\\) pr\u00e1v\u011b jedna \\(u\\)-\\(v\\)-cesta.</p> <p>PS: Obr\u00e1zek se dv\u011bma rozch\u00e1zej\u00edc\u00edmi se cestami</p> <ol> <li>Strom je souvisl\u00fd, proto \\(\\forall x, y \\in V\\) \\(\\exists\\) \\(x\\)-\\(y\\)-cesta.</li> <li>Pro spor p\u0159edpokl\u00e1dejme, \u017ee existuj\u00ed dva vrcholy \\(u\\) a \\(v\\), mezi kter\u00fdmi existuj\u00ed aspo\u0148 dv\u011b r\u016fzn\u00e9 cesty  \\(P_{1} = a_{1}, ... , a_{k}\\) a \\(P_{2} = b_{1}, ... , b_{l}\\) \\((\\)tedy \\(a_{1} = b_{1} = u\\) a \\(a_{k} = b_{l} = v)\\).</li> <li>Nech\u0165 \\(i \\geq 1\\) je nejmen\u0161\u00ed index takov\u00fd, \u017ee \\(a_{i} = b_{i}\\) a \\(a_{i+1} \\neq b_{i+1}\\).</li> <li>Ozna\u010dme \\(p, q &gt; i\\) takovou dvojici index\u016f, \u017ee \\(a_{p} = b_{q}\\) a \\(\\{a_{i+1}, . . . , a_{p\u22121}\\} \\cap \\{b_{i+1}, . . . , b_{q\u22121}\\} = \\emptyset\\).</li> <li>Pak ale vrcholy \\(\\{a_{i}, a_{i+1}, . . . , a_{p\u22121}, a_{p}\\}\\) a \\(\\{b_{i+1}, . . . , b_{q\u22121}\\}\\) dohromady tvo\u0159\u00ed v \\(G\\) kru\u017enici \u2013 SPOR</li> </ol> <pre><code>graph LR\nu -- a1b1 --&gt; a2/b2 --&gt; ai/bi\nai/bi --&gt; ai+1 --&gt; a.. --&gt; ap/bq\nai/bi --&gt; bi+1 --&gt; b.. --&gt; ap/bq\nap/bq --&gt; ... --&gt; ak/bl/v</code></pre> D\u016fkaz (2) \\(\\implies\\) (1) <p>(2) \\(\\forall 2\\) vrcholy \\(u, v \\in V \\exists\\) pr\u00e1v\u011b jedna \\(u\\)-\\(v\\)-cesta \\(\\implies\\) (1) \\(G\\) je strom.</p> <ol> <li>Z p\u0159edpokladu vypl\u00fdv\u00e1, \u017ee \\(G\\) je souvisl\u00fd.</li> <li>Pokud by v \\(G\\) byla kru\u017enice, tak by mezi n\u011bjak\u00fdmi dv\u011bma jej\u00edmi vrcholy existovaly alespo\u0148 dv\u011b r\u016fzn\u00e9 cesty, co\u017e je SPOR s p\u0159edpokladem.</li> <li>\\(G\\) je tedy strom.</li> </ol> D\u016fkaz (1) \\(\\implies\\) (3) <p>(1) \\(G\\) je strom \\(\\implies\\) (3) \\(G\\) je souvisl\u00fd a vynech\u00e1n\u00edm libovoln\u00e9 hrany vznikne nesouvisl\u00fd graf.</p> <ol> <li>Souvislost \\(G\\) je spln\u011bna trivi\u00e1ln\u011b.</li> <li>P\u0159edpokl\u00e1dejme pro spor, \u017ee existuje hrana \\(e = \\{u, v\\} \\in E\\) takov\u00e1, \u017ee graf \\(G \u2212 e = (V, E \\setminus \\{e\\})\\) je souvisl\u00fd.</li> <li>Pak v \\(G \u2212 e\\) mus\u00ed existovat \\(u\\)-\\(v\\)-cesta, kter\u00e1 se ale po p\u0159id\u00e1n\u00ed hrany \\(e\\) stane v grafu \\(G\\) kru\u017enic\u00ed, co\u017e je SPOR s p\u0159edpokladem, \u017ee \\(G\\) je strom.</li> </ol> D\u016fkaz (3) \\(\\implies\\) (1) <p>(3) \\(G\\) je souvisl\u00fd a vynech\u00e1n\u00edm libovoln\u00e9 hrany vznikne nesouvisl\u00fd graf \\(\\implies\\) (1) \\(G\\) je strom</p> <ol> <li>Souvislost \\(G\\) je spln\u011bna, sta\u010d\u00ed uk\u00e1zat neexistenci kru\u017enic v \\(G\\).</li> <li>P\u0159edpokl\u00e1dejme pro spor, \u017ee:<ul> <li>(1) vynech\u00e1n\u00edm lib. hrany v \\(G\\) vznikne nesouvisl\u00fd graf</li> <li>(2) \\(G\\) obsahuje kru\u017enici \\(C\\).</li> </ul> </li> <li>Vyjmeme-li z \\(G\\) ale libovolnou hranu \\(e = \\{x, y\\} \\in C\\), pak se \\(G\\) nerozpadne na dv\u011b komponenty,  proto\u017ee jak\u00e9koliv cest\u011b mezi libovoln\u00fdmi 2 vrcholy \\(u\\) a \\(v\\), kter\u00e1 p\u0159ed t\u00edm obsahovala \\(e\\), poskytne \\(C\\) alternativn\u00ed spojen\u00ed.</li> <li>Pro hrany kru\u017enice \\(C\\) tud\u00ed\u017e p\u0159edpoklad (1) neplat\u00ed \u2013 dostali jsme SPOR.</li> </ol> D\u016fkaz (1) \\(\\implies\\) (4) <p>(1) \\(G\\) je strom \\(\\implies\\) (4) \\(G\\) je souvisl\u00fd a \\(|V| = |E| + 1\\)</p> <p>V\u011bta o trh\u00e1n\u00ed list\u016f</p> <ol> <li>Souvislost \\(G\\) je spln\u011bna trivi\u00e1ln\u011b.</li> <li>Pro d\u016fkaz \\(|V| = |E| + 1\\) pou\u017eijeme indukci podle \\(|V|\\).</li> <li>Pro \\(|V| = 1\\) tvrzen\u00ed plat\u00ed trivi\u00e1ln\u011b. P\u0159edpokl\u00e1dejme \\(|V| \\gt 1\\).</li> <li>Dle V\u011bty o existenci list\u016f existuje v stromu \\(G\\) list \\(v\\).</li> <li>Graf \\(G' = G \u2212 v\\) je dle V\u011bty o trh\u00e1n\u00ed list\u016f op\u011bt strom.</li> <li>Dle induk\u010dn\u00edho p\u0159edpokladu tedy plat\u00ed \\(|V(G')| = |E(G')| + 1\\).</li> <li>Vr\u00e1t\u00edme-li list \\(v\\) do grafu \\(G\\), zv\u00fd\u0161\u00edme po\u010det vrchol\u016f i po\u010det hran o jedna. Proto  \\(|V | = |V (G')| + 1 = (|E(G')| + 1) + 1 = |E| + 1\\).</li> </ol> D\u016fkaz (4) \\(\\implies\\) (1) <p>V\u011bta o trh\u00e1n\u00ed list\u016f</p> <p>(4) \\(G\\) je souvisl\u00fd a \\(|V| = |E| + 1\\) \\(\\implies\\) (1) \\(G\\) je strom</p> <ol> <li>Indukc\u00ed podle \\(|V|\\). Pro \\(|V| = 1\\) tvrzen\u00ed trivi\u00e1ln\u011b plat\u00ed.</li> <li>Uk\u00e1\u017eeme nejd\u0159\u00edve, \u017ee z p\u0159edpokladu plyne, \u017ee v \\(G\\) existuje list.<ul> <li>Dle p\u0159edpokladu plat\u00ed \\(\\sum_{u \\in V}deg_{G}(u) = 2|E| = 2|V| - 2\\)</li> <li>Kdyby v\u0161echny stupn\u011b v \\(G\\) byly aspo\u0148 2,  pak \\(\\sum_{u \\in V}deg_{G}(u) \\geq 2|V|\\)</li> <li>Tedy n\u011bjak\u00fd vrchol mus\u00ed m\u00edt stupe\u0148 nejv\u00fd\u0161e 1. Ozna\u010dme ho \\(v\\).</li> <li>Proto\u017ee \\(G\\) je souvisl\u00fd, vrchol \\(v\\) nem\u016f\u017ee m\u00edt stupe\u0148 0.</li> <li>Vrchol \\(v\\) je tedy list.</li> </ul> </li> <li>Graf \\(G' = G \u2212 v\\) je souvisl\u00fd a spl\u0148uje \\(|V (G')| = |E(G')| + 1\\), nebo\u0165 jsme z \\(G\\) odebrali 1 vrchol a 1 hranu.</li> <li>\\(G'\\) je tedy dle induk\u010dn\u00edho p\u0159edpokladu strom.</li> <li>Dle V\u011bty o trh\u00e1n\u00ed list\u016f je tedy \\(G\\) tak\u00e9 strom</li> </ol>"},{"location":"03_Stromy/3.2_Charakterizace_strom%C5%AF/#theorem-3.3","title":"V\u011bta o charakterizaci strom\u016f","text":"<p>Nech\u0165 \\(G = (V, E)\\) je graf. Pak n\u00e1sleduj\u00edc\u00ed tvrzen\u00ed jsou ekvivalentn\u00ed:</p> <ol> <li>\\(G\\) je strom.</li> <li>Pro ka\u017ed\u00e9 dva vrcholy \\(u, v \\in V\\) existuje pr\u00e1v\u011b jedna \\(u\\)-\\(v\\)-cesta.</li> <li>\\(G\\) je souvisl\u00fd a vynech\u00e1n\u00edm libovoln\u00e9 hrany vznikne nesouvisl\u00fd graf.</li> <li>\\(G\\) je souvisl\u00fd a \\(|E| = |V| \u2212 1\\)</li> </ol>"},{"location":"03_Stromy/3.3_Kostra_grafu/","title":"3.3 Kostra grafu","text":""},{"location":"03_Stromy/3.3_Kostra_grafu/#motivace","title":"Motivace","text":"<ul> <li>Uva\u017eujme topologii po\u010d\u00edta\u010dov\u00e9 s\u00edt\u011b popsanou jako souvisl\u00fd graf, jeho\u017e hrany p\u0159edstavuj\u00ed komunika\u010dn\u00ed kabely mezi sm\u011brova\u010di.</li> <li>Ke ka\u017ed\u00e9mu sm\u011brova\u010di mohou b\u00fdt p\u0159ipojeny koncov\u00e9 po\u010d\u00edta\u010de.</li> <li>Chceme minimalizovat po\u010det komunika\u010dn\u00edch kabel\u016f tak, aby po\u010d\u00edta\u010dov\u00e1 s\u00ed\u0165 z\u016fstala funk\u010dn\u00ed, tedy aby libovoln\u00fd po\u010d\u00edta\u010d mohl  komunikovat s libovoln\u00fdm jin\u00fdm po\u010d\u00edta\u010dem d\u00edky tomu, \u017ee lze postavit mezi nimi komunika\u010dn\u00ed propojen\u00ed slo\u017een\u00e9 z 1 \u010di v\u00edce sm\u011brova\u010d\u016f.</li> <li>Probl\u00e9m, kter\u00e9 konkr\u00e9tn\u00ed kabely zvolit pro toto minim\u00e1ln\u00ed \u0159e\u0161en\u00ed, je probl\u00e9m konstrukce kostry grafu (angl. spanning tree) s\u00edt\u011b.</li> <li>Pokud nav\u00edc po\u017eadujeme, aby byl minim\u00e1ln\u00ed sou\u010det d\u00e9lek pou\u017eit\u00fdch kabel\u016f, dostaneme probl\u00e9m minim\u00e1ln\u00ed kostry.</li> </ul> <p>Definice 3.4 (Kostra grafu)</p> <p>Pozorov\u00e1n\u00ed</p> <ul> <li>Nesouvisl\u00e9 grafy nemaj\u00ed kostru, kostru m\u00e1 ka\u017ed\u00e1 souvisl\u00e1 komponenta.</li> <li>Kostra souvisl\u00e9ho grafu je tedy souvisl\u00fd podgraf nad stejnou mno\u017einou vrchol\u016f s nejmen\u0161\u00edm po\u010dtem hran.</li> <li>Souvisl\u00fd graf s kru\u017enicemi m\u00e1 v\u00edce r\u016fzn\u00fdch koster</li> </ul>"},{"location":"03_Stromy/3.3_Kostra_grafu/#def-3.4","title":"Kostra grafu","text":"<p>Nech\u0165 \\(G = (V, E)\\) je souvisl\u00fd graf. Podgraf \\(K\\) grafu \\(G\\) nazveme kostrou grafu \\(G\\), pokud \\(V(K) = V\\) a \\(K\\) je strom.</p>"},{"location":"03_Stromy/3.3_Kostra_grafu/#jak-najit-kostru-souvisleho-grafu","title":"Jak naj\u00edt kostru souvisl\u00e9ho grafu?","text":"<ul> <li>Tato \u00faloha se m\u016f\u017ee \u0159e\u0161it stejn\u011b efektivn\u011b jak prohled\u00e1v\u00e1n\u00edm grafu do hloubky tak prohled\u00e1v\u00e1n\u00edm do \u0161\u00ed\u0159ky.</li> <li>Uk\u00e1\u017eeme si jednoduchou modifikaci algoritmu BFS.</li> <li>P\u0159edpokl\u00e1dejme, \u017ee m\u00e1me ov\u011b\u0159eno, \u017ee vstupn\u00ed graf je souvisl\u00fd (minul\u00e1 p\u0159edn\u00e1\u0161ka).</li> </ul> <p>Vstup: Souvisl\u00fd graf \\(G\\) V\u00fdstup: Seznam hran n\u011bjak\u00e9 kostry grafu \\(G\\)</p>"},{"location":"03_Stromy/3.3_Kostra_grafu/#jak-je-treba-bfs-modifikovat","title":"Jak je t\u0159eba BFS modifikovat?","text":"<p>Pro odpov\u011b\u010f si sta\u010d\u00ed p\u0159ipomenout hladiny v BFS</p> <pre><code>graph TD\n    v0(H0):::level0\n    v0 --&gt; v1(H1):::level1\n    v0 --&gt; v2(H1):::level1\n    v0 --&gt; v7(H1):::level1\n    v1 --&gt; v4(H2):::level2\n    v1 --&gt; v3(H2):::level2\n    v2 --&gt; v5(H2):::level2\n    v7 --&gt; v6(H2):::level2\n    v3 --&gt; v8(H3):::level3\n    v1 -.- v2\n\n    classDef level0 fill:#00af00,stroke:#000,stroke-width:4px,color:#fff,shape:circle,align:center;\n    classDef level1 fill:#0000af,stroke:#000,stroke-width:2px,color:#fff,shape:circle,align:center;\n    classDef level2 fill:#afaf00,stroke:#000,stroke-width:2px,color:#fff,shape:circle,align:center;\n    classDef level3 fill:#ff6666,stroke:#000,stroke-width:2px,color:#fff,shape:circle,align:center;</code></pre> <p>Pozorov\u00e1n\u00ed</p> <p>Hrany do p\u0159edch\u016fdc\u016f tvo\u0159\u00ed kostru.</p> <p></p> <p>V\u011bta 3.4 (o spr\u00e1vnosti algoritmu BFS_kostra)</p> D\u016fkaz V\u011bty 3.4 <ol> <li>Ozna\u010dme \\(H\\) graf na mno\u017ein\u011b vrchol\u016f \\(V\\) s hranami do p\u0159edch\u016fdc\u016f (podle pole vypln\u011bn\u00e9ho algoritmem BFS).</li> <li>V\u00edme, \u017ee ka\u017ed\u00fd vrchol krom\u011b po\u010d\u00e1te\u010dn\u00edho vrcholu m\u00e1 pr\u00e1v\u011b jednoho p\u0159edch\u016fdce. Tedy \\(H\\) m\u00e1 pr\u00e1v\u011b \\(n \u2212 1\\) hran.</li> <li>Proto\u017ee po hran\u00e1ch do p\u0159edch\u016fdc\u016f je mo\u017en\u00e9 se z ka\u017ed\u00e9ho vrcholu dostat do \\(s\\) (tedy pro ka\u017ed\u00fd vrchol v existuje v \\(H\\) sled z \\(v\\) do \\(s\\)) a proto\u017ee slo\u017een\u00edm sled\u016f vznikne sled, je graf \\(H\\) souvisl\u00fd.</li> </ol>"},{"location":"03_Stromy/3.3_Kostra_grafu/#theorem-3.4","title":"V\u011bta o spr\u00e1vnosti algoritmu BFS_kostra","text":"<p>Nech\u0165 \\(G = (V, E)\\) je souvisl\u00fd graf.  Potom hrany do p\u0159edch\u016fdc\u016f v BFS tvo\u0159\u00ed n\u011bjakou kostru grafu \\(G\\)</p>"},{"location":"03_Stromy/3.4_Topsort/","title":"3.4 Topsort","text":"<p>Definice 3.5 (Topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed)</p> <ul> <li>Jin\u00fdmi slovy, pokud vrcholy zakresl\u00edme horizont\u00e1ln\u011b v po\u0159ad\u00ed topologick\u00e9ho uspo\u0159\u00e1d\u00e1n\u00ed, budou v\u0161echny orientovan\u00e9 hrany   sm\u011b\u0159ovat zleva doprava.</li> <li>Topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed se pou\u017e\u00edv\u00e1 p\u0159edev\u0161\u00edm pro pl\u00e1nov\u00e1n\u00ed po\u0159ad\u00ed proveden\u00ed navz\u00e1jem z\u00e1visl\u00fdch \u00faloh/v\u00fdpo\u010dt\u016f.</li> </ul>"},{"location":"03_Stromy/3.4_Topsort/#def-3.5","title":"Topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed","text":"<p>Topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed (TU) orientovan\u00e9ho grafu \\(G = (V, E)\\)  je takov\u00e9 se\u0159azen\u00ed vrchol\u016f \\(V = \\{v_{1}, ... , v_{n}\\}\\), \u017ee pro ka\u017edou orientovanou hranu \\((v_{i}, v_{j} ) \\in E\\) plat\u00ed \\(i \\lt j\\).</p>"},{"location":"03_Stromy/3.4_Topsort/#cyklicke-zavislosti","title":"Cyklick\u00e9 z\u00e1vislosti","text":"<p>Z\u00edskan\u00fd orientovan\u00fd graf v\u0161ak m\u016f\u017ee obsahovat cyklus (orientovanou kru\u017enici)</p> <p>Pozorov\u00e1n\u00ed</p> <ul> <li>Pokud graf obsahuje cyklus, nelze tuto \u00falohu zjevn\u011b vy\u0159e\u0161it.</li> <li>Graf \\(G\\) m\u016f\u017ee m\u00edt v\u00edce topologick\u00fdch uspo\u0159\u00e1d\u00e1n\u00ed</li> </ul> <p></p> <p>Definice 3.6 (Orientovan\u00e1 kru\u017enice)</p> <p></p> <p>Definice 3.7 (Acyklick\u00fd graf)</p> <p></p> <p>Definice 3.8 (Zdroj a stok)</p> <p></p> <p>V\u011bta 3.5 (o existenci zdroje a stoku)</p> D\u016fkaz V\u011bty 3.5 <ol> <li>Sporem pro existenci zdroje (pro stok analogick\u00e9).</li> <li>P\u0159edpokl\u00e1dejme, \u017ee v \\(G\\) neexistuje zdroj.</li> <li>Zvolme libovoln\u00fd vrchol \\(v_{1} \\in V\\) . Do n\u011bj, dle p\u0159edchoz\u00edho p\u0159edpokladu, vede alespo\u0148 jedna orientovan\u00e1 hrana z n\u011bjak\u00e9ho vrcholu \\(v_{2}\\).</li> <li>Do \\(v_{2}\\) tak\u00e9 mus\u00ed v\u00e9st orientovan\u00e1 hrana z n\u011bjak\u00e9ho vrcholu \\(v_{3}\\), a tak d\u00e1le.</li> <li>Nejpozd\u011bji po \\(n\\) kroc\u00edch se v\u0161ak mus\u00ed n\u011bjak\u00fd vrchol zopakovat.</li> <li>To ale znamen\u00e1 existenci cyklu v \\(G\\), \u010d\u00edm\u017e dost\u00e1v\u00e1me SPOR.</li> </ol> <p></p> <p>Algoritmus 3.1 (Topsort)</p> <p></p> <p>V\u011bta 3.6 (o spr\u00e1vnosti algoritmu TopSort)</p> D\u016fkaz V\u011bty 3.6 <ol> <li>P\u0159edpokl\u00e1dejme, \u017ee \\(G\\) je orientovan\u00fd graf a p\u0159edpokl\u00e1dejme, \u017ee na po\u010d\u00e1tku v kroku \\((5)\\) existuje aspo\u0148 jeden zdroj \\(z\\) a \u017ee v\u0161echny zdroje za\u0159ad\u00edme do fronty \\(Q\\).</li> <li>Vnit\u0159ek cyklu \\((7)-(11)\\) realizuje odebr\u00e1n\u00ed \\(1\\) zdroje z fronty \\(Q\\), jeho vyjmut\u00ed z grafu \\(G\\),  jeho vlo\u017een\u00ed do v\u00fdsledn\u00e9ho uspo\u0159\u00e1d\u00e1n\u00ed a identifikaci p\u0159\u00edpadn\u00fdch nov\u00fdch zdroj\u016f a jejich za\u0159azen\u00ed do \\(Q\\).</li> <li>Existence hrany \\((v_{i}, v_{j})\\) znemo\u017e\u0148uje vlo\u017eit vrchol \\(v_{j}\\) do fronty \\(Q\\)  p\u0159ed vrcholem \\(v_{i}\\), proto\u017ee \\(v_{j}\\) by v takov\u00e9m okam\u017eiku m\u011blo  \\(\\delta [v_{j}] \\geq 1\\) a podm\u00ednkou vlo\u017een\u00ed do \\(Q\\) je \\(\\delta [v_{j}] = 0\\)</li> <li>Pokud v okam\u017eiku vypr\u00e1zdn\u011bn\u00ed fronty jsou zpracov\u00e1ny v\u0161echny vrcholy grafu \\(G\\), na\u0161li jsme TU orientovan\u00e9ho acyklick\u00e9ho grafu (RETURN).</li> <li>Pokud je fronta pr\u00e1zdn\u00e1 a p\u0159esto zb\u00fdvaj\u00ed n\u011bjak\u00e9 nezpracovan\u00e9 vrcholy ve zbytku \\(G\\), pak ve zbytku \\(G\\) nejsou \u017e\u00e1dn\u00e9 zdroje,  \u010dili ka\u017ed\u00fd vrchol m\u00e1 vstupn\u00ed hranu/-y a mus\u00ed existovat orientovan\u00fd cyklus, plus p\u0159\u00edpadn\u011b z n\u011bj dostupn\u00e9 podgrafy.  Vrcholy tohoto zbytkov\u00e9ho grafu nelze topologicky uspo\u0159\u00e1dat.</li> <li>Algoritmus tedy spr\u00e1vn\u011b detekuje existenci cyklu a skon\u010d\u00ed v kone\u010dn\u00e9m \u010dase.</li> <li>V obou p\u0159\u00edpadech algoritmus pracuje korektn\u011b a zastav\u00ed se.</li> </ol> <p></p> <p>V\u011bta 3.7 (o slo\u017eitosti algoritmu TopSort)</p> D\u016fkaz V\u011bty 3.7 <ol> <li>V\u00fdpo\u010det pole vstupn\u00edch stup\u0148\u016f na \u0159\u00e1dc\u00edch \\((3),(4)\\) trv\u00e1 \\(\\Theta (|E|)\\).</li> <li>Po\u010d\u00e1te\u010dn\u00ed vlo\u017een\u00ed zdroj\u016f do \\(Q\\) na \u0159\u00e1dku \\((5)\\) trv\u00e1 \\(O(|V|)\\).</li> <li>Ka\u017ed\u00fd vrchol je vlo\u017een do \\(Q\\) nejv\u00fd\u0161e 1x, proto vyb\u00edr\u00e1n\u00ed z \\(Q\\) a v\u00fdpis na v\u00fdstup na \u0159\u00e1dc\u00edch \\((6)\\)\u2013\\((8)\\) trv\u00e1 \\(O(|V|)\\).</li> <li>Ka\u017ed\u00e1 hrana m\u016f\u017ee b\u00fdt odebr\u00e1na z grafu nejv\u00fd\u0161e 1x, proto operace na \u0159\u00e1dc\u00edch \\((9)\\)\u2013\\((11)\\) trvaj\u00ed \\(O(|E|)\\).</li> <li>Celkov\u00e1 \u010dasov\u00e1 slo\u017eitost je tedy \\(O(|V|+|E|)\\).</li> <li>Graf \\(G\\), pole \\(\\delta\\)[], fronta \\(Q\\), to v\u0161e zabere \\(O(|V| + |E|)\\) pam\u011bti.</li> </ol> <p>K zamy\u0161len\u00ed</p> <ul> <li>Jak vypadaj\u00ed orientovan\u00e9 grafy s pr\u00e1v\u011b dv\u011bma topologick\u00fdmi uspo\u0159\u00e1d\u00e1n\u00edmi?</li> <li>Jak vypadaj\u00ed orientovan\u00e9 grafy s pr\u00e1v\u011b t\u0159emi topologick\u00fdmi uspo\u0159\u00e1d\u00e1n\u00edmi?</li> <li>Fungoval by algoritmus TopSort i s jinou strukturou ne\u017e frontou? Co t\u0159eba se z\u00e1sobn\u00edkem?</li> <li>Navrhn\u011bte, jak modifikovat algoritmus DFS pro orientovan\u00e9 grafy, aby vytvo\u0159il TU grafu.<ul> <li>N\u00e1pov\u011bda 1: Vezmu-li orientovan\u00fd acyklick\u00fd graf a n\u011bjak\u00e9 jeho TU, jakou vlastnost mus\u00ed m\u00edt posledn\u00ed vrchol v TU?</li> <li>N\u00e1pov\u011bda 2: P\u0159ipus\u0165me, \u017ee TU lze konstruovat odzadu.</li> </ul> </li> </ul>"},{"location":"03_Stromy/3.4_Topsort/#def-3.6","title":"Orientovan\u00e1 kru\u017enice","text":"<p>Nech\u0165 \\(n \\geq 1\\). Orientovan\u00e1 kru\u017enice d\u00e9lky \\(n\\) (s \\(n\\) vrcholy) je orient. graf \\((\\{1, ... , n\\}\\), \\(\\{(i, i + 1) | i \\in \\{1, ... , n \u2212 1\\}\\} \\cup \\{(n, 1)\\})\\).</p>"},{"location":"03_Stromy/3.4_Topsort/#def-3.7","title":"Acyklick\u00fd graf","text":"<p>Orientovan\u00fd graf \\(G\\) nazveme acyklick\u00fd, pokud neobsahuje jako podgraf orientovanou kru\u017enici.  angl. Directed Acyclic Graph (DAG)</p>"},{"location":"03_Stromy/3.4_Topsort/#def-3.8","title":"Zdroj a stok","text":"<ul> <li>Zdroj je takov\u00fd vrchol orientovan\u00e9ho grafu, do kter\u00e9ho nevede \u017e\u00e1dn\u00e1 hrana.</li> <li>Stok je takov\u00fd vrchol orientovan\u00e9ho grafu, ze kter\u00e9ho nevede \u017e\u00e1dn\u00e1 hrana</li> </ul>"},{"location":"03_Stromy/3.4_Topsort/#theorem-3.5","title":"V\u011bta o existenci zdroje a stoku","text":"<ul> <li>Nech\u0165 \\(G = (V, E)\\) je orientovan\u00fd acyklick\u00fd graf. Potom \\(G\\) obsahuje aspo\u0148 jeden zdroj a aspo\u0148 jeden stok.</li> </ul>"},{"location":"03_Stromy/3.4_Topsort/#algo-3.1","title":"Algoritmus Topsort","text":"<p>Existence zdroje v orientovan\u00e9m acyklick\u00e9m grafu vede p\u0159\u00edmo\u010da\u0159e na algoritmus konstrukce topologick\u00e9ho uspo\u0159\u00e1d\u00e1n\u00ed takov\u00e9ho grafu.</p> <p>Vstup</p> <p>Orientovan\u00fd graf \\(G\\).</p> <p>V\u00fdstup</p> <p>N\u011bjak\u00e9 topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed \\(G\\), pokud byl acyklick\u00fd  Detekce cykli\u010dnosti v opa\u010dn\u00e9m p\u0159\u00edpad\u011b.</p> <p>Idea</p> <ul> <li>po\u010d\u00edtej vstupn\u00ed stupn\u011b vrchol\u016f (tj. po\u010det hran, ve kter\u00fdch je vrchol n\u00e1sledn\u00edkem),</li> <li>zdroje za\u0159azuj do fronty,</li> <li>odeb\u00edrej vrcholy z fronty, za\u0159azuj je do v\u00fdstupn\u00edho po\u0159ad\u00ed a odeb\u00edrej je z grafu a to znamen\u00e1, \u017ee jejich n\u00e1sledn\u00edk\u016fm sni\u017euj vstupn\u00ed stupn\u011b.</li> <li>Pokud po vypr\u00e1zdn\u011bn\u00ed fronty zbyly v grafu n\u011bjak\u00e9 vrcholy, byl v n\u011bm orientovan\u00fd cyklus.</li> </ul> <p>Algoritmus</p> Algoritmus TopSort(orientovan\u00fd G):<pre><code>Q je pr\u00e1zdn\u00e1 fronta\n\u03b4[] = pole vstupn\u00edch stup\u0148\u016f vrchol\u016f G, na po\u010d\u00e1tku vynulovan\u00e9\nPro ka\u017edou hranu (u, v) \u2208 E(G):\n    \u03b4[v]++\nVlo\u017e do Q v\u0161echny vrcholy z s \u03b4[z] = 0\nDokud fronta Q nen\u00ed pr\u00e1zdn\u00e1:\n    Odeber prvek z ze za\u010d\u00e1tku fronty Q\n    Vypi\u0161 z\n    Pro ka\u017edou hranu (z, w) vedouc\u00ed ze z:\n        \u03b4[w]\u2212\u2212\n        Pokud \u03b4[w] = 0: za\u0159a\u010f w do Q\nPokud nebyly zpracov\u00e1ny v\u0161echny vrcholy:\n    graf G obsahuje orientovan\u00fd cyklus\n</code></pre>"},{"location":"03_Stromy/3.4_Topsort/#theorem-3.6","title":"V\u011bta o spr\u00e1vnosti algoritmu TopSort","text":"<p>Algoritmus TopSort(\\(G\\)) spu\u0161t\u011bn\u00fd na orientovan\u00fd graf \\(G\\) dob\u011bhne v kone\u010dn\u00e9m \u010dase a bu\u010f vygeneruje korektn\u00ed topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed acyklick\u00e9ho grafu nebo detekuje existenci orientovan\u00e9ho cyklu.</p>"},{"location":"03_Stromy/3.4_Topsort/#theorem-3.7","title":"V\u011bta o slo\u017eitosti algoritmu TopSort","text":"<p>Algoritmus TopSort(\\(G\\)), kde \\(G = (V, E)\\) je orientovan\u00fd graf reprezentovan\u00fd pomoc\u00ed pole n\u00e1sledn\u00edk\u016f, m\u00e1 \u010dasovou i pam\u011b\u0165ovou slo\u017eitost \\(O(|V| + |E|)\\).</p>"},{"location":"03_Stromy/3.5_Jednoduch%C3%A9_%C5%99azen%C3%AD/","title":"3.5 Jednoduch\u00e9 \u0159azen\u00ed","text":"<p>Definice 3.9 (Probl\u00e9m \u0159azen\u00ed)</p> <ul> <li>P\u0159\u00edklad: \\(n = 6, A = 23, 7, 19, 21, 5, 12, A^{\u2032} = 5, 7, 12, 19, 21, 23\\).</li> <li>Obecn\u011b: ze vstupn\u00ed posloupnosti vytvo\u0159it posloupnost hodnot v p\u0159eddefinovan\u00e9m po\u0159ad\u00ed.</li> <li>Fundament\u00e1ln\u00ed probl\u00e9m v informatice.</li> <li>Existuje \u0159ada p\u0159\u00edstup\u016f a algoritm\u016f.</li> <li>Implicitn\u011b budeme uva\u017eovat algoritmy \u0159adic\u00ed vzestupn\u011b.</li> </ul>"},{"location":"03_Stromy/3.5_Jednoduch%C3%A9_%C5%99azen%C3%AD/#def-3.9","title":"Probl\u00e9m \u0159azen\u00ed","text":"<ul> <li>Vstup: \u010c\u00edslo \\(n\\) a posloupnost \u010d\u00edsel \\(A = a_{1}, a_{2}, . . . , a_{n}\\).</li> <li>V\u00fdstup: Takov\u00e1 permutace \\(A^{\u2032} = a_{1}^{\u2032}, a_{2}^{\u2032}, . . . , a_{n}^{\u2032}\\) vstupn\u00ed posloupnosti A,  \u017ee plat\u00ed \\(a_{1}^{\u2032} \\leq a_{2}^{\u2032} \\leq ... \\leq a_{n}^{\u2032}\\)</li> </ul>"},{"location":"03_Stromy/3.5_Jednoduch%C3%A9_%C5%99azen%C3%AD/#taxonomie-algoritmu-pro-razeni","title":"Taxonomie algoritm\u016f pro \u0159azen\u00ed","text":"<p>(A) Z\u00e1kladn\u00ed operace:</p> <ol> <li>\u0158azen\u00ed zalo\u017een\u00e9 na pouze bin\u00e1rn\u00ed operaci porovn\u00e1n\u00ed-a-prohozen\u00ed (Compare-And-Exchange).</li> <li>\u0158azen\u00ed zalo\u017een\u00e9 na jin\u00e9 operaci.</li> </ol> <p>(B) Pam\u011b\u0165ov\u00e1 n\u00e1ro\u010dnost:</p> <ol> <li>In-place algoritmy (pot\u0159ebuj\u00ed \\(n\\) + polylog(\\(n\\)) pam\u011bti).</li> <li>Out-of-place algoritmy.</li> </ol> <p>(C) Stabilita:</p> <ol> <li>Stabiln\u00ed algoritmy (stejn\u011b velk\u00e9 prvky se nikdy neprohod\u00ed).</li> <li>Nestabiln\u00ed algoritmy (stejn\u011b velk\u00e9 prvky se mohou prohodit).</li> </ol> <p>(D) Citlivost na hodnoty prvk\u016f vstupn\u00ed posloupnosti:</p> <ol> <li>Datov\u011b citliv\u00e9 algoritmy (\u010dasov\u00e1 slo\u017eitost z\u00e1vis\u00ed na hodnot\u00e1ch prvk\u016f).</li> <li>Datov\u011b necitliv\u00e9 algoritmy (\u010dasov\u00e1 slo\u017eitost nez\u00e1vis\u00ed na hodnot\u00e1ch prvk\u016f).</li> </ol>"},{"location":"03_Stromy/3.5_Jednoduch%C3%A9_%C5%99azen%C3%AD/#kvadraticke-algoritmy-razeni","title":"Kvadratick\u00e9 algoritmy \u0159azen\u00ed","text":"<ul> <li>Vstupn\u00ed posloupnost se rozd\u011bl\u00ed na levou se\u0159azenou a pravou nese\u0159azenou \u010d\u00e1st.</li> <li>Na po\u010d\u00e1tku je lev\u00e1 \u010d\u00e1st pr\u00e1zdn\u00e1 a prav\u00e1 \u010d\u00e1st je cel\u00e1 vstupn\u00ed posloupnost.</li> <li>Po vlo\u017een\u00ed prvku se hranice mezi se\u0159azenou a nese\u0159azenou \u010d\u00e1st\u00ed posune o jednu pozici doprava.</li> </ul> <p>Algoritmus 3.2 (SelectSort)</p> <p></p> <p>Algoritmus 3.3 (InsertSort)</p> <p></p> <p>Algoritmus 3.4 (BubbleSort)</p> <p></p> <p>V\u011bta 3.8 (o korektnosti algoritmu BubbleSort)</p> D\u016fkaz V\u011bty 3.8 <ol> <li>Korektnost dok\u00e1\u017eeme induk\u010dn\u00edm d\u016fkazem n\u00e1sleduj\u00edc\u00edho invariantu.</li> <li>Invariant: nejpozd\u011bji po \\(i\\)-t\u00e9 iteraci cyklu na \u0159\u00e1dc\u00edch \\((3)\\)\u2013\\((9)\\) se \\(i\\) nejv\u011bt\u0161\u00edch prvk\u016f pole nach\u00e1z\u00ed se\u0159azeno na \\(i\\) posledn\u00edch pozic\u00edch zprava.</li> <li>IZ: Invariant plat\u00ed pro \\(i = 1\\). Po 1. iteraci je nejv\u011bt\u0161\u00ed prvek cel\u00e9 posloupnosti zaru\u010den\u011b na posledn\u00ed pozici.</li> <li>IK: P\u0159edpokl\u00e1dejme, \u017ee Invariant plat\u00ed pro v\u0161echna \\(j \\lt i\\) a tedy \\(i \u2212 1\\) nejv\u011bt\u0161\u00edch prvk\u016f se nach\u00e1z\u00ed se\u0159azeno na posledn\u00edch \\(i \u2212 1\\) pozic\u00edch vpravo. Prove\u010fme \\(i\\)-tou iteraci.</li> <li>T\u00edm probubl\u00e1 nejv\u011bt\u0161\u00ed hodnota lev\u00e9ho zbytku doprava, lev\u00e1 \u010d\u00e1st se zkr\u00e1t\u00ed o jedna a prav\u00e1 se\u0159azen\u00e1 \u010d\u00e1st se zv\u011bt\u0161\u00ed o jeden prvek, a invariant plat\u00ed.</li> </ol> <p></p> <p>V\u011bta 3.9 (o slo\u017eitosti algoritmu BubbleSort)</p> D\u016fkaz V\u011bty 3.9 <ol> <li>Iterac\u00ed je nejv\u00fd\u0161e \\(n \u2212 1\\), \\(i\\)-t\u00e1 iterace trv\u00e1 \\(\\Theta (n \u2212 i)\\) krok\u016f, co\u017e d\u00e1v\u00e1 \u010dasovou slo\u017eitost \\(O(n^{2})\\).</li> <li>Krom\u011b vstupn\u00edho pole pot\u0159ebuje pouze \\(O(1)\\) pam\u011bti.</li> <li>Je stabiln\u00ed, nebo\u0165 podm\u00ednka na \u0159\u00e1dku \\((6)\\) zabr\u00e1n\u00ed prohozen\u00ed stejn\u00fdch prvk\u016f.</li> <li>Je datov\u011b citliv\u00fd, nebo\u0165 kon\u010d\u00ed, jakmile nedo\u0161lo b\u011bhem n\u011bkter\u00e9 iterace ke zm\u011bn\u011b. V nejlep\u0161\u00edm p\u0159\u00edpad\u011b ji\u017e se\u0159azen\u00e9ho pole m\u00e1 slo\u017eitost \\(\\Theta(n)\\).</li> </ol>"},{"location":"03_Stromy/3.5_Jednoduch%C3%A9_%C5%99azen%C3%AD/#algo-3.2","title":"Algoritmus SelectSort","text":"<p>Z nese\u0159azen\u00e9 prav\u00e9 \u010d\u00e1sti se vybere minimum a prohod\u00ed se s jej\u00edm prvn\u00edm prvkem, tj. p\u0159\u00edmo za se\u0159azenou \u010d\u00e1st. </p> <p>Vlastnosti</p> <ul> <li>Se\u0159ad\u00ed \\(n\\)-prvkov\u00e9 pole v \u010dase \\(\u0398(n^{2})\\)</li> <li>in-place, nestabiln\u00ed, datov\u011b necitliv\u00fd</li> </ul> <p>Invariant: Po \\(i\\)-t\u00e9 iteraci je vlevo se\u0159azen\u00e1 posloupnost d\u00e9lky \\(i\\) a vpravo zb\u00fdv\u00e1 \\(n \u2212 i\\) nese\u0159azen\u00fdch prvk\u016f, kter\u00e9 jsou \\(\\geq\\) ne\u017e \u010d\u00edsla v lev\u00e9 \u010d\u00e1sti.</p>"},{"location":"03_Stromy/3.5_Jednoduch%C3%A9_%C5%99azen%C3%AD/#algo-3.3","title":"Algoritmus InsertSort","text":"<p>Z nese\u0159azen\u00e9 prav\u00e9 \u010d\u00e1sti se vezme prvn\u00ed prvek a vlo\u017e\u00ed se zprava na spr\u00e1vnou pozici v lev\u00e9 se\u0159azen\u00e9 \u010d\u00e1sti.</p> <p>Vlastnosti</p> <ul> <li>Se\u0159ad\u00ed \\(n\\)-prvkov\u00e9 pole v \u010dase \\(O(n^{2})\\)</li> <li>in-place, stabiln\u00ed, datov\u011b citliv\u00fd.</li> </ul> <p>Invariant: Po \\(i\\)-t\u00e9 iteraci je vlevo se\u0159azen\u00e1 posloupnost d\u00e9lky \\(i + 1\\) a vpravo zb\u00fdv\u00e1 \\(n \u2212 1 \u2212 i\\) nese\u0159azen\u00fdch prvk\u016f.</p>"},{"location":"03_Stromy/3.5_Jednoduch%C3%A9_%C5%99azen%C3%AD/#algo-3.4","title":"Algoritmus BubbleSort","text":"<ul> <li>\u0158azen\u00ed probubl\u00e1v\u00e1n\u00edm v\u011bt\u0161\u00edch prvk\u016f doprava.</li> </ul> <p>Idea</p> <ul> <li>Postupn\u011b zleva doprava se porovn\u00e1vaj\u00ed dvojice sousedn\u00edch prvk\u016f a pokud jsou prvky dvojice v nespr\u00e1vn\u00e9m po\u0159ad\u00ed, prohod\u00ed se.</li> <li>Po prvn\u00edm pr\u016fchodu bubliny se nejv\u011bt\u0161\u00ed prvek dostane na posledn\u00ed m\u00edsto.</li> <li>Cel\u00fd postup se opakuje nejv\u00fd\u0161e \\((n \u2212 1)\\)-kr\u00e1t: poka\u017ed\u00e9 se se\u0159azen\u00e1 podposloupnost vpravo prodlou\u017e\u00ed o jednu pozici doleva.</li> <li>Pokud se b\u011bhem jednoho pr\u016fchodu neprohodila \u017e\u00e1dn\u00e1 dvojice soused\u016f, u\u017e se nikdy \u017e\u00e1dn\u00e1 neprohod\u00ed a \u0159azen\u00ed skon\u010dilo.</li> </ul> <ul> <li>Vhodn\u00fd algoritmus, pokud je nap\u0159. vstupn\u00ed posloupnost z velk\u00e9 \u010d\u00e1sti se\u0159azen\u00e1</li> </ul> <p>Algoritmus</p> BubbleSort<pre><code>end := n\nzmena := 1\nDokud zmena = 1:\n    zmena := 0\n    Pro j := 1 ... (end \u2212 1):\n        Pokud P [j] &gt; P [j + 1]:\n            proho\u010f P [j] a P [j + 1]\n            zmena := 1\n    end\u2212\u2212\n</code></pre>"},{"location":"03_Stromy/3.5_Jednoduch%C3%A9_%C5%99azen%C3%AD/#theorem-3.8","title":"V\u011bta o korektnosti algoritmu BubbleSort","text":"<p>Algoritmus BubbleSort korektn\u011b se\u0159ad\u00ed \\(n\\)-prvkov\u00e9 pole.</p>"},{"location":"03_Stromy/3.5_Jednoduch%C3%A9_%C5%99azen%C3%AD/#theorem-3.9","title":"V\u011bta o slo\u017eitosti algoritmu BubbleSort","text":"<p>BubbleSort se\u0159ad\u00ed \\(n\\)-prvkov\u00e9 pole v \u010dase \\(O(n^{2})\\) a je in-place, stabiln\u00ed, datov\u011b citliv\u00fd.</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.1_Halda_jako_struktura/","title":"4.1 Halda jako struktura","text":""},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.1_Halda_jako_struktura/#zakoreneny-strom-binarni-strom-a-halda","title":"Zako\u0159en\u011bn\u00fd strom, Bin\u00e1rn\u00ed strom a halda","text":"<p>Definice 4.1 (Zako\u0159en\u011bn\u00fd strom)</p> <p>Pozorov\u00e1n\u00ed</p> <p>V\u0161echny \\(v \\in V(T) \u2212 \\{r\\}\\) jsou potomci ko\u0159ene \\(r\\) a ko\u0159en \\(r\\) je p\u0159edkem v\u0161ech ostatn\u00edch vrchol\u016f.</p> <p></p> <p>Definice 4.2 (Bin\u00e1rn\u00ed strom)</p> <p></p> <p>Definice 4.3 (Bin\u00e1rn\u00ed minimov\u00e1 halda)</p> <pre><code>graph TD\n    A([\"3\"]):::level0\n    A --&gt; B([\"5\"]):::level1\n    A --&gt; C([\"7\"]):::level1\n    B --&gt; D([\"11\"]):::level2\n    B --&gt; E([\"6\"]):::level2\n    C --&gt; F([\"9\"]):::level2\n\n    classDef level0 fill:#00af00,stroke:#000,stroke-width:2px,color:#fff,shape:circle,align:center;\n    classDef level1 fill:#0000af,stroke:#000,stroke-width:2px,color:#fff,shape:circle,align:center;\n    classDef level2 fill:#afaf00,stroke:#000,stroke-width:2px,color:#fff,shape:circle,align:center;</code></pre> <p>Pozorov\u00e1n\u00ed</p> <p>Na cest\u011b vedouc\u00ed z libovoln\u00e9ho vrcholu do ko\u0159ene tvo\u0159\u00ed kl\u00ed\u010de nerostouc\u00ed posloupnost. V ko\u0159eni je tedy glob\u00e1ln\u00ed minimum ze v\u0161ech kl\u00ed\u010d\u016f.</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.1_Halda_jako_struktura/#def-4.1","title":"Zako\u0159en\u011bn\u00fd strom","text":"<ul> <li>Zako\u0159en\u011bn\u011bn\u00fd strom je strom \\(T\\), ve kter\u00e9m je jeden vrchol \\(r \\in V(T)\\) ozna\u010den jako ko\u0159en</li> <li>Le\u017e\u00ed-li \\(u\\) na (jedin\u00e9) cest\u011b z \\(v\\) do ko\u0159ene, pak \\(u\\) je p\u0159edek \\(v\\) a \\(v\\) je potomek \\(u\\). Pokud je nav\u00edc \\(\\{u,v\\} \\in E(T)\\) hrana, \u0159\u00edk\u00e1me, \u017ee \\(u\\) je otec \\(v\\) a \\(v\\) je syn \\(u\\).</li> <li>Vrcholy rozd\u011bl\u00edme podle vzd\u00e1lenosti od ko\u0159ene do hladin: v nult\u00e9 le\u017e\u00ed ko\u0159en, v prvn\u00ed jeho synov\u00e9, atd.</li> <li>Hloubka zako\u0159en\u011bn\u00e9ho stromu \\(T\\) je po\u010det jeho hladin.</li> </ul>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.1_Halda_jako_struktura/#def-4.2","title":"Bin\u00e1rn\u00ed strom","text":"<p>Strom nazveme bin\u00e1rn\u00ed, pokud</p> <ul> <li>je zako\u0159en\u011bn\u00fd</li> <li>ka\u017ed\u00fd vrchol m\u00e1 nejv\u00fd\u0161e dva syny</li> <li>u syn\u016f rozli\u0161ujeme, kter\u00fd je lev\u00fd a kter\u00fd prav\u00fd.</li> </ul>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.1_Halda_jako_struktura/#def-4.3","title":"Bin\u00e1rn\u00ed minimov\u00e1 halda","text":"<p>Bin\u00e1rn\u00ed minimov\u00e1 halda je datov\u00e1 struktura tvaru bin\u00e1rn\u00edho stromu, v jeho\u017e ka\u017ed\u00e9m vrcholu \\(x\\) je ulo\u017een jeden kl\u00ed\u010d \\(k(x)\\) a kter\u00e1 spl\u0148uje tyto dv\u011b vlastnosti:</p> <ol> <li>Tvar Haldy: Strom m\u00e1 v\u0161echny hladiny krom\u011b posledn\u00ed pln\u011b obsazen\u00e9. Posledn\u00ed hladina je zapln\u011bna od lev\u00e9ho okraje sm\u011brem k prav\u00e9mu.</li> <li>Haldov\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed: Je-li \\(v\\) vrchol a \\(s\\) jeho syn, plat\u00ed</li> </ol> <p>\\(k(v) \\le k(s)\\)</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.2_Vlastnosti_haldy/","title":"4.2 Vlastnosti haldy","text":""},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.2_Vlastnosti_haldy/#pocet-hladin-haldy","title":"Po\u010det hladin haldy","text":"<p>V\u011bta 4.1 (O po\u010dtu hladin haldy)</p> D\u016fkaz V\u011bty 4.1 <ul> <li>Bin\u00e1rn\u00ed strom s \\(h \\ge 1\\) \u00fapln\u00fdmi hladinami m\u00e1 \\(n = 2^0 + 2^1 + 2^2 ... + 2^{h-1} = 2^h - 1\\) vrchol\u016f</li> <li>Vzhledem ke Tvaru haldy p\u0159ibude nov\u00e1 hladina jen tehdy, kdy\u017e po\u010det prvk\u016f \\(n\\) vzroste z \\(2^h - 1\\) na \\(2^h\\)</li> <li>Z toho plyne vzorec, nebo\u0165 pr\u00e1v\u011b funkce \\(\\lfloor log(n) \\rfloor\\) se pr\u00e1v\u011b p\u0159i t\u00e9to zm\u011bn\u011b \\(n\\) zv\u011bt\u0161\u00ed o jedna a pro \\(n=2^h - 1\\) je po\u010det hladin \\(h = (h - 1) + 1 = \\lfloor log(2^h - 1) \\rfloor + 1\\).</li> </ul>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.2_Vlastnosti_haldy/#def-4.1","title":"O po\u010dtu hladin haldy","text":"<p>Bin\u00e1rn\u00ed halda s \\(n\\) prvky m\u00e1 \\(\\lfloor log(n) \\rfloor + 1\\) hladin.</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.2_Vlastnosti_haldy/#pocet-listu-haldy","title":"Po\u010det list\u016f haldy","text":"<p>V\u011bta 4.2 (O po\u010dtu list\u016f haldy)</p> D\u016fkaz V\u011bty 4.2 <ul> <li>Indukc\u00ed podle po\u010dtu vrchol\u016f bin\u00e1rn\u00edho stromu.</li> <li>Lemma plat\u00ed trivi\u00e1ln\u011b pro \\(n = 3\\) (2 listy a ko\u0159en \u2013 jedin\u00fd vnit\u0159n\u00ed vrchol).</li> <li>Nech\u0165 \\(n \\gt 3\\) je lich\u00e9. Odebr\u00e1n\u00edm posledn\u00edho listu, kter\u00fd je druh\u00fdm (tj. prav\u00fdm) synem posledn\u00edho vnit\u0159n\u00edho vrcholu, vznikne halda o sud\u00e9 velikosti \\(n\u22121\\), pro kterou z ind. p\u0159edp. lemma plat\u00ed.</li> <li>Vr\u00e1cen\u00edm posledn\u00edho listu se po\u010det vnit\u0159n\u00edch vrchol\u016f nezm\u011bn\u00ed a p\u016fvodn\u00ed strom jich tedy m\u00e1 \\(\\lfloor (n-1)/2 \\rfloor = \\lfloor n/2 \\rfloor\\)</li> <li>A po\u010det list\u016f se zv\u011bt\u0161\u00ed o jedna a p\u016fvodn\u00ed strom jich tedy m\u00e1 \\(\\lceil (n-1)/2 \\rceil + 1 = \\lceil n/2 \\rceil\\)</li> <li>Nech\u0165 \\(n \\ge 4\\) je sud\u00e9. Pak posledn\u00ed list je jedin\u00fd lev\u00fd syn sv\u00e9ho otce.</li> <li>Jeho odebr\u00e1n\u00edm vznikne halda lich\u00e9 velikosti \\(n \u2212 1\\), kter\u00e1 m\u00e1 podle ind. p\u0159edpokladu \\(\\lceil (n \u2212 1)/2 \\rceil\\) list\u016f a \\(\\lfloor (n \u2212 1)/2 \\rfloor\\) vnit\u0159n\u00edch vrchol\u016f.</li> <li>Vr\u00e1cen\u00edm posledn\u00edho listu jeden vnit\u0159n\u00ed vrchol p\u0159ibude a p\u016fvodn\u00ed strom jich tedy m\u00e1 \\(\\lfloor (n \u2212 1)/2 \\rfloor + 1 = \\lfloor n/2 \\rfloor\\).</li> <li>A po\u010det list\u016f se nezm\u011bn\u00ed a p\u016fvodn\u00ed strom jich tedy m\u00e1 \\(\\lceil (n \u2212 1)/2 \\rceil = \\lceil n/2 \\rceil\\).</li> </ul>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.2_Vlastnosti_haldy/#def-4.2","title":"O po\u010dtu list\u016f haldy","text":"<p>Bin\u00e1rn\u00ed halda s \\(n \\ge 3\\) prvky m\u00e1 \\(\\lfloor n/2 \\rfloor\\) vnit\u0159n\u00edch vrchol\u016f a \\(\\lceil n/2 \\rceil\\) list\u016f.</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.3_Operace_na_Hald%C4%9B/","title":"4.3 Operace na Hald\u011b","text":""},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.3_Operace_na_Hald%C4%9B/#binarni-minimova-halda-formalizace","title":"Bin\u00e1rn\u00ed minimov\u00e1 halda \u2013 Formalizace","text":""},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.3_Operace_na_Hald%C4%9B/#atributy-haldy-h","title":"Atributy haldy H","text":"<ul> <li>H.root, kter\u00fd je aktu\u00e1ln\u00ed ko\u0159en</li> <li>H.n, kter\u00fd udr\u017euje aktu\u00e1ln\u00ed po\u010det prvk\u016f</li> <li>H.last, kter\u00fd udr\u017euje ukazatel na aktu\u00e1ln\u00ed posledn\u00ed list (nejprav\u011bj\u0161\u00ed list v posledn\u00ed hladin\u011b), pokud existuje</li> </ul>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.3_Operace_na_Hald%C4%9B/#prvek-haldy-x","title":"Prvek haldy \\(x\\)","text":"<ul> <li>kl\u00ed\u010d \\(k(x)\\)</li> <li>ukazatel na otce</li> <li>ukazatele na sv\u00e9 syny (jsou-li v hald\u011b obsa\u017een\u00e9)</li> </ul> <p>V n\u00e1sleduj\u00edc\u00edm textu p\u0159edpokl\u00e1d\u00e1me, \u017ee v\u00fd\u0161e uveden\u00e9 prom\u011bnn\u00e9 m\u00e1me a um\u00edme je p\u0159epo\u010d\u00edtat v \u010dase \\(O(1)\\). Na z\u00e1v\u011br takovou implementaci p\u0159edvedeme.</p> <p></p> <p>Algoritmus 4.1 (HeapInsert)</p> <p></p> <p>V\u011bta 4.3 (O koreknosti HeapInsert)</p> D\u016fkaz V\u011bty 4.3 <ul> <li>Pokud H je pr\u00e1zdn\u00e1, pak je v\u00fdsledkem jednoprvkov\u00e1 halda \u2013 hotovo.</li> <li>Jinak ozna\u010dme \\(H'\\) v\u00fdsledek vol\u00e1n\u00ed HeapInsert(\\(H\\), \\(k\\)).</li> <li>\\(H'\\) m\u00e1 dle (3) tvar haldy.</li> <li>Zb\u00fdv\u00e1 ov\u011b\u0159it, \u017ee spl\u0148uje podm\u00ednku haldov\u00e9ho uspo\u0159\u00e1d\u00e1n\u00ed</li> <li>Po p\u0159id\u00e1n\u00ed hodnoty \\(k\\) do nov\u00e9ho listu \\(l\\) m\u016f\u017ee existovat jen jedna hrana \\(s\\) poru\u0161enou podm\u00ednkou. Tento probl\u00e9m pomoc\u00ed funkce BubbleUp posouv\u00e1me sm\u011brem ke ko\u0159eni.</li> <li>Je t\u0159eba ov\u011b\u0159it, \u017ee nem\u016f\u017eeme poru\u0161it podm\u00ednku haldov\u00e9ho uspo\u0159\u00e1d\u00e1n\u00ed mezi n\u011bjak\u00fdm otcem \\(o\\) a jeho (p\u0159\u00edpadn\u00fdm) druh\u00fdm synem na cest\u011b z \\(l\\) do ko\u0159ene.<ul> <li>Pozorujeme, \u017ee hodnota \\(k(o)\\) v \\(o\\) se aplikov\u00e1n\u00edm BubbleUp nemohla zv\u00fd\u0161it (m\u016f\u017ee klesnout, p\u0159\u00edpadn\u011b z\u016fstat stejn\u00e1, pokud otec vrcholu \\(o\\) m\u011bl stejnou hodnotu).</li> </ul> </li> </ul> <p></p> <p>Algoritmus 4.2 (HeapExtractMin)</p> <p></p> <p>V\u011bta 4.4 (O koreknosti HeapExtractMin)</p> D\u016fkaz V\u011bty 4.4 <ul> <li>Tvar haldy je op\u011bt zachov\u00e1n trivi\u00e1ln\u011b.</li> <li>Pokud je v\u00fdsledkem pr\u00e1zdn\u00e1 \u010di jednoprvkov\u00e1 halda, m\u00e1me hotovo</li> <li>Prohozen\u00ed z \u0159\u00e1dku 3 mohlo poru\u0161it haldov\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed (mezi hladinami 0 a 1).</li> <li>Op\u011bt prohazujeme s men\u0161\u00edm ze syn\u016f, \u010d\u00edm\u017e posunujeme poru\u0161en\u00ed na dvojici n\u00e1sleduj\u00edc\u00edch hladin.</li> <li>Toto m\u016f\u017ee pokra\u010dovat jen do posledn\u00ed hladiny.</li> </ul> <p>K Zamy\u0161len\u00ed</p> <ul> <li>Co se zm\u011bn\u00ed, kdy\u017e m\u00edsto minimov\u00e9 haldy budeme pracovat s maximovou haldou a m\u00edsto operac\u00ed HeapExtractMin a HeapFindMin budeme tedy podporovat operace HeapExtractMax a HeapFindMax?</li> <li>Rozmyslete algoritmus operace HeapChangeKey, kter\u00e1 dostane ukazatel na prvek ulo\u017een\u00fd v hald\u011b, ve kter\u00e9m se m\u00e1 kl\u00ed\u010d zm\u011bnit na zadanou hodnotu tak, aby v\u00fdsledkem byla op\u011bt halda.</li> <li>Vyu\u017eit\u00edm operace HeapChangeKey lze definovat operaci, kter\u00e1 umo\u017e\u0148uje z haldy odstranit libovoln\u00fd prvek zadan\u00fd ukazatelem. Popi\u0161te jej\u00ed algoritmus.</li> </ul>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.3_Operace_na_Hald%C4%9B/#algo-4.1","title":"Algoritmus HeapInsert","text":"<p>Vlo\u017een\u00ed prvku do haldy HeapInsert(\\(H,k\\))</p> <p>Vstup</p> <ul> <li>Halda \\(H\\).</li> <li>kl\u00ed\u010d \\(k\\) p\u0159id\u00e1van\u00e9ho prvku</li> </ul> <p>V\u00fdstup</p> <ul> <li>Halda \\(H\\) s p\u0159idan\u00fdm prvkem \\(p\\) s kl\u00ed\u010dem \\(k\\)</li> </ul> <p>Idea</p> <ul> <li>Vlastnost Tvar haldy dovoluje p\u0159idat okam\u017eit\u011b nov\u00fd prvek na konec nejspodn\u011bj\u0161\u00ed hladiny</li> <li>Pokud by ji\u017e byla pln\u00e1, zalo\u017e\u00edme novou hladinu.</li> <li>Pokud je Haldov\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed mezi nov\u00fdm listem l a jeho otcem o v po\u0159\u00e1dku, m\u016f\u017eeme skon\u010dit.</li> <li>Pokud ne, prohod\u00edme \\(k(l)\\) a \\(k(o)\\).</li> <li>T\u00edm se ale m\u016f\u017ee poru\u0161it vlastnost Haldov\u00e9ho uspo\u0159\u00e1d\u00e1n\u00ed mezi vrcholem \\(o\\) a otcem vrcholu \\(o\\).</li> <li>Pokud pro n\u011b Haldov\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed neplat\u00ed, op\u011bt jejich kl\u00ed\u010de prohod\u00edme, jinak kon\u010d\u00edme.</li> <li>Toto opakujeme, nejd\u00e1le v\u0161ak a\u017e do ko\u0159ene.</li> </ul> <p>Algoritmus</p> Algoritmus HeapInsert(H,k):<pre><code>HeapInsert(H, k)\n    H.n += 1\n    vlo\u017e na prvn\u00ed volnou pozici v posledn\u00ed hladin\u011b H\n        nov\u00fd vrchol p s kl\u00ed\u010dem k\n    BubbleUp(H,p)\n\nBubbleUp(H, p)\n    Dokud p \u0338= H.root:\n        o := otec(p)\n        Pokud k(o) \u2264 k(p):\n            return\n        proho\u010f k(o) a k(p)\n        p := o\n</code></pre> <p>\u010casov\u00e1 slo\u017eitost</p> <p>Na ka\u017ed\u00e9 hladin\u011b str\u00e1v\u00edme \\(O(1)\\) operac\u00ed a proch\u00e1zen\u00fdch hladin je nejv\u00fd\u0161e logaritmicky mnoho, celkem tedy \u010das \\(O(log(n))\\)</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.3_Operace_na_Hald%C4%9B/#def-4.3","title":"O koreknosti HeapInsert","text":"<p>Bu\u010f \\(H\\) minimov\u00e1 halda a \\(k\\) kl\u00ed\u010d. Potom struktura vznikl\u00e1 vol\u00e1n\u00edm HeapInsert(\\(H\\), \\(k\\)) je op\u011bt minimov\u00e1 halda.</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.3_Operace_na_Hald%C4%9B/#algo-4.2","title":"Algoritmus HeapExtractMin","text":"<ul> <li>Nalezen\u00ed minima HeapFindMin(\\(H\\)) je trivi\u00e1ln\u00ed -&gt; Vr\u00e1t\u00edme kl\u00ed\u010d ko\u0159ene haldu v \u010dase \\(O(1)\\)</li> <li>HeapExtractMin(H) je komplikovan\u011bj\u0161\u00ed: Odstran\u011bn\u00ed ko\u0159ene r = H.root stromu haldy by poru\u0161ilo vlastnost tvar haldy.</li> <li>Nicm\u00e9n\u011b je mo\u017en\u00e9 trivi\u00e1ln\u011b odstranit posledn\u00ed list \\(l\\), \u010dili list nejv\u00edc vpravo v posledn\u00ed hladin\u011b.</li> </ul> <p>Odstran\u011bn\u00ed minima z haldy HeapExtractMin(\\(H\\))</p> <p>Vstup</p> <ul> <li>Halda \\(H\\).</li> </ul> <p>V\u00fdstup</p> <ul> <li>Halda \\(H\\) s odebran\u00fdm prvkem \\(p\\) s nejmen\u0161\u00edm kl\u00ed\u010dem \\(k\\)</li> </ul> <p>Idea</p> <ul> <li>Proho\u010f \\(k(r)\\) a \\(k(l)\\)</li> <li>Odstra\u0148 vrchol \\(l\\) a zmen\u0161i haldu o 1 prvek.</li> <li>\"Probubl\u00e1vej dol\u016f\" z ko\u0159ene kl\u00ed\u010d \\(k(l)\\) na jeho spr\u00e1vn\u00e9 m\u00edsto, aby op\u011bt platilo haldov\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed.</li> </ul> <p>Algoritmus</p> Algoritmus HeapExtractMin(H):<pre><code>Algoritmus HeapExtractMin(H)\n    r = H.root, x = k(r), l = H.last\n    proho\u010f k(r) a k(l)\n    H.n := H.n \u2212 1\n    BubbleDown(r)\n    return x\n\n\nBubbleDown(v)\n    Dokud m\u00e1 v n\u011bjak\u00e9 syny:\n        s := takov\u00fd syn v, kter\u00fd m\u00e1 nejmen\u0161\u00ed kl\u00ed\u010d\n        Pokud k(v) \u2264 k(s):\n            return\n        proho\u010f k(v) a k(s)\n        v := s\n</code></pre> <p>\u010casov\u00e1 slo\u017eitost</p> <p>Na ka\u017ed\u00e9 hladin\u011b str\u00e1v\u00edme \\(O(1)\\) operac\u00ed a proch\u00e1zen\u00fdch hladin je nejv\u00fd\u0161e logaritmicky mnoho, celkem tedy \u010das \\(O(log(n))\\)</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.3_Operace_na_Hald%C4%9B/#def-4.4","title":"O koreknosti HeapExtractMin","text":"<p>Bu\u010f \\(H\\) minimov\u00e1 halda a \\(k\\) kl\u00ed\u010d. Potom struktura vznikl\u00e1 vol\u00e1n\u00edm HeapExtractMin(\\(H\\)) je op\u011bt minimov\u00e1 halda.</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.4_Reprezentace_haldy_v_pam%C4%9Bti/","title":"4.4 Reprezentace haldy v pam\u011bti","text":"<ul> <li> <p>Reprezentace pomoc\u00ed dynamicky alokovan\u00fdch spojov\u00fdch struktur je zbyte\u010dn\u011b komplikovan\u00e1.</p> </li> <li> <p>O\u010d\u00edslujme (oindexujeme) vrcholy po hladin\u00e1ch shora dol\u016f a na nich zleva doprava (\u010d\u00edslujeme od 1 do \\(n\\)):</p> </li> </ul> <p></p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.4_Reprezentace_haldy_v_pam%C4%9Bti/#vztahy-indexu-v-halde","title":"Vztahy index\u016f v hald\u011b","text":"<p>Pozorov\u00e1n\u00ed</p> <p>M\u00e1-li vrchol \\(v\\) index \\(i\\), pak</p> <ul> <li>jeho lev\u00fd syn m\u00e1 index \\(2i\\)</li> <li>jeho prav\u00fd syn index \\(2i + 1\\)</li> <li>jeho otec m\u00e1 index \\(\\lfloor i/2 \\rfloor\\)</li> <li>v\u00fdraz \\(i\\ mod\\ 2\\) ud\u00e1v\u00e1, zda je v p\u0159ipojen k otci levou \u010di pravou hranou, tj. zda je jeho lev\u00fd \u010di prav\u00fd syn.</li> </ul> <p>D\u016fsledek</p> <p>Haldu lze tedy jednodu\u0161e reprezentovat v poli a pohyb po stromu realizovat v\u00fd\u0161e popsan\u00fdmi operacemi s indexy.</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.5_Heap_Build_a_Sort/","title":"4.5 Heap Build a Sort","text":""},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.5_Heap_Build_a_Sort/#rychla-konstrukce-haldy-operace-heapbuild","title":"Rychl\u00e1 konstrukce haldy - operace HeapBuild","text":"<ul> <li>Haldu z n prvk\u016f lze vytvo\u0159it z pr\u00e1zdn\u00e9 haldy n vol\u00e1n\u00edmi operace HeapInsert, co\u017e d\u00e1v\u00e1 \u010das (pomoc\u00ed Stirlingova   vzorce)</li> </ul> \\[O(log(2)) +O(log(3)) + \u00b7\u00b7\u00b7 + O(log\\ n) = O(log(n!)) \\approx O(n\\ log\\ n)\\] <ul> <li>Jde to v\u0161ak rychleji.</li> </ul> <p>Algoritmus 4.3 (HeapBuild)</p> <p></p> <p>V\u011bta 4.5 (O \u010dasov\u00e9 slo\u017eitosti algoritmu HeapBuild)</p> D\u016fkaz V\u011bty 4.5 <ul> <li>Nech\u0165 strom haldy m\u00e1 \\(h\\) hladin (od 0 do h-1)</li> <li>Plat\u00ed tedy \\(2^{h-1} \\le n \\le 2^h - 1\\).</li> <li>Pro \u00fa\u010dely anal\u00fdzy si p\u0159edstav\u00edme, \u017ee i posledn\u00ed hladina je zcela pln\u00e1, nap\u0159\u00edklad n\u011bjak\u00fdmi \u201edummy\u201c prvky v\u011bt\u0161\u00edmi ne\u017e v\u0161e ostatn\u00ed, t\u00edm jist\u011b nesn\u00ed\u017e\u00edme pot\u0159ebn\u00fd po\u010det operac\u00ed.</li> <li>Procedura BubbleDown od \\(j\\)-t\u00e9 hladiny trv\u00e1 \u010das \\(O(h \u2212 1 \u2212 j)\\).</li> <li>Pokud to se\u010dteme p\u0159es v\u0161ech \\(2^j\\) vrchol\u016f hladiny \\(j\\) a pot\u00e9 p\u0159es v\u0161echny hladiny, dostaneme (a\u017e na konstantu)</li> </ul> \\[\\sum_{j=0}^{h-1}2^j(h - 1 - j) = \\sum_{q=0}^{h-1}2^{h-1-q}q = \\sum_{q=0}^{h-1} \\frac{2^{h-1}}{2^q}q \\le n\\sum_{q=0}^{h-1}\\frac{q}{2^q}\\] <p>V\u011bta (d\u2019Alembertovo krit\u00e9rium \u2013 BI-MA2)</p> <p>Nech\u0165 \\(a_k \\gt 0\\) pro ka\u017ed\u00e9 \\(k \\in \\mathbb{N}\\). Pokud \\(\\lim_{k\\to\\infty} \\frac{a_{k+1}}{a_k} \\lt 1\\), potom \u0159ada \\(\\sum_{k=0}^{\\infty}a_k\\) absolutn\u011b konverguje.</p> <ul> <li>\u010casovou slo\u017eitost lze shora odhadnout \\(O(n\\sum_{q=0}^{\\infty}\\frac{q}{2^q}) = O(n).\\)</li> <li>Pro \\(a_k = \\frac{k}{2^k}\\) m\u00e1me:</li> </ul> \\[\\lim_{k\\to\\infty}\\frac{k+1}{2^{k+1}}/\\frac{k}{2^k} = lim_{k\\to\\infty}\\frac{(k + 1) \\cdot 2^k}{k \\cdot 2^{k+1}} = lim_{k\\to\\infty}\\frac{k+1}{k\\cdot2} = \\frac{1}{2}\\] <ul> <li>Nav\u00edc \\(\\frac{k}{2^k} \\gt 0\\), tak\u017ee jsou spln\u011bny p\u0159edpoklady d\u2019Alemebrtova krit\u00e9ria a proto \u0159ada \\(\\sum a_k\\) konverguje k n\u011bjak\u00e9 kladn\u00e9 re\u00e1ln\u00e9 konstant\u011b \\(c\\) a tedy: \\(O(n \\sum q/{2^q}) = O(c \\cdot n) = O(n)\\).</li> </ul>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.5_Heap_Build_a_Sort/#algo-4.3","title":"Algoritmus HeapBuild","text":"<p>Konstrukce haldy HeapBuild</p> <p>Vstup</p> <ul> <li>prvky \\(x_1,...x_n\\)</li> </ul> <p>V\u00fdstup</p> <ul> <li>Halda \\(H[1...n]\\)</li> </ul> <p>Idea</p> <ol> <li>M\u00e1-li prvek \\(v\\) dva syny \\(l\\) a \\(r\\), kte\u0159\u00ed jsou ko\u0159eny podstrom\u016f tvo\u0159\u00edc\u00edch ji\u017e korektn\u00ed haldy, lze podstrom s ko\u0159enem ve \\(v\\) p\u0159ed\u011blat na haldu \u201ezabubl\u00e1n\u00edm\u201c kl\u00ed\u010de \\(k(v)\\) dol\u016f.</li> <li>V\u0161ech \u2308n/2\u2309 list\u016f jsou 1prvkov\u00e9 haldy.</li> </ol> <p>Algoritmus</p> Algoritmus HeapBuild:<pre><code>    vlo\u017e prvky do pole H tak, \u017ee H[i] := xi\n    Pro i := \u230an/2\u230b, . . . , 1:\n        BubbleDown(H[i])\n</code></pre>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.5_Heap_Build_a_Sort/#def-4.5","title":"O \u010dasov\u00e9 slo\u017eitosti HeapBuild","text":"<p>Operace HeapBuild m\u00e1 \u010dasovou slo\u017eitost \\(O(n)\\).</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.5_Heap_Build_a_Sort/#heapsort","title":"HeapSort","text":"<p>Algoritmus 4.4 (HeapSort)</p> <p>K Zamy\u0161len\u00ed</p> <ul> <li>P\u0159edchoz\u00ed popis algoritmu HeapSort p\u0159edpokl\u00e1dal, \u017ee se odeb\u00edran\u00e1 minima postupn\u011b zapisuj\u00ed do v\u00fdstupn\u00edho pole.</li> <li>Jedn\u00e1 se tedy o efektivn\u011bj\u0161\u00ed realizaci my\u0161lenky algoritmu SelectSort.</li> <li>Algoritmus HeapSort lze realizovat in-place, tedy bez pou\u017eit\u00ed extra pam\u011bti na ulo\u017een\u00ed zkonstruovan\u00e9 haldy.</li> <li>Navrhn\u011bte, jak to prov\u00e9st, kdy\u017e vstupn\u00ed posloupnost je ulo\u017eena v poli \\(P\\) a krom\u011b tohoto pole sm\u00edte pou\u017e\u00edt ji\u017e jen \\(O(1)\\) pomocn\u00fdch prom\u011bnn\u00fdch.</li> </ul>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.5_Heap_Build_a_Sort/#algo-4.4","title":"Algoritmus HeapSort","text":"<p>Halda umo\u017e\u0148uje zkonstruovat rychl\u00fd algoritmus pro \u0159azen\u00ed Heapsort</p> <p>Vstup</p> <ul> <li>pole \\(p = [x_1,...x_n]\\)</li> </ul> <p>V\u00fdstup</p> <ul> <li>se\u0159azen\u00e9 pole \\(p\\)</li> </ul> <p>Idea</p> <ol> <li>Prvky \\(x_1,...,x_n\\) vlo\u017e\u00edme do pole.</li> <li>Na toto pole zavol\u00e1me HeapBuild.</li> <li>Pot\u00e9 \\(n\\)-kr\u00e1t zavol\u00e1me HeapExtractMin a vracen\u00e9 hodnoty vyp\u00ed\u0161eme do v\u00fdstupn\u00edho pole. T\u00edm vygenerujeme vzestupn\u011b se\u0159azenou posloupnost.</li> </ol> <p>\u010casov\u00e1 slo\u017eitost</p> <p>Podle p\u0159edchoz\u00edch anal\u00fdz m\u00e1 HeapSort \u010dasovou slo\u017eitost \\(O(n) + O(n\\ log\\ n) = O(n\\ log\\ n)\\).</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.6_Amortizovan%C3%A1_%C4%8Dasov%C3%A1_slo%C5%BEitost/","title":"4.6 Amortizovan\u00e1 \u010dasov\u00e1 slo\u017eitost","text":""},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.6_Amortizovan%C3%A1_%C4%8Dasov%C3%A1_slo%C5%BEitost/#slozitost-operaci-nad-dynamickymi-mnozinami-dat","title":"Slo\u017eitost operac\u00ed nad dynamick\u00fdmi mno\u017einami dat","text":"<ul> <li> <p>Bin\u00e1rn\u00ed minimov\u00e1 halda je p\u0159\u00edklad dynamick\u00e9 mno\u017einy dat, jej\u00ed\u017e velikost i konkr\u00e9tn\u00ed slo\u017een\u00ed se v z\u00e1vislosti na   posloupnosti operac\u00ed HeapInsert a HeapExtractMin pr\u016fb\u011b\u017en\u011b m\u011bn\u00ed.</p> </li> <li> <p>Slo\u017eitost operace vlo\u017een\u00ed \u010di odebr\u00e1n\u00ed prvku takov\u00e9 struktury v nejhor\u0161\u00edm nebo v nejlep\u0161\u00edm p\u0159\u00edpad\u011b nevystihuje   v\u017edy nejl\u00e9pe skute\u010dn\u00e9 chov\u00e1n\u00ed algoritmu takov\u00e9 operace v r\u00e1mci \u017eivotn\u00edho cyklu takov\u00e9 datov\u00e9 struktury.</p> </li> <li> <p>Proto je u algoritm\u016f nebo operac\u00ed, kter\u00e9 se volaj\u00ed mnohokr\u00e1t nad dynamicky se m\u011bn\u00edc\u00ed datovou strukturou, u\u017eite\u010dn\u00e9   stanovit tzv. amortizovanou slo\u017eitost\\(^1\\).</p> </li> </ul> <p>\\(^1\\)Na\u0161e definice zde je jen pro \u201ezv\u011bt\u0161uj\u00edc\u00ed se\u201c datov\u00e9 struktury. Precizn\u011bj\u0161\u00ed definici zavedeme v BI-AG2.</p> <p></p> <p>Definice 4.4 (Amortizovan\u00e1 \u010dasov\u00e1 slo\u017eitost)</p> <ul> <li>Pro odhad \u010dasov\u00e9 slo\u017eitosti jednotliv\u00fdch proveden\u00ed takov\u00e9 operace se st\u00e1le bere nejhor\u0161\u00ed p\u0159\u00edpad.</li> <li>Amortizovanou slo\u017eitost je t\u0159eba stanovovat p\u0159es dostate\u010dn\u011b dlouh\u00e9 posloupnosti operac\u00ed. Typick\u00fd kontext   amortizovan\u00e9 anal\u00fdzy je sekvence v\u0161ech operac\u00ed od inicializace datov\u00e9 struktury do vybudov\u00e1n\u00ed struktury velikosti \\(n\\).</li> <li>Slo\u017eitost jednoho konkr\u00e9tn\u00edho vol\u00e1n\u00ed operace v nejhor\u0161\u00edm p\u0159\u00edpad\u011b m\u016f\u017ee b\u00fdt \u0159\u00e1dov\u011b v\u011bt\u0161\u00ed.</li> </ul> <p>Probl\u00e9m nafukovac\u00edho pole</p> <p>Pop\u00ed\u0161eme si nyn\u00ed strategii vybudov\u00e1n\u00ed dynamick\u00e9ho 1D pole o velikosti \\(n\\) postupn\u00fdm p\u0159id\u00e1v\u00e1n\u00edm jednotliv\u00fdch nov\u00fdch prvk\u016f tak, \u017ee celkov\u00e1 \u010dasov\u00e1 slo\u017eitost bude pouze \\(O(n)\\) a tedy p\u0159id\u00e1n\u00ed jednoho prvku m\u00e1 amortizovanou slo\u017eitost \\(O^\u2217(1)\\).</p> <p>Vstup</p> <ul> <li>Na vstup p\u0159ich\u00e1zej\u00ed pr\u016fb\u011b\u017en\u011b datov\u00e9 prvky, kter\u00e9 je pot\u0159eba ukl\u00e1dat do pole \\(P[1,...]\\), \\(i\\)-t\u00fd prvek na index \\(i\\).</li> </ul> <p>Probl\u00e9m</p> <ul> <li>Navrhn\u011bte operaci NPInsert, kter\u00e1 vkl\u00e1d\u00e1 prvky do pole, kdy\u017e<ul> <li>jejich celkov\u00fd po\u010det \\(n\\) p\u0159edem nezn\u00e1me a ani ho nedok\u00e1\u017eeme rozumn\u011b odhadnout,</li> <li>a tud\u00ed\u017e nelze p\u0159edem alokovat dostate\u010dn\u011b velk\u00e9 pole,</li> <li>a na po\u010d\u00e1tku alokujeme pole minim\u00e1ln\u00ed velikosti \\(m_0 = 1\\).</li> </ul> </li> </ul> <p>Idea</p> <ol> <li>Po\u010d\u00e1te\u010dn\u00ed kapacitu pole \\(P\\) zvol\u00edme \\(m_0 = 1\\)</li> <li>Ozna\u010dme moment\u00e1ln\u00ed kapacitu pole \\(P\\) v prvc\u00edch jako \\(m\\)</li> <li>P\u0159edpokl\u00e1dejme, \u017ee po\u010det aktu\u00e1ln\u011b ulo\u017een\u00fdch prvk\u016f v \\(P\\) je \\(i \u2212 1\\) a \u017ee chceme vlo\u017eit \\(i\\)-t\u00fd prvek.</li> <li>Jestli\u017ee \\(i \\le m\\), pak prvek vlo\u017e\u00edme na volnou pozici \\(i\\).</li> <li>Jestli\u017ee \\(i \\gt m\\), pak je v \\(P\\) ulo\u017eeno \\(m\\) prvk\u016f (do\u0161la voln\u00e1 m\u00edsta) a tud\u00ed\u017e:<ul> <li>p\u0159ealokujeme \\(P\\) na velikost \\(2m\\) prvk\u016f</li> <li>do prvn\u00ed poloviny nakop\u00edrujeme star\u00e9 pole</li> <li>n\u00e1sledn\u011b star\u00e9 pole zru\u0161\u00edme,</li> <li>nov\u00fd prvek vlo\u017e\u00edme na index \\(m + 1\\).</li> </ul> </li> </ol> <p>Algoritmus</p> Algoritmus NPInsert(P, x):<pre><code>    Nech\u0165 i je po\u0159adov\u00e9 \u010d\u00edslo vkl\u00e1dan\u00e9ho prvku od za\u010d\u00e1tku vkl\u00e1d\u00e1n\u00ed.\n    Pokud i \u2264 m: P[i] := x; i := i + 1; return\n    Pokud i &gt; m\n        Alokuj pole P\u2032 o velikosti 2m\n        P\u0159ekop\u00edruj P do prvn\u00ed poloviny pole P\u2032\n        Dealokuj P; P := P\u2032\n        P[i] := x; i := i + 1\n</code></pre> <p>\u010casov\u00e1 slo\u017eitost</p> <p>\u010casov\u00e1 slo\u017eitost vol\u00e1n\u00ed NPInsert na pole s \\(i\\) prvky je v nejhor\u0161\u00edm p\u0159\u00edpad\u011b \\(\\Theta(i)\\).</p> <p></p> <p>V\u011bta 4.6 (O amortizovan\u00e9 anal\u00fdze nafukovac\u00edho pole)</p> D\u016fkaz V\u011bty 4.6 <ul> <li>Pr\u00e1ce sest\u00e1v\u00e1 z vkl\u00e1d\u00e1n\u00ed jednotliv\u00fdch prvk\u016f (ka\u017ed\u00fd v \\(O(1)\\) \u010dase) prolo\u017een\u00fdch zv\u011bt\u0161ov\u00e1n\u00edm pole.</li> <li>Celkov\u00fd \u010das samotn\u00e9ho vkl\u00e1d\u00e1n\u00ed je tedy \\(\\Theta(n)\\).</li> <li>P\u0159\u00edpadn\u00e9 zv\u011bt\u0161ov\u00e1n\u00ed p\u0159i vlo\u017een\u00ed \\(i\\)-t\u00e9ho prvku trv\u00e1 \u010das \\(\\Theta(i)\\)</li> <li>Ke zv\u011bt\u0161ov\u00e1n\u00ed doch\u00e1z\u00ed pr\u00e1v\u011b tehdy, kdy\u017e \\(i\\) je mocnina dvou.</li> <li>V\u0161echna zv\u011bt\u0161en\u00ed tedy dohromady stoj\u00ed \\(\\Theta(2^{0} + 2^{1} + \u00b7\u00b7\u00b7 + 2^{k}),\\) kde \\(2^{k}\\) je nejvy\u0161\u0161\u00ed mocnina dvojky men\u0161\u00ed ne\u017e \\(n\\).</li> <li>V z\u00e1vorce je geometrick\u00e1 posloupnost se sou\u010dtem \\(2^{k+1} \u2212 1 \\lt 2n\\)</li> <li>Celkov\u00e1 \u010dasov\u00e1 slo\u017eitost proto \u010din\u00ed \\(\\Theta(n)\\).</li> </ul> <p>K Zamy\u0161len\u00ed</p> <ul> <li>Jak z\u00e1vis\u00ed tvrzen\u00ed p\u0159edchoz\u00ed v\u011bty na volb\u011b po\u010d\u00e1te\u010dn\u00ed kapacity \\(m_0\\)?</li> <li>Jak by se amortizovan\u00e1 slo\u017eitost zm\u011bnila, pokud bychom zvolili jinou strategii nafukov\u00e1n\u00ed pole? Nap\u0159\u00edklad, pokud by velikost nov\u00e9ho v\u011bt\u0161\u00edho pole nebyla volena jako dvojn\u00e1sobn\u00e1, ale (a) jako trojn\u00e1sobn\u00e1, (b) v\u011bt\u0161\u00ed o n\u011bjakou pevnou konstantu \\(c\\) a \\(m_0 = c\\).</li> <li>Uva\u017eujme na po\u010d\u00e1tku pr\u00e1zdnou bin\u00e1rn\u00ed haldu \\(H\\) a posloupnost \\(n\\) operac\u00ed HeapInsert(\\(H,...\\)). Vypo\u010d\u00edtejte amortizovanou slo\u017eitost operace HeapInsert.</li> </ul> <p></p> <p>V\u011bta 4.7 (o slo\u017eitosti HeapBuild)</p> D\u016fkaz V\u011bty 4.7 <p>Na ka\u017ed\u00fd vrchol na za\u010d\u00e1tku polo\u017e\u00edme p pen\u00edzk\u016f. Co d\u011bl\u00e1 ka\u017ed\u00fd prvek?</p> <ul> <li>Porovn\u00e1 se s men\u0161\u00edm ze syn\u016f (2 instrukce), m\u016f\u017ee se s men\u0161\u00edm prohodit (1 instrukce) a pak se p\u0159\u00edpadn\u011b probubl\u00e1v\u00e1 dol\u016f (sm\u011brem k listu).</li> <li>Uk\u00e1\u017eeme, \u017ee za toto zvl\u00e1dne \u201ezaplatit\u201c jeden z podstrom\u016f.</li> <li>Kdy\u017e tedy nakonec p\u0159esuneme v\u0161echny zbyl\u00e9 pen\u00edzky do ko\u0159ene aktu\u00e1ln\u00edho strome\u010dku, zbyde n\u00e1m alespo\u0148 \\(p \u00b7 (k + 1)\\) pen\u00edzk\u016f, kde \\(k\\) je vzd\u00e1lenost ko\u0159enu uva\u017eovan\u00e9ho strome\u010dku od list\u016f.</li> </ul> <p>D\u016fkaz prob\u011bhne indukc\u00ed podle \\(k\\) \u2013 vzd\u00e1lenosti od listu. (Pro jednoduchost p\u0159edpokl\u00e1d\u00e1me, \u017ee posledn\u00ed hladina je zcela zapln\u011bn\u00e1 \u2013 t\u00edm form\u00e1ln\u011b ukazujeme \\(2pn\\), ale nen\u00ed t\u011b\u017ek\u00e9 d\u016fkaz poupravit.)</p> <ul> <li>ZI: \\(k = 0\\). Trivi\u00e1ln\u011b plat\u00ed, nebo\u0165 neprovedeme \u017e\u00e1dn\u00e9 porovn\u00e1n\u00ed a na kont\u011b z\u016fstane \\(p = p(k + 1)\\).</li> <li>IK: \\(k - 1 \\Rightarrow k\\). M\u00e1me \u201enov\u00fd ko\u0159en\u201c ve strom\u011b \\(T\\) a p\u0159edpokl\u00e1d\u00e1me, \u017ee podstromy \\(T_{\u2113}\\) a \\(T_{r}\\) jsou korektn\u011b vytvo\u0159eny a \u017ee (IP) ka\u017ed\u00fd z jejich ko\u0159en\u016f m\u00e1 na kont\u011b \\(pk\\). Hloubka stromu \\(T\\) je \\(k + 1\\). V\u0161imli jsem si, \u017ee v nejhor\u0161\u00edm p\u0159\u00edpad\u011b ud\u011bl\u00e1me s nov\u00fdm prvkem na ka\u017ed\u00e9 hladin\u011b (krom posledn\u00ed) \\(3\\) operace. Celkov\u011b tedy za \u201eopraven\u00ed\u201c stromu \\(T\\) zaplat\u00edme \\(3k\\). Na konci n\u00e1m tedy zbyde \\(z = p + 2pk \u2212 3k\\). Pokud zvol\u00edme \\(p \\geq 3\\), bude jist\u011b \\(z \\geq p(k + 1)\\)</li> </ul>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.6_Amortizovan%C3%A1_%C4%8Dasov%C3%A1_slo%C5%BEitost/#def-4.4","title":"Amortizovan\u00e1 \u010dasov\u00e1 slo\u017eitost","text":"<p>Operace \\(A\\) nad dynamickou datovou strukturou m\u00e1 v dan\u00e9m kontextu sv\u00e9ho prov\u00e1d\u011bn\u00ed amortizovanou \u010dasovou slo\u017eitost \\(O(f(n))\\) (zna\u010d\u00edme \\(O^*(f(n))\\)), pokud posloupnost \\(k\\) operac\u00ed \\(A\\) m\u00e1 celkovou \u010dasovou slo\u017eitost \\(O(k \u00b7 f(n))\\).</p> <p>Parametr \\(n\\) je velikost dynamick\u00e9 mno\u017einy po proveden\u00ed t\u00e9to posloupnosti operac\u00ed.</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.6_Amortizovan%C3%A1_%C4%8Dasov%C3%A1_slo%C5%BEitost/#def-4.6","title":"O amortizovan\u00e9 anal\u00fdze nafukovac\u00edho pole","text":"<p>Uva\u017eujme na po\u010d\u00e1tku pr\u00e1zdn\u00e9 nafukovac\u00ed pole. Potom celkov\u00e1 \u010dasov\u00e1 slo\u017eitost posloupnosti \\(n\\) operac\u00ed NPInsert je \\(\\Theta(n)\\), neboli amortizovan\u00e1 slo\u017eitost operace NPInsert je \\(\\Theta^*(1)\\).</p>"},{"location":"04_Bin%C3%A1rn%C3%AD_haldy/4.6_Amortizovan%C3%A1_%C4%8Dasov%C3%A1_slo%C5%BEitost/#def-4.7","title":"V\u011bta o amortizovan\u00e9 anal\u00fdze nafukovac\u00edho pole","text":"<p>Operace HeapBuild m\u00e1 \u010dasovou slo\u017eitost \\(O(n)\\)</p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.1_Binomi%C3%A1ln%C3%AD_stromy/","title":"5.1 Binomi\u00e1ln\u00ed stromy","text":""},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.1_Binomi%C3%A1ln%C3%AD_stromy/#binomialni-minimova-halda","title":"Binomi\u00e1ln\u00ed minimov\u00e1 halda","text":"<ul> <li>Pro p\u0159ehlednost zkracujeme jako BH. Podporuje stejn\u00e9 operace jako bin\u00e1rn\u00ed halda.</li> <li>Nav\u00edc je schopna rychle prov\u00e1d\u011bt operaci slou\u010den\u00ed dvou hald, kter\u00e1 m\u00e1 u bin\u00e1rn\u00ed haldy line\u00e1rn\u00ed slo\u017eitost   (slou\u010dit dv\u011b bin\u00e1rn\u00ed haldy velikost\u00ed \\(m\\) a \\(n\\) m\u00e1 slo\u017eitost operace HeapBuild haldy velikosti \\(m + n\\)).</li> <li>Binomi\u00e1ln\u00ed halda pat\u0159\u00ed do rodiny tzv. mergeable heaps.</li> <li>Dal\u0161\u00ed dobrou vlastnost\u00ed je vynikaj\u00edc\u00ed amortizovan\u00e1 slo\u017eitost operace vkl\u00e1d\u00e1n\u00ed.</li> <li>Nev\u00fdhodou jsou n\u00e1sobn\u011b vy\u0161\u0161\u00ed pam\u011b\u0165ov\u00e9 n\u00e1roky ne\u017e u bin\u00e1rn\u00ed haldy.</li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.1_Binomi%C3%A1ln%C3%AD_stromy/#slozitosti-operaci-na-binomialni-halde","title":"Slo\u017eitosti operac\u00ed na binomi\u00e1ln\u00ed hald\u011b","text":"Operace Komplexita Popis BHInsert \\(O(log n), \\Theta^{*}(1)\\) Vlo\u017e\u00ed do BH nov\u00fd prvek. BHFindMin \\(O(1)\\) Vr\u00e1t\u00ed minimum mno\u017einy prvk\u016f BH BHExtractMin \\(O(log n)\\) Odstran\u00ed z BH minimum mno\u017einy jej\u00edch prvk\u016f BHMerge \\(O(log n)\\) Slou\u010d\u00ed dv\u011b BH do jedn\u00e9 BHBuild \\(O(n)\\) Postav\u00ed z \\(n\\) prvk\u016f BH BHDecreaseKey \\(O(log n)\\) Sn\u00ed\u017e\u00ed hodnotu kl\u00ed\u010de prvku BH. BHIncreaseKey \\(O(log n)\\) Zv\u00fd\u0161\u00ed hodnotu kl\u00ed\u010de prvku BH. BHDelete \\(O(log n)\\) Sma\u017ee prvek BH. <p>Definice 5.1 (Binomi\u00e1ln\u00ed strom)</p> <p></p> <p></p> <p>Definice 5.2 (Binomi\u00e1ln\u00ed strom alternativn\u011b)</p> <p></p> <p></p> <p>V\u011bta 5.1 (o izomorfismu \\(B_{k}\\) a \\(B^{\u2032}_{k})\\)</p> <p></p> D\u016fkaz \\(B_{k} \\implies B^{\u2032}_{k}\\) <ol> <li>Matematickou indukc\u00ed podle \\(k\\).</li> <li>Pro \\(k = 0\\) tvrzen\u00ed zjevn\u011b plat\u00ed.</li> <li>Pod ko\u0159enem stromu \\(B_{k}\\) jsou dle jeho definice zav\u011b\u0161eny stromy \\(B_{0}, . . . , B_{k\u22121}\\).</li> <li>Odtr\u017een\u00edm nejprav\u011bj\u0161\u00edho podstromu \\(B_{k\u22121}\\) od \\(B_{k}\\) v\u0161ak dost\u00e1v\u00e1me podle induk\u010dn\u00edho p\u0159edpokladu strom \\(B_{k\u22121}\\).</li> <li>To d\u00e1v\u00e1 p\u0159esn\u011b definici stromu \\(B^{\u2032}_{k}\\).</li> </ol> D\u016fkaz \\(B^{\u2032}_{k} \\implies B_{k}\\) <ol> <li>Naopak, uv\u00e1\u017e\u00edme-li strom \\(B^{\u2032}_{k}\\), z indukce vypl\u00fdv\u00e1, \u017ee \\(B^{\u2032}_{k\u22121}\\) je izomorfn\u00ed s \\(B_{k\u22121}\\), pod jeho\u017e ko\u0159en jsou dle definice napojeny stromy \\(B_{0}, . . . , B_{k\u22122}.\\)</li> <li>Pod ko\u0159en \\(B^{\u2032}\\) k jsou tud\u00ed\u017e napojeny stromy \\(B_{0}, . . . , B_{k\u22121}.\\)</li> <li>To d\u00e1v\u00e1 p\u0159esn\u011b definici stromu \\(B_{k}.\\)</li> </ol>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.1_Binomi%C3%A1ln%C3%AD_stromy/#def-5.1","title":"Binomi\u00e1ln\u00ed strom","text":"<p>Binomi\u00e1ln\u00ed strom \u0159\u00e1du \\(k\\) (zna\u010d\u00edme \\(B_{k}\\)) je uspo\u0159\u00e1dan\u00fd (t.j. z\u00e1le\u017e\u00ed na po\u0159ad\u00ed syn\u016f) zako\u0159en\u011bn\u00fd strom, pro kter\u00fd plat\u00ed:</p> <ol> <li>\\(B_{0}\\) je tvo\u0159en pouze ko\u0159enem.</li> <li>Pro \\(k \\geq 1\\) z\u00edsk\u00e1me \\(B_{k}\\) ze strom\u016f \\(B_{0}, B_{1}, . . . , B_{k\u22121}\\) tak, \u017ee p\u0159id\u00e1me nov\u00fd ko\u0159en a ko\u0159eny t\u011bchto strom\u016f ud\u011bl\u00e1me (takto popo\u0159ad\u011b) syny nov\u00e9ho ko\u0159ene</li> </ol>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.1_Binomi%C3%A1ln%C3%AD_stromy/#def-5.2","title":"Binomi\u00e1ln\u00ed strom alternativn\u011b","text":"<p>Binomi\u00e1ln\u00ed strom \u0159\u00e1du \\(k\\) (zna\u010d\u00edme \\(B^{\u2032}_{k}\\)) je uspo\u0159\u00e1dan\u00fd zako\u0159en\u011bn\u00fd strom, pro kter\u00fd plat\u00ed:</p> <ul> <li>\\(B^{\u2032}_{0}\\) je tvo\u0159en pouze ko\u0159enem.</li> <li>Pro \\(k \\geq 1\\) se \\(B^{\u2032}_{k}\\) skl\u00e1d\u00e1 ze stromu \\(B^{\u2032}_{k\u22121}\\), pod jeho\u017e ko\u0159enem je jako nejprav\u011bj\u0161\u00ed syn napojen\u00fd dal\u0161\u00ed strom \\(B^{\u2032}_{k\u22121}\\).</li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.1_Binomi%C3%A1ln%C3%AD_stromy/#theorem-5.1","title":"V\u011bta o izomorfismu binomi\u00e1ln\u00edch strom\u016f","text":"<p>Stromy \\(B_{k}\\) a \\(B^{\u2032}_{k}\\) jsou izomorfn\u00ed</p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.1_Binomi%C3%A1ln%C3%AD_stromy/#vlastnosti-binomialnich-stromu","title":"Vlastnosti binomi\u00e1ln\u00edch strom\u016f","text":"<p>V\u011bta 5.2 (o vlastnostech \\(B_{k}\\))</p> D\u016fkaz V\u011bty 5.2 <ol> <li>Indukc\u00ed podle \\(k\\).</li> <li>Strom \\(B_{0}\\) m\u00e1 jist\u011b \\(1\\) hladinu a \\(2^{0} = 1\\) vrchol.</li> <li>Z induk\u010dn\u00edho p\u0159edpokladu vypl\u00fdv\u00e1, \u017ee po\u010det hladin \\(B_{k\u22121}\\) je \\(k\\) a po\u010det vrchol\u016f je \\(2^{k\u22121}\\).  \\(\\implies\\) vlastnosti \\(1\\) a \\(3\\) dok\u00e1z\u00e1ny.</li> <li>U\u017eit\u00edm dok\u00e1zan\u00e9 \u010d\u00e1sti v\u011bty 5.2 dost\u00e1v\u00e1me, \u017ee strom \\(B_{k}\\) je slo\u017een\u00fd ze dvou strom\u016f \\(B_{k\u22121}\\), z nich\u017e jeden je o hladinu n\u00ed\u017ee ne\u017e druh\u00fd, co\u017e d\u00e1v\u00e1 po\u010det hladin \\(k + 1\\) stromu \\(B_{k}\\).</li> <li>Slo\u017een\u00edm dvou strom\u016f \\(B_{k\u22121}\\) dost\u00e1v\u00e1me \\(2 \u00b7 2^{k\u22121} = 2^{k}\\) vrchol\u016f.</li> <li>Stupe\u0148 ko\u0159ene \\(B_{k\u22121}\\) je dle IP k \u2212 1 a p\u0159id\u00e1n\u00edm jednoho nov\u00e9ho syna je stupe\u0148 \\(B_{k}\\) tedy roven \\(k\\) \\(\\implies\\) vlastnost \\(2\\) je dok\u00e1z\u00e1na</li> </ol> <p>D\u016fsledek</p> <p>Binomi\u00e1ln\u00ed strom s \\(n\\) vrcholy (pokud existuje) m\u00e1 \\(1 + log n\\) hladin a po\u010det syn\u016f ko\u0159ene \\(log n\\)</p> <p></p> <p>V\u011bta 5.3 (o po\u010dtu vrchol\u016f \\(B_{k}\\) na hladin\u011b \\(i\\))</p> D\u016fkaz V\u011bty 5.3 <ol> <li>Indukc\u00ed podle \u0159\u00e1du \\(k\\).</li> <li>V\u011bta 5.3 plat\u00ed trivi\u00e1ln\u011b pro \\(B_{0}\\) a \\(B_{1}\\) (a \\(B_{2}\\)).</li> <li>Nech\u0165 tedy \\(k \\geq 2\\).</li> <li> <p>Z definice \\(B^{\u2032}_{k}\\) plyne, \u017ee vrcholy \\(B^{\u2032}_{k}\\) na \\(i.\\) hladin\u011b, \\(0 \\lt i \\lt k\\), jsou tvo\u0159eny:</p> <ul> <li>vrcholy lev\u00e9ho \\(B^{\u2032}_{k\u22121}\\) na \\(i.\\) hladin\u011b</li> <li>vrcholy prav\u00e9ho \\(B^{\u2032}_{k\u22121}\\) na \\((i \u2212 1).\\) hladin\u011b.</li> </ul> </li> <li> <p>Z induk\u010dn\u00edho p\u0159edpokladu tedy dostaneme Pascalov\u00fdm pravidlem</p> </li> </ol> \\[ n_{k}(i) = n_{k-1}(i) + n_{k-1}(i - 1) = \\binom{k-1}{i} + \\binom {k-1}{i-1} = \\binom{k}{i} \\]"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.1_Binomi%C3%A1ln%C3%AD_stromy/#theorem-5.2","title":"V\u011bta o vlastnostech binomi\u00e1ln\u00edho stromu","text":"<ul> <li>Po\u010det hladin stromu \\(B_{k}\\) je roven \\(k + 1\\)</li> <li>Stupe\u0148 ko\u0159ene je \\(k\\)</li> <li>Po\u010det vrchol\u016f \\(B_{k}\\) je roven \\(2^{k}\\).</li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.1_Binomi%C3%A1ln%C3%AD_stromy/#theorem-5.3","title":"V\u011bta o po\u010dtu vrchol\u016f binomi\u00e1ln\u00edho stromu na hladin\u011b","text":"<p>Po\u010det vrchol\u016f stromu \\(B_{k}\\) na \\(i.\\) hladin\u011b \\((i \\in \\{0, . . . , k\\}) = n_{k}(i) = \\binom{k}{i}\\)</p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.2_Binomi%C3%A1ln%C3%AD_halda/","title":"5.2 Binomi\u00e1ln\u00ed halda","text":"<p>Definice 5.3 (Binomi\u00e1ln\u00ed halda)</p> <p></p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.2_Binomi%C3%A1ln%C3%AD_halda/#def-5.3","title":"Binomi\u00e1ln\u00ed halda","text":"<p>Binomi\u00e1ln\u00ed halda (BH) obsahuj\u00edc\u00ed \\(n\\) prvk\u016f je uspo\u0159\u00e1dan\u00e1 mno\u017eina binomi\u00e1ln\u00edch strom\u016f \\(T = T_{1}, . . . , T_{\u2113}\\), kde plat\u00ed:</p> <ul> <li>Stromy \\(T_{i}\\) jsou v \\(T\\) uspo\u0159\u00e1d\u00e1ny vzestupn\u011b podle sv\u00fdch \u0159\u00e1d\u016f.</li> <li>\\(n = |V (T_{1})| + \u00b7 \u00b7 \u00b7 + |V (T_{\u2113})|.\\)</li> <li>Pro ka\u017ed\u00e9 nez\u00e1porn\u00e9 \\(k\\) se v mno\u017ein\u011b \\(T\\) vyskytuje nejv\u00fd\u0161e jeden binomi\u00e1ln\u00ed strom \u0159\u00e1du \\(k\\).</li> <li>Ka\u017ed\u00fd vrchol \\(v\\) v ka\u017ed\u00e9m stromu obsahuje kl\u00ed\u010d \\(k(v)\\).</li> <li>Pro ka\u017ed\u00fd strom \\(T_{i}\\) plat\u00ed haldov\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed kl\u00ed\u010d\u016f, \u010dili<ul> <li>\\(\\forall v \\in V (T_{i})\\) a pro v\u0161echny jeho syny \\(s_{j} , j = 1, 2, . . . , m,\\) plat\u00ed \\(k(v) \\leq k(s_{j}).\\)</li> </ul> </li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.2_Binomi%C3%A1ln%C3%AD_halda/#pametova-reprezentace-binomialni-haldy-v-pocitaci","title":"Pam\u011b\u0165ov\u00e1 reprezentace binomi\u00e1ln\u00ed haldy v po\u010d\u00edta\u010di","text":"<ul> <li>Pro ulo\u017een\u00ed uspo\u0159\u00e1dan\u00e9 mno\u017einy strom\u016f \\(\\mathcal{T}\\) BH se pou\u017e\u00edv\u00e1 spojov\u00fd seznam.</li> <li>Seznamy syn\u016f jednotliv\u00fdch vrchol\u016f v binomi\u00e1ln\u00edch stromech budeme tak\u00e9 udr\u017eovat ve spojov\u00fdch seznamech.</li> <li>Konkr\u00e9tn\u00ed implementaci prvku BH si p\u0159edvedeme pozd\u011bji, a\u017e budeme zn\u00e1t po\u017eadavky na operace, kter\u00e9 s BH budeme prov\u00e1d\u011bt.</li> <li>Kl\u00ed\u010d prvku v budeme v pseudok\u00f3du zna\u010dit \\(k(v)\\).</li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.2_Binomi%C3%A1ln%C3%AD_halda/#vlastnosti-binomialni-haldy","title":"Vlastnosti binomi\u00e1ln\u00ed haldy","text":"<p>V\u011bta 5.4 (o existenci stromu \\(B_{i}\\) v BH)</p> D\u016fkaz V\u011bty 5.4 <p>Proto\u017ee v BH nelze pou\u017e\u00edt dva binomi\u00e1ln\u00ed stromy stejn\u00e9ho \u0159\u00e1du a  ka\u017ed\u00fd binomi\u00e1ln\u00ed strom \\(B_{i}\\) p\u0159isp\u011bje do \\(n\\)-prvkov\u00e9 BH pr\u00e1v\u011b sv\u00fdmi  \\(|V(B_{i})| = 2^{i}\\) vrcholy, je poskl\u00e1d\u00e1n\u00ed \\(n\\) prvkov\u00e9 BH z binomi\u00e1ln\u00edch strom\u016f ekvivalentn\u00ed z\u00e1pisu \u010d\u00edsla \\(n\\) ve standardn\u00ed dvojkov\u00e9 soustav\u011b.</p> <p>D\u016fsledek</p> <p>n-prvkov\u00e1 BH m\u00e1 a\u017e \\(O(log n)\\) binomi\u00e1ln\u00edch strom\u016f.</p> <p></p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.2_Binomi%C3%A1ln%C3%AD_halda/#theorem-5.4","title":"V\u011bta o existenci binomi\u00e1ln\u00edho stromu Bi v binomi\u00e1ln\u00ed hald\u011b","text":"<p>Binomi\u00e1ln\u00ed strom \\(B_{i}\\) se vyskytuje v seznamu \\(\\mathcal{T}\\) \\(n\\)-prvkov\u00e9 BH pr\u00e1v\u011b tehdy, kdy\u017e ve dvojkov\u00e9m z\u00e1pisu \\(b_{k}b_{k\u22121} . . . b_{0}\\) \u010d\u00edsla \\(n\\) je \\(b_{i} = 1\\).</p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/","title":"5.3 Operace na BH","text":""},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#nalezeni-minima-bhfindminh","title":"Nalezen\u00ed minima \u2013 BHFindMin(H):","text":"<ul> <li>Minimum cel\u00e9 BH se mus\u00ed nach\u00e1zet v jednom z ko\u0159en\u016f strom\u016f \\(T_{i}\\).</li> <li>Sta\u010d\u00ed proj\u00edt seznam \\(\\mathcal{T}\\) , co\u017e bude trvat \u010das \\(O(log n)\\).</li> <li>Pou\u017e\u00edv\u00e1me-li tuto funkci \u010dasto, vyplat\u00ed se udr\u017eovat ukazatel na tento glob\u00e1ln\u011b nejmen\u0161\u00ed ko\u0159en. Operaci BHFindMin   lze pak prov\u00e9st v konstantn\u00edm \u010dase.</li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#slouceni-dvou-bh-bhmerge","title":"Slou\u010den\u00ed dvou BH \u2013 BHMerge","text":"<ul> <li>Slou\u010den\u00ed dvou BH pop\u00ed\u0161eme nejd\u0159\u00edve, proto\u017ee se pomoc\u00ed n\u011bho realizuj\u00ed ostatn\u00ed operace.</li> <li>Operace BHMerge ze dvou BH vytvo\u0159\u00ed jedinou, obsahuj\u00edc\u00ed sjednocen\u00ed prvk\u016f obou vstupn\u00edch BH.</li> <li>Nejprve pop\u00ed\u0161eme operaci BHMergeTree, kter\u00e1 slije dohromady dva binomi\u00e1ln\u00ed stromy stejn\u00e9ho \u0159\u00e1du \\(B_{i}\\) a   vytvo\u0159\u00ed strom \\(B_{i+1}\\)   (na to lze nahl\u00ed\u017eet i jako na slou\u010den\u00ed dvou BH tvo\u0159en\u00fdch jedin\u00fdm binomi\u00e1ln\u00edm stromem stejn\u00e9ho \u0159\u00e1du).</li> </ul> <p>Algoritmus 5.1 (BHMergeTree)</p> <p>Pozorov\u00e1n\u00ed</p> <p>Algoritmus BHMergeTree\\((T_{1}, T_{2})\\), kde \u0159\u00e1d(\\(T_{1}\\)) \\(=\\) \u0159\u00e1d(\\(T_{2}\\)), vytvo\u0159\u00ed korektn\u00ed binomi\u00e1ln\u00ed strom s \u0159\u00e1dem \u0159\u00e1d(\\(T_{1}\\)) \\(+ 1\\)</p> <p>Tvrzen\u00ed</p> <p>BH lze implementovat tak, \u017ee BHMergeTree\\((T_{1}, T_{2})\\) m\u00e1 \u010dasovou slo\u017eitost \\(O(1).\\)</p> <p></p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#algo-5.1","title":"Algoritmus BHMergeTree","text":"<p>Vstup</p> <p>Binomi\u00e1ln\u00ed stromy \\(T_{1}, T_{2}\\) takov\u00e9, \u017ee \u0159\u00e1d(\\(T_{1}\\)) = \u0159\u00e1d(\\(T_{2}\\))</p> <p>V\u00fdstup</p> <p>V\u00fdsledn\u00fd strom \\(T_{out}\\)</p> <p>Algoritmus</p> <pre><code>Pokud k(ko\u0159en(T1)) \u2264 k(ko\u0159en(T2)):\n    P\u0159ipoj ko\u0159en(T2) jako nejprav\u011bj\u0161\u00edho syna pod ko\u0159en(T1).\n    Tout := T1\nJinak:\n    P\u0159ipoj ko\u0159en(T1) jako nejprav\u011bj\u0161\u00edho syna pod ko\u0159en(T2).\nTout := T2\n</code></pre>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#idea-algoritmu-bhmerge-pro-slouceni-dvou-bh","title":"Idea algoritmu BHMerge pro slou\u010den\u00ed dvou BH","text":"<ul> <li>M\u011bjme BH \\(A\\) a \\(B\\), kde po\u010det prvk\u016f \\(A\\) je \\(a\\) a v bin\u00e1rn\u00edm z\u00e1pise \\(a = a_{k}a_{k\u22121} . . . a_{0}\\) a po\u010det   prvk\u016f \\(B\\) je \\(b = b_{\u2113}b_{\u2113\u22121} . . . b_{0}.\\)</li> <li>V\u00fdsledn\u00e1 halda \\(C\\) bude m\u00edt \\(c = a + b\\) prvk\u016f, \\(c = c_{m}c_{m\u22121} . . . c_{0}.\\)</li> <li>\u0158\u00e1dy binomi\u00e1ln\u00edch strom\u016f ve v\u0161ech t\u0159\u00ed hald\u00e1ch jsou jednozna\u010dn\u011b ur\u010deny bin\u00e1rn\u00edm z\u00e1pisem jejich po\u010dtu prvk\u016f.</li> <li> <p>P\u0159ipome\u0148me \"\u0161koln\u00ed\" algoritmus na s\u010d\u00edt\u00e1n\u00ed bin\u00e1rn\u00edch \u010d\u00edsel \\(a\\) a \\(b\\) pod sebou:    jdeme od nejni\u017e\u0161\u00edch \u0159\u00e1d\u016f bin\u00e1rn\u00edho z\u00e1pisu k nejvy\u0161\u0161\u00edm a</p> <ul> <li>v\u00fdsledn\u00fd bit \\(c_{i} = (a_{i} + b_{i} +\\) carry\\(_{i})\\) mod \\(2\\), kde carry\\(_{i}\\) je tzv. p\u0159enos z p\u0159edchoz\u00edho   \u0159\u00e1du a</li> <li>n\u00e1sledn\u011b carry\\(_{i+1}\\) := \\((a_{i} + b_{i} +\\) carry\\(_{i}\\)) div \\(2.\\)</li> </ul> </li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#binarni-scitani-priklad","title":"Bin\u00e1rn\u00ed s\u010d\u00edt\u00e1n\u00ed - p\u0159\u00edklad","text":"<ul> <li>\\(c_{i} = (a_{i} + b_{i} +\\) carry\\(_{i}\\)) mod \\(2\\)</li> <li>carry\\(_{i+1}\\) := \\((a_{i} + b_{i} +\\) carry\\(_{i})\\) div \\(2\\)</li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#aplikace-binarniho-scitani-na-bh","title":"Aplikace bin\u00e1rn\u00edho s\u010d\u00edt\u00e1n\u00ed na BH","text":"<p>Algoritmus na vytvo\u0159en\u00ed BH \\(C\\) nyn\u00ed zrcadl\u00ed p\u0159edchoz\u00ed algoritmus s\u010d\u00edt\u00e1n\u00ed bin\u00e1rn\u00edch \u010d\u00edsel s t\u00edm rozd\u00edlem, \u017ee:</p> <ol> <li>Bity \\(a_{i}, b_{i},\\) carry\\(_{i}\\) budou nyn\u00ed binomi\u00e1ln\u00ed stromy \\(A_{i}\\), \\(B_{i}\\), carry\\(_{i}\\) \u0159\u00e1du \\(i\\) nebo    pr\u00e1zdn\u00e9.</li> <li>M\u00edsto s\u010d\u00edt\u00e1n\u00ed dvou jedni\u010dkov\u00fdch bit\u016f vol\u00e1me BHMergeTree na dva binomi\u00e1ln\u00ed stromy stejn\u00e9ho \u0159\u00e1du, co\u017e vytvo\u0159\u00ed strom    vy\u0161\u0161\u00edho \u0159\u00e1du a tedy p\u0159enos carry do dal\u0161\u00edho \u0159\u00e1du.</li> <li>Jsou-li v\u0161echny t\u0159i stromy \\(A_{i}, B_{i},\\) carry\\(_{i}\\) nepr\u00e1zdn\u00e9, slou\u010d\u00edme \\(A_{i}\\) a \\(B_{i}\\) a v\u00fdsledek se stane    p\u0159enosem do vy\u0161\u0161\u00edho \u0159\u00e1du carry\\(_{i+1}\\) a do \\(C_{i}\\) p\u0159i\u0159ad\u00edme carry\\(_{i}\\).</li> <li>Proto\u017ee udr\u017eujeme seznamy binomi\u00e1ln\u00edch strom\u016f BH uspo\u0159\u00e1dan\u00e9 dle jejich \u0159\u00e1d\u016f, lze algoritmus realizovat pr\u016fchodem    dvou ukazatel\u016f po t\u011bchto seznamech a p\u0159eskakov\u00e1n\u00edm \u0159\u00e1d\u016f strom\u016f nep\u0159\u00edtomn\u00fdch v BH.</li> </ol> <p></p> <p></p> <p>Algoritmus 5.2 (BHMerge)</p> <p></p> <p>V\u011bta 5.5 (o korektnosti a slo\u017eitosti algoritmu BHMerge)</p> D\u016fkaz V\u011bty 5.5 <ol> <li>V ka\u017ed\u00e9 iteraci se zpracuj\u00ed v\u0161echny stromy \u0159\u00e1du akt_rad.</li> <li>N\u00e1sledn\u011b se akt_rad zv\u00fd\u0161\u00ed o jedna.</li> <li>V\u0161echny operace uvnit\u0159 cyklu trvaj\u00ed \u010das \\(O(1)\\).</li> <li>Nejvy\u0161\u0161\u00ed \u0159\u00e1d je \\(O(log n)\\), celkov\u00fd \u010das je tedy \\(O(log n)\\).</li> </ol>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#algo-5.2","title":"Algoritmus BHMerge","text":"BHMerge(A, B)<pre><code>scitanci[0 . . . 2]         //pole aktu\u00e1ln\u00edch s\u010d\u00edtanc\u016f\ncarry := null               //p\u0159enos\nneprazdnych := 2            //po\u010det zb\u00fdvaj\u00edc\u00edch s\u010d\u00edtanc\u016f\nakt_rad := 0                //aktu\u00e1ln\u00ed \u0159\u00e1d\nDokud neprazdnych \u2265 2:\n    neprazdnych := 0\n    pocet := 0              //po\u010det s\u010d\u00edtanc\u016f v aktu\u00e1ln\u00edm \u0159\u00e1du\n    Pokud A je nepr\u00e1zdn\u00e1:\n        neprazdnych++\n        a := strom nejni\u017e\u0161\u00edho \u0159\u00e1du v A\n        Pokud \u0159\u00e1d(a) = akt_rad:\n            scitanci[pocet]:= a\n            pocet++\n            vy\u0159a\u010f a z A\n    Pokud B je nepr\u00e1zdn\u00e1:\n        neprazdnych++\n        b := strom nejni\u017e\u0161\u00edho \u0159\u00e1du v B\n        Pokud \u0159\u00e1d(b) = akt_rad:\n            scitanci[pocet]:= b\n            pocet++\n            vy\u0159a\u010f b z B\n    Pokud carry nen\u00ed null:\n        neprazdnych++\n        scitanci[pocet]:= carry\n        pocet++\n        carry:= null\n\n    Pokud pocet= 3:\n        zapi\u0161 scitanci[2] do v\u00fdstupu C\n        carry := BHMergeTree(scitanci[0], scitanci[1])\n    Pokud pocet= 2:\n        carry := BHMergeTree(scitanci[0], scitanci[1])\n    Pokud pocet= 1:\n        zapi\u0161 scitanci[0] do v\u00fdstupu C\n    akt_rad++\nP\u0159e\u0159a\u010f do C zbytek BH A nebo B (pokud je\u0161t\u011b n\u011bco zb\u00fdv\u00e1)\nP\u0159epoj ukazatel na minimum na men\u0161\u00ed z minim z A a B\n</code></pre>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#theorem-5.5","title":"V\u011bta o korektnosti a slo\u017eitosti BHMerge","text":"<p>Algoritmus BHMerge je korektn\u00ed a jeho \u010dasov\u00e1 slo\u017eitost je \\(O(log n).\\)</p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#vkladani-prvku-do-bh-bhinsert","title":"Vkl\u00e1d\u00e1n\u00ed prvku do BH - BHInsert","text":"<p>Algoritmus 5.3 (BHInsert)</p> <p></p> <p></p> <p>V\u011bta 5.6 (o slo\u017eitosti algoritmu BHInsert)</p> D\u016fkaz V\u011bty 5.6 <ol> <li>V\u00edme, \u017ee binomi\u00e1ln\u00ed stromy tvo\u0159\u00edc\u00ed \\(n\\)-prvkovou BH p\u0159esn\u011b odpov\u00eddaj\u00ed jedni\u010dkov\u00fdm bit\u016fm v dvojkov\u00e9m z\u00e1pisu \u010d\u00edsla \\(n\\).</li> <li>Operace BHInsert je slou\u010den\u00ed s jednoprvkovou BH a to odpov\u00edd\u00e1 operaci Inc bin\u00e1rn\u00ed s\u010d\u00edta\u010dky.</li> <li>Proveden\u00ed operace BHMergeTree s \\(O(1)\\) slo\u017eitost\u00ed b\u011bhem BHInsert odpov\u00edd\u00e1 bitov\u00e9 inverzi v operaci Inc.</li> <li>Dle anal\u00fdzy bin\u00e1rn\u00ed s\u010d\u00edta\u010dky m\u00e1 tedy operace BHInsert amortizovanou slo\u017eitost \\(O^{*}(1)\\).</li> </ol>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#algo-5.3","title":"Algoritmus BHInsert","text":"BHInsert(H,x):<pre><code>Vytvo\u0159\u00edme BH H\u2032 s jedin\u00fdm prvkem x.\nBHMerge(H, H\u2032)\n</code></pre>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#theorem-5.6","title":"V\u011bta o slo\u017eitosti algoritmu BHInsert","text":"<p>Operace BHInsert m\u00e1 v nejhor\u0161\u00edm p\u0159\u00edpad\u011b slo\u017eitost \\(O(log n).\\) Pro na po\u010d\u00e1tku pr\u00e1zdnou BH trv\u00e1 posloupnost \\(n\\) vol\u00e1n\u00ed operace BHInsert \u010das \\(O(n).\\) BHInsert m\u00e1 tedy amortizovanou \u010dasovou slo\u017eitost \\(O^{*}(1).\\)</p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#vytvoreni-n-prvkove-bh-bhbuild","title":"Vytvo\u0159en\u00ed n prvkov\u00e9 BH \u2013 BHBuild","text":"<ul> <li>Vol\u00e1n\u00edm BHInsert \\(n\\) kr\u00e1t po sob\u011b vytvo\u0159\u00edme BH o velikosti \\(n.\\)</li> <li>Podle p\u0159edchoz\u00ed anal\u00fdzy bude trvat vytvo\u0159en\u00ed \\(n\\)-prvkov\u00e9 BH   \u010das \\(O(n).\\)</li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#odstraneni-minima-z-bh-bhextractmin","title":"Odstran\u011bn\u00ed minima z BH \u2013 BHExtractMin","text":"<p>Algoritmus 5.4 (BHExtractMin)</p> <p>(4)  Z T vytvo\u0159 novou BH H\u2032 </p> <ul> <li>Pot\u0159ebujeme v \u010dase \\(O(log n)\\) vytvo\u0159it BH ze syn\u016f (podstrom\u016f) stromu \\(\\mathcal{T}\\) .</li> <li>Toho pot\u0159ebujeme dos\u00e1hnout p\u0159i zachov\u00e1n\u00ed \\(O(1)\\) \u010dasu pro BHMergeTree</li> </ul> <p> </p> <p></p> <p>V\u011bta 5.7 (o slo\u017eitosti algoritmu BHExtractMin)</p> D\u016fkaz V\u011bty 5.7 <ol> <li>Kroky \\((1)\\) a \\((2)\\) trvaj\u00ed \u010das \\(O(1)\\), sta\u010d\u00ed si udr\u017eovat minimov\u00fd ukazatel na strom a vypojit ho ze seznamu.</li> <li>Kroky \\((3)\\) a \\((4)\\) trvaj\u00ed \\(O(logn)\\), proto\u017ee ko\u0159en binomi\u00e1ln\u00edho stromu m\u00e1 nejv\u00fd\u0161e \\(O(logn)\\) syn\u016f.</li> <li>Slou\u010den\u00ed hald trv\u00e1 \\(O(logn)\\), v\u010detn\u011b rekonstrukce minimov\u00e9ho ukazatele.</li> </ol>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#algo-5.4","title":"Algoritmus BHInsert","text":"<pre><code>Najdi v BH H strom T , jeho\u017e ko\u0159en je minimem.\nOdpoj tento strom T z BH H.\nOdtrhni z T jeho ko\u0159en.\nZ T vytvo\u0159 novou BH H\u2032. -&gt; POZOR\nProve\u010f BHMerge(H, H\u2032). \n</code></pre>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.3_Operace_na_BH/#theorem-5.7","title":"V\u011bta o slo\u017eitosti algoritmu BHExtractMin","text":"<ul> <li>\u010casov\u00e1 slo\u017eitost operace BHExtractMin je \\(O(log n)\\).</li> </ul>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.4_Reprezentace/","title":"5.4 Reprezentace","text":""},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.4_Reprezentace/#pametova-reprezentace-prvku-bh","title":"Pam\u011b\u0165ov\u00e1 reprezentace prvk\u016f BH","text":"<p>Prvek v BH bude v po\u010d\u00edta\u010di reprezentov\u00e1n pomoc\u00ed n\u00e1sleduj\u00edc\u00ed struktury:</p> <ul> <li>Ukazatel na otce</li> <li>Ukazatel na lev\u00e9ho sourozence</li> <li>Ukazatel na nejprav\u011bj\u0161\u00edho syna</li> <li>Hodnota \\(k(v)\\)</li> </ul> <p>Tvrzen\u00ed</p> <p>BHMergeTree i vytvo\u0159en\u00ed BH ze seznamu syn\u016f ko\u0159ene lze v \u010dase \\(O(log n)\\), kde \\(n\\) je po\u010det prvk\u016f ve v\u00fdsledn\u00e9 BH</p> <p></p> <p>K Zamy\u0161len\u00ed</p> <p>Jak v minimov\u00e9 BH ud\u011blat operace:</p> <ul> <li>BHDecreaseKey v \u010dase \\(O(log n)\\)?</li> <li>BHDelete v \u010dase \\(O(log n)\\)?</li> <li>BHIncreaseKey v \u010dase \\(O(log n)\\)?</li> </ul> <p>V\u0161echny operace dostanou ukazatel na prvek, se kter\u00fdm se pracuje</p>"},{"location":"05_Binomi%C3%A1ln%C3%AD_haldy/5.4_Reprezentace/#srovnani-binarni-a-binomialni-haldy","title":"Srovn\u00e1n\u00ed bin\u00e1rn\u00ed a binomi\u00e1ln\u00ed haldy","text":"Operace Bin\u00e1rn\u00ed Binomi\u00e1ln\u00ed Vlo\u017een\u00ed prvku do haldy velikosti \\(n\\) \\(O^{*}(log n), O(log n)\\) \\(O^{*}(1), O(log n)\\) ExtractMin z haldy velikosti \\(n\\) \\(O(log n)\\) \\(O(log n)\\) Slou\u010den\u00ed 2 hald velikosti \\(n\\) \\(O(n)\\) \\(O(log n)\\) <p>Binomi\u00e1ln\u00ed haldy jsou nejjednodu\u0161\u0161\u00edm \u0159e\u0161en\u00edm tzv. mergeable heaps, kter\u00e9 dok\u00e1\u017eou velmi efektivn\u011b prov\u00e9st operaci slou\u010den\u00ed a ostatn\u00ed operace maj\u00ed na operaci slou\u010den\u00ed postaven\u00e9.</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.1_%C3%9Avod_do_BVS/","title":"6.1 \u00davod do BVS","text":"<p>Bin\u00e1rn\u00ed strom (opakov\u00e1n\u00ed)</p> <p>Strom nazveme bin\u00e1rn\u00ed, pokud</p> <ul> <li>je zako\u0159en\u011bn\u00fd</li> <li>ka\u017ed\u00fd vrchol m\u00e1 nejv\u00fd\u0161e dva syny</li> <li>u syn\u016f rozli\u0161ujeme, kter\u00fd je lev\u00fd a kter\u00fd prav\u00fd.</li> </ul> <p>Zna\u010den\u00ed</p> <p>Pro vrchol v bin\u00e1rn\u00edho stromu \\(T\\) zna\u010d\u00edme</p> <ul> <li>\\(\u2113(v)\\) a \\(r(v)\\): lev\u00fd a prav\u00fd syn vrcholu \\(v\\)</li> <li>\\(L(v)\\) a \\(R(v)\\): lev\u00fd a prav\u00fd podstrom vrcholu \\(v\\)</li> <li>\\(p(v)\\): otec vrcholu \\(v\\)</li> <li>\\(T(v)\\): podstrom tvo\u0159en\u00fd ko\u0159enem v a v\u0161echny jeho potomky</li> <li>\\(h(T(v))\\): hloubka stromu \\(T(v)\\) je po\u010det hladin \\(T(v)\\)</li> <li>\\(|T|, |T (v)|, |L(v)|, |R(v)|\\): po\u010det vrchol\u016f stromu \\(T , T(v), L(v)\\) a \\(R(v)\\)</li> </ul> <ul> <li>Pokud vrchol v nem\u00e1 lev\u00e9ho syna, polo\u017e\u00edme \\(\u2113(v) = \\emptyset.\\)</li> <li>Podobn\u011b pro \\(r(v)\\) a \\(p(v)\\)</li> <li>Pak dodefinujeme, \u017ee \\(T (\\emptyset)\\) je pr\u00e1zdn\u00fd strom a \\(h(T (\\emptyset)) = 0.\\)</li> </ul> <p></p> <p>Zna\u010den\u00ed bin\u00e1rn\u00edho stromu</p> <p>Konvence z\u00e1pisu pseudok\u00f3du</p> <ul> <li>Bin\u00e1rn\u00ed strom budeme v pam\u011bti po\u010d\u00edta\u010de reprezentovat pomoc\u00ed spojov\u00fdch struktur.</li> <li>V algoritmech popisuj\u00edc\u00edch v pseudok\u00f3du operace nad bin\u00e1rn\u00edmi stromy budeme pracovat s ukazateli na jejich vrcholy.</li> </ul> <p></p> <p>Definice 6.1 (Bin\u00e1rn\u00ed vyhled\u00e1vac\u00ed strom)</p> <p></p> <p>P\u0159\u00edklady BVS</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.1_%C3%9Avod_do_BVS/#def-6.1","title":"Bin\u00e1rn\u00ed vyhled\u00e1vac\u00ed strom (BVS)","text":"<p>Bin\u00e1rn\u00ed vyhled\u00e1vac\u00ed strom (BVS) je bin\u00e1rn\u00ed strom, v jeho\u017e ka\u017ed\u00e9m vrcholu \\(v\\) je ulo\u017een unik\u00e1tn\u00ed kl\u00ed\u010d \\(k(v)\\) a pro jeho\u017e ka\u017ed\u00fd vrchol \\(v\\) plat\u00ed:</p> <ul> <li>Pokud \\(a \\in L(v)\\), pak \\(k(a) \\lt k(v).\\)</li> <li>Pokud \\(b \\in R(v)\\), pak \\(k(b) \\gt k(v).\\)</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/","title":"6.2 Operace BVS","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#prehled-operaci-bvs","title":"P\u0159ehled operac\u00ed BVS","text":"Operace Komplexita Popis BVSShow\\((v)\\) \\(O(n)\\) Vypi\u0161 vzestupn\u011b uspo\u0159\u00e1danou posloupnost kl\u00ed\u010d\u016f v\u0161ech vrchol\u016f \\(T (v).\\) BVSMin\\((v)\\) \\(O(logn)\\) Vra\u0165 vrchol obsahuj\u00edc\u00ed minim\u00e1ln\u00ed kl\u00ed\u010d v \\(T (v)\\) BVSMax\\((v)\\) \\(O(logn)\\) Vra\u0165 vrchol obsahuj\u00edc\u00ed maxim\u00e1ln\u00ed kl\u00ed\u010d v \\(T (v)\\) BVSPred\\((v,w)\\) \\(O(logn), \\Theta^{*}(1)\\) Vra\u0165 p\u0159edch\u016fdce vrcholu \\(w\\) v \\(T(v)\\) BVSSucc\\((v,w)\\) \\(O(logn), \\Theta^{*}(1)\\) Vra\u0165 n\u00e1sledn\u00edka vrcholu \\(w\\) v \\(T(v)\\) BVSFind\\((v, x)\\) \\(O(logn)\\) Vra\u0165 vrchol v \\(T(v)\\) s kl\u00ed\u010dem \\(x\\), pokud takov\u00fd existuje BVSInsert\\((v,x)\\) \\(O(logn)\\) Vlo\u017e do \\(T(v)\\) nov\u00fd vrchol s kl\u00ed\u010dem \\(x\\), pokud v n\u011bm je\u0161t\u011b neexistuje BVSDelete\\((v,x)\\) \\(O(logn)\\) Odstra\u0148 z \\(T(v)\\) vrchol s kl\u00ed\u010dem \\(x\\), pokud takov\u00fd existuje <p>Komplexita operac\u00ed v t\u00e9to tabulce uva\u017euje hloubkov\u011b vyva\u017eovan\u00fd strom, pro nevyva\u017eovan\u00fd strom by byla komplexita v\u0161ech operac\u00ed \\(O(n)\\)</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#operace-bvs","title":"Operace BVS","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#bvsshow","title":"BVSShow","text":"<p>Algoritmus 6.1 (BVSShow)</p> <p>Pozorov\u00e1n\u00ed</p> <p>BVSShow\\((v)\\) vyp\u00ed\u0161e vzestupn\u011b uspo\u0159\u00e1dan\u00e9 kl\u00ed\u010de vrchol\u016f BVS \\(T(v)\\) v \u010dase \\(O(|T(v)|)\\)</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#algo-6.1","title":"Algoritmus BVSShow","text":"<p>Vstup</p> <p>Ukazatel na ko\u0159en \\(v\\) n\u011bjak\u00e9ho BVS \\(T(v)\\)</p> <p>V\u00fdstup</p> <p>Vzestupn\u011b uspo\u0159\u00e1dan\u00e1 posloupnost kl\u00ed\u010d\u016f v\u0161ech vrchol\u016f v \\(T(v)\\)</p> <p>Algoritmus</p> BVSShow(ukazatel na vrchol v)<pre><code>    Pokud v = \u2205: return         //T (v) je pr\u00e1zdn\u00fd\n    Zavol\u00e1me BVSShow(\u2113(v))\n    Vyp\u00ed\u0161eme k(v)\n    Zavol\u00e1me BVSShow(r(v))\n</code></pre>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#bvsmin","title":"BVSMin","text":"<ul> <li>Nalezen\u00ed vrcholu s maxim\u00e1ln\u00edm kl\u00ed\u010dem je analogick\u00e9.</li> </ul> <p>Pozorov\u00e1n\u00ed</p> <p>Nejmen\u0161\u00ed kl\u00ed\u010d je prvn\u00ed v posloupnosti vzestupn\u011b uspo\u0159\u00e1dan\u00fdch kl\u00ed\u010d\u016f vygenerovan\u00fdch v p\u0159edchoz\u00edm algoritmu InOrder pr\u016fchodem a tud\u00ed\u017e vrchol s nejmen\u0161\u00edm kl\u00ed\u010dem je v dan\u00e9m BVS ten nejv\u00edce vlevo. Je to tud\u00ed\u017e bu\u010f list nebo vrchol s jedn\u00edm synem.</p> <p></p> <p>Algoritmus 6.2 (BVSMin)</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#algo-6.2","title":"Algoritmus BVSMin","text":"<p>Vstup</p> <p>Ukazatel na ko\u0159en \\(v\\) n\u011bjak\u00e9ho BVS \\(T(v)\\)</p> <p>V\u00fdstup</p> <p>Ukazatel na vrchol obsahuj\u00edc\u00ed nejmen\u0161\u00ed kl\u00ed\u010d v \\(T(v)\\)</p> <p>Algorithm</p> BVSMin(ukazatel na vrchol v)<pre><code>Pokud \u2113(v) = \u2205: vra\u0165 ukazatel na vrchol v\nJinak: vra\u0165 BVSMin(\u2113(v))\n</code></pre>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#bvspred","title":"BVSPred","text":"<p>Pozorov\u00e1n\u00ed</p> <ul> <li>Kl\u00ed\u010d p\u0159edch\u016fdce prvku \\(w\\) v \\(T(v)\\) je ve vzestupn\u00e9m v\u00fdpisu kl\u00ed\u010d\u016f algoritmem BVSShow lev\u00fdm sousedem \\(k(w).\\)</li> <li>Pokud m\u00e1 \\(w\\) v \\(T(v)\\) lev\u00fd podstrom \\(L(w)\\), pak je p\u0159edch\u016fdce w jeho maximem.</li> <li>V opa\u010dn\u00e9m p\u0159\u00edpad\u011b je p\u0159edch\u016fdcem \\(w\\) prvn\u00ed p\u0159edek, do kter\u00e9ho vstoup\u00edme zprava p\u0159i pr\u016fchodu nahoru.</li> <li>Evidentn\u011b, prvek s nejmen\u0161\u00edm kl\u00ed\u010dem p\u0159edch\u016fdce nem\u00e1, nebo\u0165 nespl\u0148uje ani jednu podm\u00ednku</li> </ul> <p></p> <p>Algoritmus 6.3 (BVSPred)</p> <p>K zamy\u0161len\u00ed</p> <p>Ov\u011b\u0159te, \u017ee pro \\(w =\\) BVSMin(\\(v\\)) vrac\u00ed tento algoritmus \\(\\emptyset\\)</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#algo-6.3","title":"Algoritmus BVSPred","text":"<p>Vstup</p> <p>Ukazatel na ko\u0159en \\(v\\) n\u011bjak\u00e9ho BVS \\(T(v)\\) a na n\u011bjak\u00fd jeho vrchol \\(w\\)</p> <p>V\u00fdstup</p> <p>Ukazatel na p\u0159edch\u016fdce \\(w\\) v \\(T(v)\\)</p> <p>Algoritmus</p> BVSPred(ukazatel na ko\u0159en v, ukazatel na vrchol w)<pre><code>Pokud w != BVSFind(v, k(w)): vra\u0165 (\u2205)\nPokud \u2113(w) != \u2205: vra\u0165 BVSMax(\u2113(w))\nz := p(w)\nDokud z != \u2205 &amp; w = \u2113(z):\n    w := z\n    z := p(z)\nvra\u0165 ukazatel na vrchol z\n</code></pre>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#bvsfind","title":"BVSFind","text":"<ul> <li>Hled\u00e1n\u00ed vrcholu BVS s dan\u00fdm kl\u00ed\u010dem</li> </ul> <p>Algoritmus 6.4 (BVSFind)</p> <p>Pozorov\u00e1n\u00ed</p> <p>Korektnost plyne okam\u017eit\u011b z definice BVS: </p> <ul> <li>V libovoln\u00e9m vrcholu \\(u\\) plat\u00ed, \u017ee v\u0161echny kl\u00ed\u010de v \\(L(u)\\) jsou men\u0161\u00ed ne\u017e \\(k(u)\\) </li> <li>V\u0161echny kl\u00ed\u010de v \\(R(u)\\) jsou v\u011bt\u0161\u00ed ne\u017e \\(k(u)\\)</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#algo-6.4","title":"Algoritmus BVSFind","text":"<p>Vstup</p> <p>Ukazatel na ko\u0159en \\(v\\) n\u011bjak\u00e9ho BVS \\(T(v)\\) a kl\u00ed\u010d \\(x\\)</p> <p>V\u00fdstup</p> <p>Ukazatel na vrchol s kl\u00ed\u010dem \\(x\\), pokud takov\u00fd v \\(T(v)\\) existuje, jinak \\(\\emptyset\\)</p> <p>Algoritmus</p> BVSFind(ukazatel na vrchol v, kl\u00ed\u010d x)<pre><code>Pokud v = \u2205: vra\u0165 \u2205\nPokud x = k(v): vra\u0165 ukazatel na v\nPokud x &lt; k(v): vra\u0165 BVSFind(\u2113(v), x)\nPokud x &gt; k(v): vra\u0165 BVSFind(r(v), x)\n</code></pre>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#bvsinsert","title":"BVSInsert","text":"<ul> <li>Vlo\u017een\u00ed vrcholu s dan\u00fdm kl\u00ed\u010dem do BVS</li> </ul> <p>Algoritmus 6.5 (BVSInsert)</p> <p>Pozorov\u00e1n\u00ed</p> <p>Operaci BVSInsert lze ch\u00e1pat jako hled\u00e1n\u00ed dan\u00e9ho kl\u00ed\u010de a pokud kl\u00ed\u010d nenajdeme, vlo\u017e\u00edme ho na jednozna\u010dn\u011b ur\u010denou pozici jako nov\u00fd list (p\u0159edpokl\u00e1d\u00e1me unik\u00e1tn\u00ed kl\u00ed\u010de)</p> <p>Pozorov\u00e1n\u00ed (tvar BVS)</p> <ul> <li>Z dosud uveden\u00e9ho vypl\u00fdv\u00e1, \u017ee danou mno\u017einu kl\u00ed\u010d\u016f bude existovat v\u00edce korektn\u00edch BVS li\u0161\u00edc\u00edch se tvarem, proto\u017ee v\u00fdsledn\u00fd tvar BVS z\u00e1vis\u00ed nejen na hodnot\u00e1ch kl\u00ed\u010d\u016f, ale i na po\u0159ad\u00ed, v jak\u00e9m jsou do BVS vkl\u00e1d\u00e1ny.</li> <li>Operace BVSShow vr\u00e1t\u00ed pro v\u0161echny mo\u017en\u00e9 BVS nad stejnou mno\u017einou kl\u00ed\u010d\u016f stejnou uspo\u0159\u00e1danou posloupnost kl\u00ed\u010d\u016f.</li> <li>Geometricky tomuto line\u00e1rn\u00edmu v\u00fdpisu odpov\u00edd\u00e1 pr\u016fm\u011bt na vodorovnou osu.</li> </ul> <p></p> <p>Tvar BVS</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#algo-6.5","title":"Algoritmus BVSInsert","text":"<p>Vstup</p> <p>Ukazatel na ko\u0159en \\(v\\) n\u011bjak\u00e9ho BVS \\(T(v)\\) a kl\u00ed\u010d \\(x\\)</p> <p>V\u00fdstup</p> <p>Ukazatel na ko\u0159en \\(v\\) BVS s prvkem s kl\u00ed\u010dem \\(x\\)</p> <p>Algoritmus</p> BVSInsert(ukazatel na vrchol v, kl\u00ed\u010d x)<pre><code>Pokud v = \u2205:\n    vytvo\u0159 nov\u00fd vrchol v s kl\u00ed\u010dem x\n    vra\u0165 ukazatel na v a skon\u010d\u00edme\nPokud x = k(v): nic     //vrchol s kl\u00ed\u010dem x v T (v) ji\u017e existuje\nPokud x &lt; k(v): \u2113(v) := BVSInsert(\u2113(v), x)\nPokud x &gt; k(v): r(v) := BVSInsert(r(v), x)\nVra\u0165 ukazatel na v\n</code></pre>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#bvsdelete","title":"BVSDelete","text":"<ul> <li>Odstran\u011bn\u00ed vrcholu s dan\u00fdm kl\u00ed\u010dem z BVS</li> <li>Nejd\u0159\u00edve nalezneme vrchol, kter\u00fd obsahuje kl\u00ed\u010d, kter\u00fd chceme smazat.</li> <li>P\u0159i maz\u00e1n\u00ed vrcholu m\u016f\u017ee nastat n\u011bkolik r\u016fzn\u00fdch p\u0159\u00edpad\u016f:</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#pripady-bvsdelete","title":"P\u0159\u00edpady BVSDelete","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#1-vrchol-v-neni-v-t","title":"1. Vrchol \\(v\\) nen\u00ed v \\(T\\)","text":"<ul> <li>\\(T\\) je ponech\u00e1n beze zm\u011bny</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#2-vrchol-v-je-listem-t","title":"2. Vrchol \\(v\\) je listem \\(T\\)","text":"<ul> <li>Vrchol \\(v\\) je odstran\u011bn z \\(T\\)</li> </ul> <p>Odstran\u011bn\u00ed listu BVS</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#3-vrchol-v-ma-jednoho-syna","title":"3. Vrchol \\(v\\) m\u00e1 jednoho syna","text":"<ul> <li>Vrchol \\(v\\) nahrad\u00edme jeho jedin\u00fdm synem</li> </ul> <p>Odstran\u011bn\u00ed vrcholu s jedn\u00edm synem</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#4-vrchol-u-ma-dva-syny","title":"4. Vrchol \\(u\\) m\u00e1 dva syny","text":"<ul> <li>Pak \\(u\\) nem\u016f\u017eeme odstranit p\u0159\u00edmo, proto\u017ee by nebylo kam p\u0159ipojit jeho syny.</li> <li>Vyu\u017eijeme ale faktu, \u017ee vrchol \\(u\\) m\u00e1 v BVS n\u00e1sledn\u00edka \\(w\\) = BVSMin(r(u)).</li> <li>A ten m\u00e1 nejv\u00fd\u0161e jednoho syna (prav\u00e9ho, kdyby m\u011bl lev\u00e9ho, tak je n\u00e1sledn\u00edk jeho lev\u00fd syn)</li> <li>Kl\u00ed\u010d vrcholu \\(u\\) nahrad\u00edme kl\u00ed\u010dem vrcholu \\(w\\)</li> <li>Aplikac\u00ed postupu z p\u0159\u00edpadu 2) nebo 3) pak odstran\u00edme z BVS vrchol \\(w\\).</li> </ul> <p>Odstran\u011bn\u00ed vrcholu se dv\u011bma syny</p> <p></p> <p>Algoritmus 6.6 (BVSDelete)</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.2_Operace_BVS/#algo-6.6","title":"Algoritmus BVSDelete","text":"<p>Vstup</p> <p>Ukazatel na ko\u0159en \\(v\\) n\u011bjak\u00e9ho BVS a kl\u00ed\u010d \\(x\\)</p> <p>V\u00fdstup</p> <p>Ukazatel na ko\u0159en BVS, ze kter\u00e9ho byl odstran\u011bn vrchol s kl\u00ed\u010dem \\(x\\), pokud takov\u00fd vrchol existoval.</p> <p>Algoritmus</p> BVSDelete(ukazatel na vrchol v, kl\u00ed\u010d x)<pre><code>Pokud v = \u2205: vra\u0165 \u2205\nPokud x &lt; k(v): \u2113(v) := BVSDelete(\u2113(v), x)\nPokud x &gt; k(v): r(v) := BVSDelete(r(v), x)\nPokud x = k(v):\n    Pokud \u2113(v)= r(v)= \u2205: vra\u0165 \u2205\n    Pokud \u2113(v)= \u2205: vra\u0165 r(v)\n    Pokud r(v)= \u2205: vra\u0165 \u2113(v)\n    w := BVSMin(r(v))       // v m\u00e1 oba syny, w n\u00e1sledn\u00edk\n    k(v) := k(w)\n    r(v) := BVSDelete(r(v), k(w))\nvra\u0165 ukazatel na v\n</code></pre>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.3_Vyv%C3%A1%C5%BEenost_BVS/","title":"6.3 Vyv\u00e1\u017eenost BVS","text":"<p>Pozorov\u00e1n\u00ed</p> <p>\u010casov\u00e1 slo\u017eitost operac\u00ed BVSFind, BVSMin, BVSInsert a BVSDelete nad BVS \\(T(v)\\) je:</p> \\[ O(h(T (v))) \\] <p>Pozorov\u00e1n\u00ed</p> <p>Hloubka \\(h(T(v))\\) BVS \\(T(v)\\) je:</p> <ul> <li>v nejlep\u0161\u00edm p\u0159\u00edpad\u011b \\(\\Omega(log |T (v)|)\\)</li> <li>v nejhor\u0161\u00edm p\u0159\u00edpad\u011b \\(O(|T (v)|)\\)  (nap\u0159. BVS vytvo\u0159en\u00fd postupn\u00fdm vlo\u017een\u00edm kl\u00ed\u010d\u016f \\(1, 2, . . . , n\\) v tomto po\u0159ad\u00ed).</li> </ul> <p></p> <p>Dva BVS se stejn\u00fdmi vrcholy a jinou hloubkou</p> <p></p> <p>Definice 6.2 (Dokonale vyv\u00e1\u017een\u00fd BVS)</p> <p>Pozorov\u00e1n\u00ed</p> <p>Dokonale vyv\u00e1\u017een\u00fd BVS o velikosti \\(n\\) m\u00e1 \\(1 + \u230alog n\u230b\\) hladin a operace BVSFind, BVSMin, BVSInsert a BVSDelete na n\u011bm tedy maj\u00ed \u010dasovou slo\u017eitost \\(O(logn)\\)</p> <p></p> <p>V\u011bta 6.1 (o slo\u017eitosti operac\u00ed nad dokonale vyv\u00e1\u017een\u00fdm BVS)</p> D\u016fkaz V\u011bty 6.1 <p>Uva\u017eujme dokonale vyv\u00e1\u017een\u00fd BVS s kl\u00ed\u010di \\(1, 2, . . . , n\\), kde \\(n = 2^{k} - 1\\)  Ten pak vypad\u00e1 nutn\u011b takto:</p> <p></p> <ol> <li>Ko\u0159en stromu je v\u017edy prost\u0159edn\u00ed z kl\u00ed\u010d\u016f.</li> <li>V\u0161echna lich\u00e1 \u010d\u00edsla jsou v listech stromu.</li> <li>Lev\u00fd a prav\u00fd podstrom maj\u00ed pr\u00e1v\u011b \\(2^{k\u22121} \u2212 1\\) vrchol\u016f a jsou tedy op\u011bt ur\u010deny jednozna\u010dn\u011b.</li> <li>Nyn\u00ed provedeme n\u00e1sleduj\u00edc\u00ed posloupnost dvojic operac\u00ed:  \\(Insert(n + 1), Delete(1), Insert(n + 2), Delete(2), . . .\\)</li> <li>Po proveden\u00ed i-t\u00e9 dvojice operac\u00ed bude strom obsahovat hodnoty \\(i + 1, . . . , i + n\\)</li> <li>Podle toho, zda je \\(i\\) sud\u00e9 nebo lich\u00e9, se budou v listech nach\u00e1zet bu\u010f v\u0161echna sud\u00e1, nebo v\u0161echna lich\u00e1 \u010d\u00edsla.</li> <li>Poka\u017ed\u00e9 se proto v\u0161em vrchol\u016fm zm\u011bn\u00ed, zda jsou listy, co\u017e ale nutn\u011b znamen\u00e1 upravit \\(\\Omega (n)\\) ukazatel\u016f.</li> <li>Tedy aspo\u0148 jedna z operac\u00ed BVSInsert a BVSDelete trv\u00e1 \\(\\Omega (n)\\)</li> </ol>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.3_Vyv%C3%A1%C5%BEenost_BVS/#def-6.2","title":"Dokonale vyv\u00e1\u017een\u00fd BVS","text":"<p>BVS nazveme dokonale vyv\u00e1\u017een\u00fd, pokud pro ka\u017ed\u00fd jeho vrchol \\(v\\) plat\u00ed</p> \\[ ||L(v)| \u2212 |R(v)|| \u2264 1 \\]"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.3_Vyv%C3%A1%C5%BEenost_BVS/#theorem-6.1","title":"V\u011bta o slo\u017eitosti operac\u00ed nad dokonale vyv\u00e1\u017een\u00fdm BVS","text":"<p>Pokud m\u00e1 BVS z\u016fst\u00e1vat po proveden\u00ed operac\u00ed BVSInsert a BVSDelete dokonale vyv\u00e1\u017een\u00fd, potom a\u0165 pou\u017eijeme jakoukoli implementaci zm\u00edn\u011bn\u00fdch operac\u00ed, bude \u010dasov\u00e1 slo\u017eitost aspo\u0148 jedn\u00e9 z nich \\(\\Omega (n)\\) pro nekone\u010dn\u011b mnoho r\u016fzn\u00fdch \\(n\\)</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/","title":"6.4 AVL rotace","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#hloubkove-vyvazeni-avl-stromy","title":"Hloubkov\u00e9 vyv\u00e1\u017een\u00ed: AVL stromy","text":"<ul> <li>Z p\u0159edchoz\u00edho v\u00fdkladu tedy plyne, \u017ee \u017e\u00e1dn\u00e9 krit\u00e9rium vyv\u00e1\u017eenosti   stejn\u011b jako p\u0159\u00edli\u0161 p\u0159\u00edsn\u00e9 krit\u00e9rium vyv\u00e1\u017eenosti vedou v nejhor\u0161\u00edm   p\u0159\u00edpad\u011b na line\u00e1rn\u00ed slo\u017eitost alespo\u0148 jedn\u00e9 z operac\u00ed BVS.</li> <li>Krit\u00e9rium vyv\u00e1\u017eenosti BVS je tedy t\u0159eba definovat m\u00e9n\u011b   restriktivn\u011b, sta\u010d\u00ed udr\u017eovat hloubku \\(O(logn)\\).</li> </ul> <p>Definice 6.3 (Hloubkov\u011b vyv\u00e1\u017een\u00fd BVS)</p> <ul> <li>Existuje n\u011bkolik r\u016fzn\u00fdch \u0159e\u0161en\u00ed, zde si vysv\u011btl\u00edme tzv.   AVL-stromy, kter\u00e9 jsou efektivn\u00ed implementac\u00ed hloubkov\u011b   vyv\u00e1\u017een\u00fdch BVS.</li> </ul> <p></p> <p>V\u011bta 6.2 (o hloubce hloubkov\u011b vyv\u00e1\u017een\u00fdch strom\u016f)</p> D\u016fkaz V\u011bty 6.2 <ol> <li>Definujme \\(A_{h} =\\) min. po\u010det vrchol\u016f HV stromu hloubky \\(h\\)</li> <li>Uk\u00e1\u017eeme, \u017ee \\(A_{h}\\) roste exponenci\u00e1ln\u011b s \\(h\\)</li> <li>Nejmen\u0161\u00ed takov\u00e9 stromy dan\u00e9 hloubky jsou maxim\u00e1ln\u011b \"hloubkov\u011b vyv\u00e1\u017een\u00e9\" v mez\u00edch definice, \u010dili v ka\u017ed\u00e9m vnit\u0159n\u00edm vrcholu v plat\u00ed \\(|h(L(v)) \u2212 h(R(v))| = 1.\\) Pro \\(h \\le 4\\) lze nejmen\u0161\u00ed HV stromy hloubky \\(h\\) nal\u00e9zt p\u0159\u00edmo:  </li> <li>Obecn\u011b pak minim\u00e1ln\u00ed HV strom hloubky \\(h\\) mus\u00ed m\u00edt jako podstromy minim\u00e1ln\u00ed HV stromy hloubky \\(h \u2212 1\\) a \\(h \u2212 2\\)</li> <li>Mus\u00ed tedy platit \\(A_{h} = A_{h\u22121} + A_{h\u22122} + 1\\)</li> <li> <p>Dok\u00e1\u017eeme indukc\u00ed, \u017ee \\(A_{h+1} \\geq 2^{\\frac{h}{2}} \\stackrel{\\cdot}{=} 1.41^{h}\\)</p> <ul> <li>IZ: \\(A_{1} = 1 \\geq 2^{\\frac{0}{2}} = 1\\) a \\(A_{2} = 2 \\geq 2^{\\frac{1}{2}}\\)</li> <li>IK:</li> </ul> \\[ \\begin{align} A_{h+1} &amp; = 1 + A_{h} + A_{h-1} \\gt \\\\\\\\ &amp; \\gt 2^{\\frac{h-1}{2}} + 2^{\\frac{h-2}{2}} = \\\\\\\\ &amp; = 2^{\\frac{h}{2}} \\cdot (2^{-\\frac{1}{2}} + 2^{-1}) \\gt \\\\\\\\ &amp; \\gt 2^{\\frac{h}{2}} \\cdot (\\frac{1}{2} + \\frac{1}{2}) = \\\\\\\\ &amp; = 2^{\\frac{h}{2}} \\end{align} \\] </li> <li> <p>HV strom hloubky \\(h + 1\\) m\u00e1 tedy nejm\u00e9n\u011b \\(\\sqrt{2^{h}}\\) vrchol\u016f.</p> </li> <li>Proto HV strom o \\(n\\) vrcholech m\u00e1 hloubku nejv\u00fd\u0161e \\(log_{\\sqrt{2}}(n) + 1\\)</li> <li>A proto\u017ee je bin\u00e1rn\u00ed, nem\u016f\u017ee m\u00edt hloubku men\u0161\u00ed ne\u017e \\(\u230alog_{2} n\u230b\\)</li> <li>Tedy hloubka HV stromu o \\(n\\) vrcholech je \\(\\Theta (log n)\\)</li> </ol>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#def-6.3","title":"Hloubkov\u011b vyv\u00e1\u017een\u00fd BVS","text":"<p>BVS je hloubkov\u011b vyv\u00e1\u017een\u00fd, pokud pro ka\u017ed\u00fd jeho vrchol \\(v\\) plat\u00ed</p> \\[ |h(L(v)) \u2212 h(R(v))| \\le 1 \\]"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#theorem-6.2","title":"V\u011bta o hloubce hloubkov\u011b vyv\u00e1\u017een\u00fdch strom\u016f","text":"<p>Hloubkov\u011b vyv\u00e1\u017een\u00fd strom s \\(n\\) vrcholy m\u00e1 hloubku \\(\\Theta (log n)\\)</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#udrzovani-hloubkoveho-vyvazeni","title":"Udr\u017eov\u00e1n\u00ed hloubkov\u00e9ho vyv\u00e1\u017een\u00ed","text":"<ul> <li>Operace BVSShow, BVSMin, BVSPred a BVSFind nem\u011bn\u00ed ani tvar   ani obsah BVS, funguj\u00ed tedy beze zm\u011bny i pro AVL stromy.</li> <li>Operace vkl\u00e1d\u00e1n\u00ed a maz\u00e1n\u00ed prvk\u016f ale hloubky podstrom\u016f m\u011bn\u00ed.</li> <li>Proto operace AVLInsert a AVLDelete vlo\u017e\u00ed/vyjmou vrchol   jako u BVSInsert a BVSDelete, ale pak kontroluj\u00ed sm\u011brem ke   ko\u0159enu hloubkovou vyv\u00e1\u017eenost a p\u0159i jej\u00edm poru\u0161en\u00ed ji opravuj\u00ed</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#jak-kontrolovat-a-pripadne-opravit-hloubkovou-nevyvazenost","title":"Jak kontrolovat a p\u0159\u00edpadn\u011b opravit hloubkovou nevyv\u00e1\u017eenost?","text":"<ol> <li>V ka\u017ed\u00e9m vrcholu v v\u017edy spo\u010dteme \u010d\u00edslo    \\(\\delta(v) = h(R(v)) \u2212 h(L(v))\\), kter\u00e9 nazveme znam\u00e9nko vrcholu \\(v\\).</li> <li> <p>V korektn\u00edm AVL stromu m\u016f\u017ee nab\u00fdvat jen t\u011bchto hodnot:</p> <ul> <li>\\(\\delta (v) = +1\\) (prav\u00fd podstrom hlub\u0161\u00ed) \u2013 zna\u010d\u00edme \\(+1\\)</li> <li>\\(\\delta (v) = \u22121\\) (lev\u00fd podstrom hlub\u0161\u00ed) \u2013 zna\u010d\u00edme \\(-1\\)</li> <li>\\(\\delta (v) = 0\\) (oba podstromy stejn\u011b hlubok\u00e9) \u2013 zna\u010d\u00edme \\(0\\)</li> </ul> </li> <li> <p>Jakmile p\u0159i kontrole naraz\u00edme na jin\u00e9 \\(\\delta(v)\\), strom oprav\u00edme pomoc\u00ed jednoduch\u00fdch nebo dvojit\u00fdch rotac\u00ed</p> </li> </ol>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#avl-rotace","title":"AVL rotace","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#jednoduche-avl-rotace","title":"Jednoduch\u00e9 AVL rotace","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#jednoducha-rotace-doprava-r","title":"Jednoduch\u00e1 rotace doprava (R)","text":"<ul> <li>Jednoduch\u00e1 rotace doprava oprav\u00ed hloubkovou nevyv\u00e1\u017eenost v modelov\u00e9 situaci dle obr\u00e1zku dole, kdy:<ul> <li>\\(y = \u2113(x)\\) a \\(h = h(B) = h(C) = h(A) \u2212 1\\) a tud\u00ed\u017e</li> <li>\\(\\delta (y) = \\mathbf{-1}\\) a \\(\\delta (x) = \\mathbf{-2}\\)</li> </ul> </li> <li>Po proveden\u00ed rotace doprava je \\(\\delta (x) = \\delta(y) = 0\\)</li> <li>Z definice BVS plyne, \u017ee p\u0159epojen\u00ed \\(B\\) od \\(y\\) k \\(x\\) zachov\u00e1v\u00e1 BVS</li> </ul> <p>Jednoduch\u00e1 rotace doprava v AVL stromu</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#jednoducha-rotace-doleva-l","title":"Jednoduch\u00e1 rotace doleva (L)","text":"<ul> <li>Jednoduch\u00e1 rotace doleva je zrcadlov\u011b symetrick\u00e1 modelov\u00e1 situace:<ul> <li>\\(y = r(x)\\) a \\(h(A) = h(B) = h(C) \u2212 1\\) a tud\u00ed\u017e</li> <li>\\(\\delta(x) = \\mathbf{+2}\\) a \\(\\delta(y) = \\mathbf{+1}\\)</li> </ul> </li> <li>Po proveden\u00ed rotace doleva je op\u011bt \\(\\delta(x) = \\delta(y) = 0\\)</li> </ul> <p>Jednoduch\u00e1 rotace doleva v AVL stromu</p> <p></p> <p>Algoritmus 6.7 (rotateLeft)</p> <ul> <li>Vn\u011bj\u0161\u00ed algoritmus pot\u00e9 mus\u00ed p\u0159\u00edpadnou zm\u011bnu hloubky podstromu propagovat s\u00e1m.</li> </ul> <p>Pozorov\u00e1n\u00ed</p> <p>Pokud je \\(x\\) vrcholem v bin\u00e1rn\u00edm vyhled\u00e1vac\u00edm strom\u011b, potom po vol\u00e1n\u00ed rotateLeft\\((x)\\) m\u00e1me op\u011bt bin\u00e1rn\u00ed vyhled\u00e1vac\u00ed strom.</p> <p>Pozorov\u00e1n\u00ed</p> <ul> <li>V\u0161e plat\u00ed symetricky pro rotateRight\\((x)\\)</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#algo-6.7","title":"Algoritmus rotateLeft","text":"<p>Vstup </p> <ul> <li>Vrchol \\(x\\) v BVS</li> </ul> rotateLeft(x)<pre><code>y := r(x)\nr(x) := \u2113(y)\n\u2113(y) := x\np(r(x)) := x; p(y) := p(x); p(x) := y;\nh(T (x)) := max(h(L(x)), h(R(x))) + 1;\nh(T (y)) := max(h(R(y)), h(T (x))) + 1\n</code></pre>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#dvojite-avl-rotace","title":"Dvojit\u00e9 AVL rotace","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#situace-kdy-jednoducha-rotace-nepomuze","title":"Situace, kdy jednoduch\u00e1 rotace nepom\u016f\u017ee","text":"<ul> <li>Lze snadno nahl\u00e9dnout, \u017ee jednoduch\u00e1 rotace nepom\u016f\u017ee v modelov\u00e9 situaci na obr\u00e1zku, kdy \\(h(A) = h(C) = h(B) \u2212 1\\)</li> <li>Uk\u00e1z\u00e1no pro rotaci doprava: m\u00edsto \\(\\delta(y) = \\mathbf{+1}\\) a \\(\\delta(x) = \\mathbf{-2}\\) dostaneme \\(\\delta(y) = \\mathbf{+2}\\) a \\(\\delta(x) = \\mathbf{-1}\\)</li> </ul> <ul> <li>V podobn\u00fdch situac\u00edch je nutn\u00e9 pou\u017e\u00edt posloupnost dvou jednoduch\u00fdch rotac\u00ed, bu\u010f LR nebo RL, kter\u00e9 naz\u00fdv\u00e1me dvojit\u00e9 rotace.</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#dvojita-rotace-lr","title":"Dvojit\u00e1 rotace LR","text":"<ul> <li>Nech\u0165 \\(h(A) = h(B) = h(D) = h(C) + 1\\)</li> <li>A tedy \\(\\delta(x) = \\mathbf{-2}, \\delta(y) = \\mathbf{+1}\\) a \\(\\delta(z) = \\mathbf{-1}\\)</li> </ul> <p>LR rotace</p> <ul> <li>Po proveden\u00ed LR rotace m\u00e1me \\(\\delta(y) = \\delta(z) = \\mathbf{0}\\) a \\(\\delta(x) = \\mathbf{+1}\\)</li> <li>Funguje zjevn\u011b i pro situace, kde je na po\u010d\u00e1tku \\(\\delta(z) = \\mathbf{+1}\\) nebo \\(\\delta(y) = \\mathbf{+2}\\)</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.4_AVL_rotace/#dvojita-rotace-rl","title":"Dvojit\u00e1 rotace RL","text":"<ul> <li>Nech\u0165 op\u011bt symetricky \\(h(A) = h(B) = h(D) = h(C) + 1\\)</li> <li>A tedy \\(\\delta(x) = \\mathbf{+2}, \\delta(y) = \\mathbf{-1}\\) a \\(\\delta(z) = \\mathbf{-1}\\)</li> </ul> <p>RL rotace</p> <ul> <li>Po proveden\u00ed RL rotace m\u00e1me \\(\\delta(x) = \\delta(z) = \\mathbf{0}\\) a \\(\\delta(y) = \\mathbf{+1}\\)</li> <li>Funguje zjevn\u011b, i kdy\u017e je na po\u010d\u00e1tku \\(\\delta(z) = \\mathbf{+1}\\) nebo \\(\\delta(y) = \\mathbf{-2}\\)</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/","title":"6.5 AVL operace","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#avlinsert","title":"AVLInsert","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#idea","title":"Idea","text":"<ol> <li>Nov\u00fd vrchol vlo\u017e\u00edme standardn\u011b jako list se znam\u00e9nkem \\(\\mathbf{0}\\)</li> <li>Z pr\u00e1zdn\u00e9ho podstromu hloubky \\(0\\) se tak stal jednovrcholov\u00fd podstrom hloubky \\(1\\)</li> <li>Potom je t\u0159eba p\u0159epo\u010d\u00edtat hloubky strom\u016f na cest\u011b z jeho rodi\u010de do ko\u0159ene.</li> <li>Proto budeme propagovat nahoru informaci o tom, \u017ee se zv\u011bt\u0161ila hloubka podstromu.</li> <li>V jednotliv\u00fdch \u00farovn\u00edch se tato informace zpracuje v z\u00e1vislosti na hloubk\u00e1ch p\u0159\u00edslu\u0161n\u00fdch sourozenc\u016f.</li> <li>Tuto kontrolu a p\u0159\u00edpadn\u00e9 napraven\u00ed nevyv\u00e1\u017eenost\u00ed m\u016f\u017eeme elegantn\u011b prov\u00e9st b\u011bhem n\u00e1vratu z rekurze v procedu\u0159e AVLInsert</li> </ol>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#oprava-hloubkoveho-vyvazeni","title":"Oprava hloubkov\u00e9ho vyv\u00e1\u017een\u00ed","text":"<p>Pop\u00ed\u0161eme propagaci pro jeden vrchol:</p> <ol> <li>Nech\u0165 do n\u011bjak\u00e9ho vrcholu \\(x\\) p\u0159i\u0161la z jeho syna informace o prohlouben\u00ed podstromu.</li> <li> <p>Uk\u00e1\u017eeme pro p\u0159\u00edpad, kdy p\u0159i\u0161la z lev\u00e9ho syna</p> <ul> <li>P\u0159\u00edpad, kdy p\u0159i\u0161la z prav\u00e9ho syna, se \u0159e\u0161\u00ed obdobn\u011b, jen se vym\u011bn\u00ed v\u00fdznam \\(\\mathbf{+1}\\) a \\(\\mathbf{-1}\\), lev\u00e9ho a prav\u00e9ho podstromu a sm\u011br rotac\u00ed.</li> <li>Rozli\u0161\u00edme t\u0159i p\u0159\u00edpady podle znam\u00e9nka vrcholu \\(x\\)</li> </ul> </li> </ol>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-1-vrchol-x-mel-znamenko-1","title":"P\u0159\u00edpad 1 - vrchol x m\u011bl znam\u00e9nko +1","text":"<ul> <li>Hloubka lev\u00e9ho podstromu se pr\u00e1v\u011b vyrovnala s hloubkou prav\u00e9ho, \u010dili znam\u00e9nko \\(x\\) se zm\u011bn\u00ed na \\(\\mathbf{0}\\)</li> <li>Hloubka podstromu \\(T(x)\\) se ale nezm\u011bnila, tak\u017ee propagov\u00e1n\u00ed informace zastav\u00edme.</li> </ul> <p>AVLInsert p\u0159\u00edpad 1</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-2-vrchol-x-mel-znamenko-0","title":"P\u0159\u00edpad 2 - vrchol x m\u011bl znam\u00e9nko 0","text":"<ul> <li>Znam\u00e9nko \\(x\\) se zm\u011bn\u00ed na \\(\\mathbf{-1}\\).</li> <li>Hloubka podstromu \\(T(x)\\) se zv\u011bt\u0161ila o jedna, tak\u017ee mus\u00edme pokra\u010dovat v propagov\u00e1n\u00ed</li> </ul> <p>AVLInsert p\u0159\u00edpad 2</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-3-vrchol-x-mel-znamenko-1","title":"P\u0159\u00edpad 3 - vrchol x m\u011bl znam\u00e9nko -1","text":"<p>tedy te\u010f z\u00edsk\u00e1 \\(\\delta(x) = \\mathbf{-2}\\), je t\u0159eba vyva\u017eovat</p> <ul> <li>Ozna\u010dme \\(y\\) vrchol, z n\u011bj\u017e p\u0159i\u0161la informace o prohlouben\u00ed, \u010dili lev\u00e9ho syna vrcholu \\(x\\)</li> <li>Rozebereme op\u011bt t\u0159i p\u0159\u00edpady podle znam\u00e9nka vrcholu \\(y\\)</li> </ul> <p></p> <p>AVLInsert p\u0159\u00edpad 3 (obecn\u011b)</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-3a-vrchol-y-ma-znamenko-1","title":"P\u0159\u00edpad 3a - vrchol y m\u00e1 znam\u00e9nko -1","text":"<ol> <li>Ozna\u010d\u00edme-li \\(h\\) hloubku podstromu \\(C\\), podstrom \\(T(y)\\) m\u00e1 hloubku \\(h + 2\\), tak\u017ee podstrom \\(A\\) m\u00e1 hloubku \\(h + 1\\) a podstrom \\(B\\) hloubku \\(h\\).</li> <li>Provedeme jednoduchou rotaci \\(R\\) hrany \\(\\{x, y\\}\\)</li> <li>T\u00edm z\u00edsk\u00e1 vrchol \\(x\\) znam\u00e9nko \\(\\mathbf{0}\\), podstrom \\(T(x)\\) hloubku \\(h + 1\\), vrchol \\(y\\) znam\u00e9nko \\(\\mathbf{0}\\) a podstrom \\(T(y)\\) hloubku \\(h + 2\\)</li> <li>Jeliko\u017e p\u0159ed zapo\u010det\u00edm operace AVLInsert m\u011bl podstrom \\(T(x)\\) hloubku \\(h + 2\\), z pohledu vy\u0161\u0161\u00edch pater se nic nezm\u011bnilo. 5</li> <li>Propagov\u00e1n\u00ed (\u010derven\u00e1 \u0161ipka) tedy zastav\u00edme</li> </ol> <p>AVLInsert p\u0159\u00edpad 3a</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-3b-vrchol-y-ma-znamenko-1","title":"P\u0159\u00edpad 3b - vrchol y m\u00e1 znam\u00e9nko +1","text":"<ol> <li>Ozna\u010d\u00edme \\(z\\) prav\u00e9ho syna vrcholu \\(y\\) (mus\u00ed existovat).</li> <li>Ozna\u010d\u00edme jednotliv\u00e9 podstromy tak jako na obr\u00e1zku a spo\u010d\u00edt\u00e1me jejich hloubky.</li> <li>Referen\u010dn\u00ed hloubku \\(h\\) zvol\u00edme podle podstromu \\(D\\)</li> <li>Hloubky \\(h\u2212\\) znamenaj\u00ed bu\u010f \\(h\\) nebo \\(h \u2212 1\\)</li> <li>Provedeme dvojitou LR rotaci, kter\u00e1 celou konfiguraci p\u0159eko\u0159en\u00ed za vrchol \\(z\\)</li> <li>Vrchol \\(x\\) bude m\u00edt znam\u00e9nko bu\u010f \\(\\mathbf{0}\\) nebo \\(\\mathbf{+1}\\), vrchol \\(y\\) bu\u010f \\(\\mathbf{-1}\\) nebo \\(\\mathbf{0}\\), ka\u017edop\u00e1dn\u011b oba podstromy \\(T(x)\\) a \\(T(y)\\) z\u00edskaj\u00ed hloubku \\(h + 1\\)</li> <li>Proto vrchol \\(z\\) z\u00edsk\u00e1 znam\u00e9nko \\(\\mathbf{0}\\)</li> <li>P\u0159ed zapo\u010det\u00edm AVLInsertu \u010dinila hloubka cel\u00e9 konfigurace \\(h + 2\\), nyn\u00ed je tak\u00e9 \\(h + 2\\), tak\u017ee propagov\u00e1n\u00ed zastav\u00edme</li> </ol> <p>AVLInsert p\u0159\u00edpad 3b</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-3c-vrchol-y-ma-znamenko-0","title":"P\u0159\u00edpad 3c - vrchol y m\u00e1 znam\u00e9nko 0","text":"<ul> <li>Tento p\u0159\u00edpad nem\u016f\u017ee nikdy nastat, nebo\u0165 z vrcholu se znam\u00e9nkem \\(\\mathbf{0}\\) se informace o prohlouben\u00ed v \u017e\u00e1dn\u00e9m z p\u0159edchoz\u00edch p\u0159\u00edpad\u016f ne\u0161\u00ed\u0159\u00ed   a nov\u011b p\u0159idan\u00fd list m\u00e1 sice znam\u00e9nko \\(\\mathbf{0}\\), ale jeho otec nem\u016f\u017ee m\u00edt nikdy \\(\\mathbf{-1}\\)</li> <li>\u010cili zdola z vrcholu se znam\u00e9nkem \\(\\mathbf{0}\\) nem\u016f\u017ee informace o prohlouben\u00ed p\u0159ij\u00edt do vrcholu se znam\u00e9nkem \\(\\mathbf{-1}\\)</li> </ul>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#avldelete","title":"AVLDelete","text":""},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#idea_1","title":"Idea","text":"<p>Obdobn\u011b jako AVLInsert.</p> <ol> <li>Vrchol sma\u017eeme podle BVSDelete a po cest\u011b zp\u011bt do ko\u0159ene propagujeme informaci o sn\u00ed\u017een\u00ed hloubky podstromu.</li> <li>Poka\u017ed\u00e9 ma\u017eeme list nebo vrchol s jedin\u00fdm synem, tak\u017ee sta\u010d\u00ed propagovat od m\u00edsta smazan\u00e9ho vrcholu nahoru.</li> </ol>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#oprava-hloubkoveho-vyvazeni_1","title":"Oprava hloubkov\u00e9ho vyv\u00e1\u017een\u00ed","text":"<p>Pop\u00ed\u0161eme propagaci pro jeden vrchol.</p> <ol> <li>Nech\u0165 do vrcholu \\(x\\) p\u0159i\u0161la ze syna informace o sn\u00ed\u017een\u00ed hloubky podstromu.</li> <li> <p>Uk\u00e1\u017eeme op\u011bt pro p\u0159\u00edpad, kdy p\u0159i\u0161la z lev\u00e9ho syna.</p> <ul> <li>P\u0159\u00edpad, kdy p\u0159i\u0161la z prav\u00e9ho syna se \u0159e\u0161\u00ed obdobn\u011b, jen se vym\u011bn\u00ed v\u00fdznam \\(\\mathbf{+1}\\) a \\(\\mathbf{-1}\\), lev\u00e9ho a prav\u00e9ho podstromu a sm\u011br rotac\u00ed.</li> <li>Rozli\u0161\u00edme op\u011bt t\u0159i p\u0159\u00edpady podle znam\u00e9nka vrcholu \\(x\\).</li> </ul> </li> </ol>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-1-vrchol-x-ma-znamenko-1","title":"P\u0159\u00edpad 1 - vrchol x m\u00e1 znam\u00e9nko -1","text":"<ul> <li>Hloubka lev\u00e9ho podstromu se pr\u00e1v\u011b vyrovnala s hloubkou prav\u00e9ho, znam\u00e9nko vrcholu \\(x\\) se m\u011bn\u00ed na \\(\\mathbf{0}\\)</li> <li>Hloubka podstromu \\(T(x)\\) se sn\u00ed\u017eila, tak\u017ee pokra\u010dujeme v propagov\u00e1n\u00ed</li> </ul> <p>AVLDelete p\u0159\u00edpad 1</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-2-vrchol-x-ma-znamenko-0","title":"P\u0159\u00edpad 2 - vrchol x m\u00e1 znam\u00e9nko 0","text":"<ul> <li>Znam\u00e9nko \\(x\\) se zm\u011bn\u00ed na \\(\\mathbf{+1}\\)</li> <li>Hloubka podstromu \\(T(x)\\) se nezm\u011bnila, tak\u017ee propagov\u00e1n\u00ed zastav\u00edme</li> </ul> <p>AVLDelete p\u0159\u00edpad 2</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-3-vrchol-x-ma-znamenko-1","title":"P\u0159\u00edpad 3 - vrchol x m\u00e1 znam\u00e9nko +1","text":"<ul> <li>Tehdy se jeho znam\u00e9nko zm\u011bn\u00ed na \\(\\mathbf{+2}\\) a mus\u00edme vyva\u017eovat.</li> <li>Rozli\u0161\u00edme t\u0159i p\u0159\u00edpady podle znam\u00e9nka prav\u00e9ho syna \\(y\\) vrcholu \\(x\\).</li> </ul> <p>AVLDelete p\u0159\u00edpad 3 (obecn\u011b)</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-3a-vrchol-y-ma-take-znamenko-1","title":"P\u0159\u00edpad 3a - vrchol y m\u00e1 tak\u00e9 znam\u00e9nko +1","text":"<ol> <li>Ozna\u010d\u00edme-li \\(h\\) hloubku podstromu \\(A\\), bude m\u00edt \\(T(y)\\) hloubku \\(h + 2\\), tak\u017ee \\(C\\) hloubku \\(h + 1\\) a \\(B\\) hloubku \\(h\\)</li> <li>Provedeme jednoduchou rotaci L hrany \\(\\{x, y\\}\\)</li> <li>T\u00edm vrchol \\(x\\) z\u00edsk\u00e1 znam\u00e9nko \\(\\mathbf{0}\\), podstrom \\(T(x)\\) hloubku \\(h + 1\\), tak\u017ee vrchol y dostane tak\u00e9 znam\u00e9nko \\(\\mathbf{0}\\)</li> <li>P\u0159ed zapo\u010det\u00edm AVLDelete m\u011bl podstrom \\(T(x)\\) hloubku \\(h + 3\\)     nyn\u00ed m\u00e1 \\(T(y)\\) hloubku \\(h + 2\\), tak\u017ee z pohledu vy\u0161\u0161\u00edch hladin do\u0161lo ke sn\u00ed\u017een\u00ed hloubky.</li> <li>Proto pokra\u010dujeme v propagov\u00e1n\u00ed (\u010derven\u00e1 \u0161ipka).</li> </ol> <p>AVLDelete p\u0159\u00edpad 3a</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-3b-vrchol-y-ma-znamenko-0","title":"P\u0159\u00edpad 3b - vrchol y m\u00e1 znam\u00e9nko 0","text":"<ol> <li>Nech\u0165 \\(h\\) je hloubka podstromu \\(A\\). Pak \\(T(y)\\) m\u00e1 hloubku \\(h + 2\\) a \\(B\\) i \\(C\\) hloubku \\(h + 1\\).</li> <li>Provedeme jednoduchou rotaci L hrany \\(\\{x, y\\}\\)</li> <li>Vrchol \\(x\\) z\u00edsk\u00e1v\u00e1 znam\u00e9nko \\(\\mathbf{+1}\\), podstrom \\(T(x)\\) hloubku \\(h + 2\\), tak\u017ee vrchol \\(y\\) obdr\u017e\u00ed znam\u00e9nko \\(\\mathbf{-1}\\)</li> <li>Hloubka podstromu \\(T(x)\\) p\u0159ed za\u010d\u00e1tkem AVLDelete \u010dinila \\(h + 3\\)$, nyn\u00ed m\u00e1 podstrom \\(T(y)\\) hloubku tak\u00e9 \\(h + 3\\), a propagov\u00e1n\u00ed zastav\u00edme</li> </ol> <p>AVLDelete p\u0159\u00edpad 3b</p>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#pripad-3c-vrchol-y-ma-znamenko-1","title":"P\u0159\u00edpad 3c - vrchol y m\u00e1 znam\u00e9nko -1","text":"<ol> <li>Ozna\u010d\u00edme \\(z\\) lev\u00e9ho syna vrcholu \\(y\\)</li> <li>Ozna\u010d\u00edme podstromy podle obr\u00e1zku a spo\u010d\u00edt\u00e1me jejich hloubky.<ul> <li>Referen\u010dn\u00ed hloubku \\(h\\) zvol\u00edme op\u011bt podle \\(A\\)</li> <li>Hloubky \\(h\u2212\\) znamenaj\u00ed bu\u010f \\(h\\) nebo \\(h \u2212 1\\)</li> </ul> </li> <li>Provedeme dvojitou RL rotaci, kter\u00e1 celou konfiguraci p\u0159eko\u0159en\u00ed za vrchol \\(z\\)</li> <li>P\u0159epo\u010d\u00edt\u00e1me hloubky a znam\u00e9nka.</li> <li>Vrchol \\(y\\) bude m\u00edt znam\u00e9nko bu\u010f \\(\\mathbf{0}\\) nebo \\(\\mathbf{+1}\\), \\(x\\) bu\u010f \\(\\mathbf{-1}\\) nebo \\(\\mathbf{0}\\).<ul> <li>Podstromy \\(T(y)\\) a \\(T(x)\\) budou ka\u017edop\u00e1dn\u011b hlubok\u00e9 \\(h + 1\\)</li> <li>Proto vrchol \\(z\\) obdr\u017e\u00ed znam\u00e9nko \\(\\mathbf{0}\\)</li> </ul> </li> <li>P\u016fvodn\u00ed hloubka podstromu \\(T(x)\\) p\u0159ed za\u010d\u00e1tkem AVLDelete \u010dinila \\(h + 3\\), nyn\u00ed hloubka \\(T (z)\\) \u010din\u00ed \\(h + 2\\)</li> <li>pokra\u010dujeme v propagov\u00e1n\u00ed (\u010derven\u00e1 \u0161ipka).</li> </ol> <p>AVLDelete p\u0159\u00edpad 3c</p> <p></p> <p>V\u011bta 6.3 (o slo\u017eitosti operac\u00ed AVLInsert a AVLDelete)</p> D\u016fkaz V\u011bty 6.3 <ol> <li>Hloubka AVL stromu je v\u017edy \\(\\Theta(log n)\\)</li> <li>P\u016fvodn\u00ed implementace operac\u00ed BVSFind, BVSInsert a BVSDelete tedy pracuj\u00ed v logaritmick\u00e9m \u010dase.</li> <li>P\u0159i vyva\u017eov\u00e1n\u00ed se operace v\u017edy vrac\u00ed po cest\u011b do ko\u0159ene a v ka\u017ed\u00e9m vrcholu provede \\(\\Theta(1)\\) operac\u00ed, tak\u017ee celkov\u011b tak\u00e9 trv\u00e1 \\(\\Theta(log n)\\)</li> </ol>"},{"location":"06_BVS_a_vyva%C5%BEov%C3%A1n%C3%AD/6.5_AVL_operace/#theorem-6.3","title":"V\u011bta o slo\u017eitosti operac\u00ed AVLInsert a AVLDelete","text":"<p>AVLInsert a AVLDelete trvaj\u00ed \\(O(log n)\\)</p>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.1_Slovn%C3%ADky_a_He%C5%A1ovac%C3%AD_tabulky/","title":"7.1 Slovn\u00edky a He\u0161ovac\u00ed tabulky","text":""},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.1_Slovn%C3%ADky_a_He%C5%A1ovac%C3%AD_tabulky/#slovniky","title":"Slovn\u00edky","text":"<p>Nejjednodu\u0161\u0161\u00ed datovou strukturou pro pr\u00e1ci s dynamick\u00fdmi mno\u017einami je slovn\u00edk (tabulka, mapa, asociativn\u00ed pole).</p> <p></p> <p>Definice 7.1 (Slovn\u00edk)</p> <ul> <li>Prvky se tedy vyhled\u00e1vaj\u00ed a ukl\u00e1daj\u00ed podle sv\u00fdch kl\u00ed\u010d\u016f.</li> <li>Kl\u00ed\u010de jsou unik\u00e1tn\u00ed, t.j., v dan\u00e9m okam\u017eiku se vyskytuje nejv\u00fd\u0161e jeden prvek s dan\u00fdm kl\u00ed\u010dem </li> <li>Mno\u017einu v\u0161ech mo\u017en\u00fdch kl\u00ed\u010d\u016f, kter\u00e9 se mohou ve slovn\u00edku vyskytnout, nazveme univerzum \\(\\mathcal{U}\\).</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.1_Slovn%C3%ADky_a_He%C5%A1ovac%C3%AD_tabulky/#def-7.1","title":"Slovn\u00edk","text":"<ul> <li> <p>Prvky slovn\u00edku jsou stejn\u011b jako v p\u0159edchoz\u00edch p\u0159edn\u00e1\u0161k\u00e1ch   dvojice (kl\u00ed\u010d,hodnota). Kl\u00ed\u010d prvku x zna\u010d\u00edme zase k(x).</p> </li> <li> <p>Slovn\u00edk je datov\u00e1 struktura, kter\u00e1 umo\u017e\u0148uje reprezentovat   dynamickou podmno\u017einu prvk\u016f s kl\u00ed\u010di \\(K \\subseteq \\mathcal{U}\\), kde \\(|K| \\ll |\\mathcal{U}|\\),   a efektivn\u011b podporovat operace</p> <ul> <li>Find(\\(k\\)): zjisti, zda prvek \\(k \\in K\\) (p\u0159\u00edp. vra\u0165 hodnotu prvku).</li> <li>Insert(\\(x\\)): pokud \\(k(x) \\notin K\\), vlo\u017e \\(x\\) do slovn\u00edku.</li> <li>Delete(\\(x\\)): pokud \\(k(x) \\in K\\), vyma\u017e \\(x\\) ze slovn\u00edku.</li> </ul> </li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.1_Slovn%C3%ADky_a_He%C5%A1ovac%C3%AD_tabulky/#implementace-slovniku","title":"Implementace slovn\u00edk\u016f","text":"<ul> <li>Pro men\u0161\u00ed rozsahy univerza \\(\\mathcal{U}\\) lze pou\u017e\u00edt nap\u0159\u00edklad bitov\u00e9 pole.</li> <li>Potom \u010dasov\u00e1 slo\u017eitost operac\u00ed bude zjevn\u011b \\(O(1)\\).</li> <li>Nicm\u00e9n\u011b pam\u011b\u0165ov\u00e9 n\u00e1roky budou \\(\\Theta(|\\mathcal{U}|)\\).</li> <li>V praxi ale b\u00fdv\u00e1 velikost univerza \\(|\\mathcal{U}|\\) obrovsk\u00e9 \u010d\u00edslo.</li> <li>Podobn\u011b tabulka s p\u0159\u00edm\u00fdm adresov\u00e1n\u00edm podle kl\u00ed\u010d\u016f.</li> <li>Klasick\u00e9 slovn\u00edky (p\u0159ekladov\u00e9, v\u00fdkladov\u00e9) pou\u017e\u00edvaj\u00ed (abecedn\u011b) se\u0159azen\u00e1 pole: hled\u00e1n\u00ed je logaritmick\u00e9, vkl\u00e1d\u00e1n\u00ed \u010di maz\u00e1n\u00ed je line\u00e1rn\u00ed.</li> <li>V t\u00e9to kapitole se budeme v\u011bnovat he\u0161ovac\u00edm tabulk\u00e1m (hash tables, alternativn\u011b se jim \u0159\u00edk\u00e1 rozptylovac\u00ed tabulky).</li> <li>C\u00edlem he\u0161ov\u00e1n\u00ed je skloubit n\u00edzk\u00e9 pam\u011b\u0165ov\u00e9 n\u00e1roky operac\u00ed, tzn. \\(O(|K|)\\), a p\u0159itom zachovat konstantn\u00ed slo\u017eitost operac\u00ed, i kdy\u017e pouze v pr\u016fm\u011brn\u00e9m p\u0159\u00edpad\u011b.</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.1_Slovn%C3%ADky_a_He%C5%A1ovac%C3%AD_tabulky/#hesovaci-tabulky","title":"He\u0161ovac\u00ed tabulky","text":"<ul> <li>Pro n\u011bjak\u00e9 univerzum kl\u00ed\u010d\u016f \\(\\mathcal{U}\\), zvolme kone\u010dn\u00e9 pole p\u0159ihr\u00e1dek \\(P = \\{0,...,m \u2212 1\\}\\) (he\u0161ovac\u00ed tabulku) a he\u0161ovac\u00ed funkci \\(h: \\mathcal{U} \\to P\\), kter\u00e1 ka\u017ed\u00e9mu kl\u00ed\u010di univerza p\u0159id\u011bl\u00ed jednu p\u0159ihr\u00e1dku.</li> <li>Chceme-li ulo\u017eit mno\u017einu prvk\u016f s kl\u00ed\u010di \\(K \\subseteq \\mathcal{U}\\), rozm\u00edst\u00edme jej\u00ed prvky do p\u0159ihr\u00e1dek: prvek s kl\u00ed\u010dem \\(k \\in K\\) um\u00edst\u00edme do p\u0159ihr\u00e1dky \\(h(k)\\).</li> <li>Budeme-li hledat n\u011bjak\u00fd prvek s kl\u00ed\u010dem \\(k \\in \\mathcal{U}\\), v\u00edme, \u017ee nem\u016f\u017ee b\u00fdt jinde ne\u017e v p\u0159ihr\u00e1dce \\(h(k)\\).</li> <li>D\u00edky pom\u011bru \\(m\\) a \\(|U|\\ (m \\ll |\\mathcal{U}|)\\) se bude st\u00e1vat, \u017ee n\u011bkolik prvk\u016f padne do stejn\u00e9 p\u0159ihr\u00e1dky.</li> <li>Tomu se \u0159\u00edk\u00e1 kolize</li> <li>C\u00edlem je volit \\(m\\) a \\(h\\) tak, aby se po\u010det koliz\u00ed minimalizoval.</li> <li>To, jak kolize \u0159e\u0161it, vysv\u011btl\u00edme pozd\u011bji.</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.1_Slovn%C3%ADky_a_He%C5%A1ovac%C3%AD_tabulky/#priklad-hesovaci-tabulky","title":"P\u0159\u00edklad he\u0161ovac\u00ed tabulky","text":"<ul> <li>Uva\u017eujme univerzum v\u0161ech cel\u00fdch \u010d\u00edsel, he\u0161ovac\u00ed tabulku s \\(m = 10\\) p\u0159ihr\u00e1dkami a he\u0161ovac\u00ed funkci \\(h(k) = k mod 10\\).</li> <li>Celo\u010d\u00edseln\u00e9 kl\u00ed\u010de budeme tedy rozd\u011blovat do p\u0159ihr\u00e1dek podle posledn\u00ed \u010d\u00edslice.</li> <li>P\u0159edpokl\u00e1dejme, \u017ee jsme do tabulky vlo\u017eili letopo\u010dty 1212, 935, 1948, 1918, 1968, 1989</li> </ul> <ul> <li>Hled\u00e1me-li rok 2015, v\u00edme, \u017ee se mus\u00ed nach\u00e1zet v p\u0159ihr\u00e1dce 5. Tam je ov\u0161em pouze 935, tak\u017ee hned odpov\u00edme zam\u00edtav\u011b.</li> <li>Hled\u00e1n\u00ed roku 2017 je je\u0161t\u011b rychlej\u0161\u00ed: p\u0159ihr\u00e1dka 7 je pr\u00e1zdn\u00e1.</li> <li>Hled\u00e1me-li rok 1618, mus\u00edme ho porovnat s 3 prvky.</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.2_He%C5%A1ovac%C3%AD_funkce/","title":"7.2 He\u0161ovac\u00ed funkce","text":""},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.2_He%C5%A1ovac%C3%AD_funkce/#idealni-a-dobre-fungujici-hesovaci-funkce","title":"Ide\u00e1ln\u00ed a dob\u0159e funguj\u00edc\u00ed he\u0161ovac\u00ed funkce","text":"<ul> <li>Slo\u017eitost operac\u00ed Find\\((k)\\) a Insert\\((x)\\) zjevn\u011b z\u00e1vis\u00ed na slo\u017eitosti v\u00fdpo\u010dtu he\u0161ovac\u00ed funkce a na tom, jak rozm\u00eds\u0165uje ukl\u00e1dan\u00e9 prvky do p\u0159ihr\u00e1dek.</li> <li>Ide\u00e1ln\u00ed he\u0161ovac\u00ed funkce \\(h: U \\to P\\) vypo\u010dte \u010d\u00edslo p\u0159ihr\u00e1dky v konstantn\u00edm \u010dase a zadanou \\(n\\)-prvkovou mno\u017einu vstupn\u00edch kl\u00ed\u010d\u016f \\(K\\) rozprost\u0159e mezi \\(m\\) p\u0159ihr\u00e1dek \\(P\\) dokonale rovnom\u011brn\u011b, tzn. v\u0161echny p\u0159ihr\u00e1dky budou m\u00edt nejv\u00fd\u0161e \\(\\lceil n/m \\rceil\\) prvk\u016f.</li> <li>Ide\u00e1ln\u00ed he\u0161ovac\u00ed funkce je obvykle nemo\u017en\u00e9 sestrojit, proto se pou\u017e\u00edvaj\u00ed funkce, kter\u00e9 se chovaj\u00ed \u201eprakticky n\u00e1hodn\u011b\u201c.</li> <li>Uk\u00e1\u017eeme n\u011bkolik p\u0159\u00edklad\u016f he\u0161ovac\u00edch funkc\u00ed, pro kter\u00e9 bylo experiment\u00e1ln\u011b ov\u011b\u0159eno, \u017ee dob\u0159e he\u0161uj\u00ed nejr\u016fzn\u011bj\u0161\u00ed typy dat.</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.2_He%C5%A1ovac%C3%AD_funkce/#priklady-dobre-fungujicich-hesovacich-funkci","title":"P\u0159\u00edklady dob\u0159e funguj\u00edc\u00edch he\u0161ovac\u00edch funkc\u00ed","text":"<p>1. Line\u00e1rn\u00ed kongruence</p> <p>Line\u00e1rn\u00ed kongruence: \\(k \\mapsto ak\\ mod\\ m\\).</p> <ul> <li>Zde \\(m\\) je typicky prvo\u010d\u00edslo a \\(a\\) je n\u011bjak\u00e1 dostate\u010dn\u011b velk\u00e1 konstanta nesoud\u011bln\u00e1 s \\(m\\).</li> <li>\u010casto se a nastavuje bl\u00edzko cel\u00e9 \u010d\u00e1sti \\(0.618m\\).</li> </ul> <p>2. Vy\u0161\u0161\u00ed bity sou\u010dinu</p> <p>Vy\u0161\u0161\u00ed bity sou\u010dinu: \\(k \\mapsto \\lfloor (ak\\ mod\\ 2^w)/2^{w\u2212\u2113} \\rfloor\\).</p> <ul> <li>Pokud he\u0161ujeme \\(w\\)-bitov\u00e9 kl\u00ed\u010de do \\(m = 2^l\\) p\u0159ihr\u00e1dek, vybereme \\(w\\)-bitovou lichou konstantu \\(a\\) (nesoud\u011blnou s \\(2^w\\)).</li> <li>Pak pro ka\u017ed\u00e9 \\(k\\) spo\u010d\u00edt\u00e1me \\(ak\\), o\u0159\u00edzneme ho na \\(w\\) bit\u016f a z nich vezmeme nejvy\u0161\u0161\u00edch \\(l\\).</li> <li>Vzhledem k tomu, \u017ee p\u0159ete\u010den\u00ed ve v\u011bt\u0161in\u011b programovac\u00edch jazyk\u016f automaticky o\u0159ez\u00e1v\u00e1 v\u00fdsledek, sta\u010d\u00ed k v\u00fdpo\u010dtu he\u0161ovac\u00ed funkce jedno n\u00e1soben\u00ed a bitov\u00fd posun.</li> </ul> <p>3. Skal\u00e1rn\u00ed sou\u010din</p> <p>Skal\u00e1rn\u00ed sou\u010din: \\(k_0,...,k_{d-1} \\mapsto (\\sum_{i=0}^{d-1} a_ik_i)\\ mod\\ m\\)</p> <ul> <li>Posloupnost kl\u00ed\u010d\u016f zahe\u0161ujeme tak, \u017ee zahe\u0161ujeme ka\u017ed\u00fd kl\u00ed\u010d zvl\u00e1\u0161\u0165 a v\u00fdsledky se\u010dteme.</li> <li>Pokud \\(i\\)-t\u00fd kl\u00ed\u010d \\(k_i\\) zahe\u0161ujeme line\u00e1rn\u00ed kongruenc\u00ed \\(k_i \\to  a_ik_i\\ mod\\ m\\), je he\u0161 cel\u00e9 posloupnosti jej\u00ed skal\u00e1rn\u00ed sou\u010din s vektorem konstant \\((a_0, a_1, . . . , a_{d\u22121})\\) modulo \\(m\\)</li> <li>Podobn\u011b lze he\u0161 po\u010d\u00edtat v dvojkov\u00e9 soustav\u011b pomoc\u00ed operace XOR m\u00edsto sou\u010dtu.</li> </ul> <p>4. Polynom</p> <p>Polynom: \\(k_0,...,k_{d-1} \\mapsto (\\sum_{i=0}^{d-1} a^ik_i)\\ mod\\ m\\)</p> <ul> <li>Zvol\u00edme jednu konstantu \\(a\\) a po\u010d\u00edt\u00e1me skal\u00e1rn\u00ed sou\u010din zadan\u00e9 posloupnosti s vektorem mocnin \\((a^0,a^1,...,a^{d\u22121})\\) a op\u011bt modulo \\(m\\).</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.2_He%C5%A1ovac%C3%AD_funkce/#idealni-hesovani","title":"Ide\u00e1ln\u00ed he\u0161ov\u00e1n\u00ed","text":"<ul> <li>P\u0159esto\u017ee jsou vlastnosti he\u0161ovac\u00edch funkc\u00ed \u010dasto postaveny na experiment\u00e1ln\u00edch v\u00fdsledc\u00edch, pro n\u011bkter\u00e9 p\u0159\u00edpady he\u0161ov\u00e1n\u00ed lze prov\u00e9st i exaktn\u00ed anal\u00fdzu.</li> <li> <p>Po\u017eadovan\u00e9 vlastnosti he\u0161ovac\u00ed funkce:</p> </li> <li> <p>V\u00fdpo\u010det \\(h(k)\\) je rychl\u00fd (\\(O(1)\\)) a funkce \\(h\\) neukl\u00e1d\u00e1 \u017e\u00e1dn\u00e1 data   do pam\u011bti. Speci\u00e1ln\u011b je tedy jej\u00ed v\u00fdpo\u010det nez\u00e1visl\u00fd na historii p\u0159edchoz\u00edch vol\u00e1n\u00ed</p> </li> <li>He\u0161ovac\u00ed funkce \\(h\\) rozd\u011bluje univerzum \\(\\mathcal{U}\\) do p\u0159ihr\u00e1dek rovnom\u011brn\u011b, nap\u0159\u00edklad takto:</li> </ul> \\[\\forall i \\neq j \\in \\{0,...,m-1\\} : |h^{-1}(i)| = |h^{-1}(j)| \\pm 1\\]"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.2_He%C5%A1ovac%C3%AD_funkce/#casova-slozitost-idealniho-hesovani","title":"\u010casov\u00e1 slo\u017eitost ide\u00e1ln\u00edho he\u0161ov\u00e1n\u00ed","text":"<p>Fakt (neform\u00e1ln\u00ed)</p> <p>Uva\u017eujme he\u0161ovac\u00ed tabulku velikosti \\(m\\) s \\(n\\) prvky a s he\u0161ovac\u00ed funkc\u00ed \\(h\\) a nech\u0165 jsou spln\u011bny p\u0159edpoklady 1) a 2). Nech\u0165 nav\u00edc plat\u00ed, \u017ee vstupn\u00ed data jsou z univerza \\(\\mathcal{U}\\) vyb\u00edr\u00e1na nez\u00e1visle rovnom\u011brn\u011b n\u00e1hodn\u011b. Potom</p> <ol> <li>pr\u016fm\u011br po\u010dtu prvk\u016f v p\u0159ihr\u00e1dce je \\(n/m\\)</li> <li>po\u010det prvk\u016f v p\u0159ihr\u00e1dce je \\(O(n/m)\\) pro skoro v\u0161echny p\u0159ihr\u00e1dky</li> <li>pr\u016fm\u011brn\u00fd po\u010det operac\u00ed vykonan\u00fdch p\u0159i hled\u00e1n\u00ed, vkl\u00e1d\u00e1n\u00ed imaz\u00e1n\u00ed je \\(O(n/m)\\).</li> </ol>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.2_He%C5%A1ovac%C3%AD_funkce/#nafukovaci-hesovaci-tabulka-a-prehesovani","title":"Nafukovac\u00ed he\u0161ovac\u00ed tabulka a p\u0159ehe\u0161ov\u00e1n\u00ed","text":"<ul> <li>P\u0159edpokl\u00e1dejme, \u017ee po\u010det zahe\u0161ovan\u00fdch prvk\u016f \\(n\\) p\u0159edem nezn\u00e1me a nedok\u00e1\u017eeme jej rozumn\u011b odhadnout.</li> <li>Jak m\u00e1me zvolit po\u010det p\u0159ihr\u00e1dek \\(m\\) he\u0161ovac\u00ed tabulky, pokud budeme cht\u00edt zajistit, aby faktor napln\u011bn\u00ed he\u0161ovac\u00ed tabulky \\(\u03b1 = n/m\\) nep\u0159ekro\u010dil zadanou konstantu \\(Z\\)?</li> <li> <p>Pom\u016f\u017ee n\u00e1m technika amortizovan\u00e9ho nafukovac\u00edho pole.</p> <ul> <li>Na po\u010d\u00e1tku zalo\u017e\u00edme pr\u00e1zdnou he\u0161ovac\u00ed tabulku s n\u011bjak\u00fdm po\u010d\u00e1te\u010dn\u00edm po\u010dtem p\u0159ihr\u00e1dek \\(m = m_0\\).</li> <li>Po vlo\u017een\u00ed prvku zkontrolujeme \\(\u03b1 = n/m\\).</li> <li>Pokud \\(\u03b1 \\gt Z\\), je he\u0161ovac\u00ed tabulka p\u0159epln\u011bn\u00e1. Pak zdvojn\u00e1sob\u00edme \\(m\\), zvol\u00edme novou he\u0161ovac\u00ed funkci a v\u0161echny  prvky p\u0159ehe\u0161ujeme: pro ka\u017ed\u00fd prvek ze star\u00e9 tabulky spo\u010dteme novou he\u0161ovac\u00ed funkci a vlo\u017e\u00edme do nov\u00e9 tabulky.</li> </ul> </li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.3_%C5%98e%C5%A1en%C3%AD_koliz%C3%AD/","title":"7.3 \u0158e\u0161en\u00ed koliz\u00ed","text":"<p>Jeliko\u017e \\(m \\ll |U|\\), \u017e\u00e1dn\u00e1 he\u0161ovac\u00ed funkce se nem\u016f\u017ee vyhnout koliz\u00edm, kdy je n\u011bkolik prvk\u016f zahe\u0161ov\u00e1no do t\u00e9\u017ee p\u0159ihr\u00e1dky.</p> <p>Existuj\u00ed dv\u011b principi\u00e1ln\u011b odli\u0161n\u00e9 metody \u0159e\u0161en\u00ed koliz\u00ed:</p> <ol> <li> <p>\u0158et\u011bzen\u00ed (Chaining) = Otev\u0159en\u00e9 he\u0161ov\u00e1n\u00ed (Open hashing). Otev\u0159en\u00e9 he\u0161ov\u00e1n\u00ed proto, \u017ee ukl\u00e1dan\u00e9 prvky nejsou ukl\u00e1d\u00e1ny do he\u0161ovac\u00ed tabulky, ale do \u201eotev\u0159en\u00e9ho prostoru\u201c za n\u00ed, do \u0159et\u00edzk\u016f, odkazovan\u00fdch z tabulky.</p> </li> <li> <p>Otev\u0159en\u00e9 adresov\u00e1n\u00ed (Open addressing) = Uzav\u0159en\u00e9 he\u0161ov\u00e1n\u00ed (Closed hashing). Uzav\u0159en\u00e9 he\u0161ov\u00e1n\u00ed proto, \u017ee prvky  jsou ukl\u00e1d\u00e1ny do \u201euzav\u0159en\u00e9ho prostoru tabulky\u201c. Otev\u0159en\u00e9 adresov\u00e1n\u00ed proto, \u017ee \u010d\u00edslo (index) p\u0159ihr\u00e1dky tabulky, kam je  nakonec he\u0161ovan\u00fd prvek ulo\u017een, je dop\u0159edu otev\u0159en\u00fd, nebo\u0165 nen\u00ed d\u00e1n pouze he\u0161ovac\u00ed funkc\u00ed, ale i moment\u00e1ln\u00ed obsazenost\u00ed tabulky.</p> </li> </ol>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.3_%C5%98e%C5%A1en%C3%AD_koliz%C3%AD/#reseni-kolizi-retezenim","title":"\u0158e\u0161en\u00ed koliz\u00ed \u0159et\u011bzen\u00edm","text":"<ul> <li>He\u0161ovac\u00ed tabulka je pole \\(m\\) p\u0159ihr\u00e1dek, kter\u00e9 jsou bu\u010f pr\u00e1zdn\u00e9 nebo obsahuj\u00ed ukazatel na \u0159et\u00edzky (= spojov\u00e9 seznamy) ulo\u017een\u00fdch prvk\u016f.</li> <li>Jedn\u00e1 se o p\u0159\u00edmo\u010darou implementaci abstraktn\u00ed struktury he\u0161ovac\u00ed tabulky.</li> <li>Na\u0161e tabulka bude tedy implementovan\u00e1 takto:</li> </ul> <p>\u010casov\u00e1 slo\u017eitost he\u0161ov\u00e1n\u00ed s \u0159et\u00edzky</p> <ul> <li>Hled\u00e1n\u00ed, vkl\u00e1d\u00e1n\u00ed i maz\u00e1n\u00ed sest\u00e1v\u00e1 z v\u00fdpo\u010dtu he\u0161ovac\u00ed funkce a projit\u00ed \u0159et\u00edzku v p\u0159\u00edslu\u0161n\u00e9 p\u0159ihr\u00e1dce.</li> <li>V p\u0159\u00edpad\u011b ide\u00e1ln\u00ed he\u0161ovac\u00ed funkce a pokud jsou vstupn\u00ed data z univerza \\(\\mathcal{U}\\) vyb\u00edr\u00e1na nez\u00e1visle rovnom\u011brn\u011b n\u00e1hodn\u011b, budou m\u00edt (skoro) v\u0161echny \u0159et\u00edzky d\u00e9lku nejv\u00fd\u0161e \\(\\lceil n/m \\rceil\\) prvk\u016f.</li> <li>Zvol\u00edme-li nav\u00edc po\u010det p\u0159ihr\u00e1dek \\(m = \\Theta(n)\\), vyjde konstantn\u00ed d\u00e9lka \u0159et\u00edzku, a t\u00edm p\u00e1dem i \u010dasov\u00e1 slo\u017eitost operac\u00ed.</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.3_%C5%98e%C5%A1en%C3%AD_koliz%C3%AD/#otevrena-adresace-reseni-kolizi","title":"Otev\u0159en\u00e1 adresace: \u0158e\u0161en\u00ed koliz\u00ed","text":"<ul> <li>He\u0161ovac\u00ed tabulka s otev\u0159enou adresac\u00ed je pole s \\(m\\) p\u0159ihr\u00e1dkami \\(A[0],...,A[m \u2212 1]\\), jen\u017ee tentokr\u00e1t se do ka\u017ed\u00e9 p\u0159ihr\u00e1dky vejde pouze jeden prvek.</li> <li>P\u0159i pokusu o ulo\u017een\u00ed do obsazen\u00e9 p\u0159ihr\u00e1dky budeme postupn\u011b zkou\u0161et n\u00e1hradn\u00ed p\u0159ihr\u00e1dky, dokud nenajdeme pr\u00e1zdnou</li> <li>He\u0161ovac\u00ed funkce tedy ka\u017ed\u00e9mu kl\u00ed\u010di \\(k \\in \\mathcal{U}\\) p\u0159i\u0159ad\u00ed jeho vyhled\u00e1vac\u00ed posloupnost \\(h(k,0),h(k,1),...,h(k,m \u2212 1)\\), kter\u00e1 je ide\u00e1ln\u011b permutac\u00ed posloupnosti \\(\\{0,1,...,m \u2212 1\\}\\).</li> <li>Ta ur\u010duje po\u0159ad\u00ed p\u0159ihr\u00e1dek, do kter\u00fdch se budeme postupn\u011b sna\u017eit vkl\u00e1dat kl\u00ed\u010d \\(k\\).</li> <li>V ide\u00e1ln\u00edm p\u0159\u00edpad\u011b vyhled\u00e1vac\u00ed posloupnost obsahuje v\u0161echna \u010d\u00edsla p\u0159ihr\u00e1dek v dokonale n\u00e1hodn\u00e9m po\u0159ad\u00ed (v\u0161echny permutace p\u0159ihr\u00e1dek jsou stejn\u011b pravd\u011bpodobn\u00e9).</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.3_%C5%98e%C5%A1en%C3%AD_koliz%C3%AD/#find","title":"Find","text":"<p>Algoritmus 7.1 (Otev\u0159en\u00e1 adresace: Hled\u00e1n\u00ed)</p>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.3_%C5%98e%C5%A1en%C3%AD_koliz%C3%AD/#algoritmus-openfind","title":"Algoritmus OpenFind","text":"OpenFind(k)<pre><code>Pro i = 0,...,m \u2212 1:\n    j := h(k, i)\n    Pokud k(A[j]) = k: ohla\u0161 nalezen\u00ed A[j] a skon\u010di\n    Pokud je A[j] pr\u00e1zdn\u00e1: ohla\u0161 ne\u00fasp\u011bch a skon\u010di\nOhla\u0161 ne\u00fasp\u011bch\n</code></pre>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.3_%C5%98e%C5%A1en%C3%AD_koliz%C3%AD/#delete","title":"Delete","text":"<ul> <li>Maz\u00e1n\u00ed je problematick\u00e9. Pokud bychom p\u0159ihr\u00e1dku smazan\u00e9ho prvku ozna\u010dili jako pr\u00e1zdnou, m\u016f\u017eeme zp\u016fsobit, \u017ee existuj\u00edc\u00ed prvek s n\u011bjak\u00fdm jin\u00fdm kl\u00ed\u010dem \\(k'\\) nebude nalezen, proto\u017ee vyhled\u00e1vac\u00ed posloupnost, kter\u00e1 byla pou\u017eita p\u0159i vkl\u00e1d\u00e1n\u00ed \\(k'\\), bude t\u00edmto z\u00e1sahem p\u0159eru\u0161ena.</li> </ul> <ul> <li>Proto budeme mazan\u00e9 prvky pouze ozna\u010dovat za smazan\u00e9.</li> <li>Standardn\u00ed implementace ozna\u010den\u00ed smazan\u00e9ho prvku je pomoc\u00ed tzv. n\u00e1hrobku \\(\u2020\\) (\\(tombstone\\)).</li> <li>Dodefinujeme \\(k(\u2020)\\) jako libovolnou hodnotu mimo \\(\\mathcal{U}\\).</li> </ul> <p>Algoritmus 7.2 (Otev\u0159en\u00e1 adresace: Maz\u00e1n\u00ed)</p>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.3_%C5%98e%C5%A1en%C3%AD_koliz%C3%AD/#algo-7.2","title":"Algoritmus OpenDelete","text":"<p>Idea</p> <ul> <li>Prvek nahrad\u00edme \u2020.</li> <li>Operace OpenDelete je pak n\u00e1sleduj\u00edc\u00ed:</li> </ul> OpenDelete(x)<pre><code>Pro i = 0, . . . , m \u2212 1:\n    j := h(k(x), i)\n    Pokud je A[j] = x:\n        A[j] = \u2020\n        skon\u010di\n    Pokud je A[j] pr\u00e1zdn\u00e1:\n        skon\u010di\n</code></pre>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.3_%C5%98e%C5%A1en%C3%AD_koliz%C3%AD/#insert","title":"Insert","text":"<p>Algoritmus 7.3 (Otev\u0159en\u00e1 adresace: Vkl\u00e1d\u00e1n\u00ed)</p> <ul> <li>Pokud se vyhled\u00e1vac\u00ed posloupnosti nov\u011b vkl\u00e1dan\u00fdch prvk\u016f li\u0161\u00ed od vyhled\u00e1vac\u00edch posloupnost\u00ed mazan\u00fdch prvk\u016f ozna\u010dovan\u00fdch n\u00e1hrobky, po\u010det n\u00e1hrobk\u016f m\u016f\u017ee snadno p\u0159es\u00e1hnout zadanou mez (t\u0159eba m/4). Pak se obvykle struktura tabulky p\u0159ebuduje (p\u0159ehe\u0161uje).</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.3_%C5%98e%C5%A1en%C3%AD_koliz%C3%AD/#algo-7.3","title":"Algoritmus OpenInsert","text":"<p>Idea</p> <ul> <li>M\u00edsto po smazan\u00fdch prvc\u00edch m\u016f\u017eeme vyu\u017e\u00edvat p\u0159i vkl\u00e1d\u00e1n\u00ed</li> <li>Operace OpenInsert je pak n\u00e1sleduj\u00edc\u00ed:</li> </ul> OpenInsert(x)<pre><code>Pokud OpenFind(k(x)) nalezne k(x): skon\u010di\nPro i = 0,...,m \u2212 1:\n    j := h(k(x),i)\n    Pokud je A[j] pr\u00e1zdn\u00e1 nebo A[j] = \u2020:\n        A[j] := x a skon\u010di\nOhla\u0161 zapln\u011bn\u00ed he\u0161ovac\u00ed tabulky\n</code></pre>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.4_Volba_vyhled%C3%A1vac%C3%AD_posloupnosti/","title":"7.4 Volba vyhled\u00e1vac\u00ed posloupnosti","text":"<ul> <li>Jak volit vyhled\u00e1vac\u00ed posloupnosti?</li> <li>Uk\u00e1\u017eeme z\u00e1kladn\u00ed mo\u017enosti, kter\u00e9 se \u010dasto pou\u017e\u00edvaj\u00ed v praxi</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.4_Volba_vyhled%C3%A1vac%C3%AD_posloupnosti/#linearni-pridavani","title":"Line\u00e1rn\u00ed p\u0159id\u00e1v\u00e1n\u00ed","text":"<p>Line\u00e1rn\u00ed p\u0159id\u00e1v\u00e1n\u00ed (Linear Probing): Vyhled\u00e1vac\u00ed posloupnost je d\u00e1na funkc\u00ed \\(h(k,i) = (f(k) + i)\\ mod\\ m\\), kde \\(f(k)\\) je \u201eoby\u010dejn\u00e1\u201c he\u0161ovac\u00ed funkce a \\(i\\) je po\u010det ne\u00fasp\u011b\u0161n\u00fdch pokus\u016f v aktu\u00e1ln\u00ed operaci.</p> <ul> <li>Zkou\u0161\u00edme tedy jednodu\u0161e za sebou jdouc\u00ed p\u0159ihr\u00e1dky.</li> <li>V\u00fdhodou je sekven\u010dn\u00ed p\u0159\u00edstup do pam\u011bti, kter\u00fd je na dne\u0161n\u00edch po\u010d\u00edta\u010d\u00edch se skryt\u00fdmi pam\u011btmi (cache memory) rychlej\u0161\u00ed.</li> <li>Nev\u00fdhodou je to, \u017ee jakmile se vytvo\u0159\u00ed souvisl\u00e9 bloky obsazen\u00fdch p\u0159ihr\u00e1dek, dal\u0161\u00ed vkl\u00e1d\u00e1n\u00ed se do nich \u010dasto stref\u00ed a bloky d\u00e1le porostou.</li> <li>Bez d\u016fkazu uv\u00e1d\u00edme, \u017ee pro ne\u00fasp\u011b\u0161n\u00e9 hled\u00e1n\u00ed plat\u00ed odhad pr\u016fm\u011brn\u00e9ho po\u010dtu nav\u0161t\u00edven\u00fdch p\u0159ihr\u00e1dek 1/\\((1 \u2212 \u03b1)^2\\). A to pouze, je-li \\(f\\) dokonale n\u00e1hodn\u00e1.</li> <li>Nen\u00ed-li, chov\u00e1n\u00ed struktury obvykle degraduje. Lze zobecnit na line\u00e1rn\u00ed p\u0159id\u00e1v\u00e1n\u00ed s krokem, kde \\(h(k,i) = (f(k) + c \\cdot i)\\ mod\\ m\\) a \\(c \\gt 1\\) je konstanta nesoud\u011bln\u00e1 s \\(m\\).</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.4_Volba_vyhled%C3%A1vac%C3%AD_posloupnosti/#dvojite-hesovani","title":"Dvojit\u00e9 he\u0161ov\u00e1n\u00ed","text":"<p>Dvojit\u00e9 he\u0161ov\u00e1n\u00ed (Double Hashing): Vyhled\u00e1vac\u00ed posloupnost je d\u00e1na funkc\u00ed \\(h(k,i) = (f(k) + i \u00b7 g(k))\\ mod\\ m\\), kde \\(f : \\mathcal{U} \\to \\{0,...,m \u2212 1\\}\\) a \\(g : \\mathcal{U} \\to \\{1,...,m \u2212 1\\}\\) jsou dv\u011b r\u016fzn\u00e9 he\u0161ovac\u00ed funkce, \\(m\\) je prvo\u010d\u00edslo a \\(i\\) je po\u010det ne\u00fasp\u011b\u0161n\u00fdch pokus\u016f v aktu\u00e1ln\u00ed operaci</p> <ul> <li>Proto\u017ee \\(m\\) je prvo\u010d\u00edslo, je s n\u00edm \\(g(k)\\) v\u017edy nesoud\u011bln\u00e9 a vyhled\u00e1vac\u00ed posloupnost nav\u0161t\u00edv\u00ed ka\u017edou p\u0159ihr\u00e1dku pr\u00e1v\u011b jednou.</li> <li>Je zn\u00e1mo, \u017ee pro dokonale n\u00e1hodn\u00e9 funkce \\(f\\) a \\(g\\) se dvojit\u00e9 he\u0161ov\u00e1n\u00ed chov\u00e1 stejn\u011b dob\u0159e, jako p\u0159i pou\u017eit\u00ed pln\u011b n\u00e1hodn\u00fdch vyhled\u00e1vac\u00edch posloupnost\u00ed.</li> <li>Toto tvrzen\u00ed t\u00e9\u017e ponech\u00e1v\u00e1me bez d\u016fkazu.</li> </ul> <p></p> <p>V\u011bta 7.1 (O efektivit\u011b otev\u0159en\u00e9 adresace)</p> D\u016fkaz V\u011bty 7.1 <ul> <li>Nech\u0165 \\(k\\) je hledan\u00fd kl\u00ed\u010d a \\(h_1,h_2,...,h_m\\) jeho vyhled\u00e1vac\u00ed posloupnost.</li> <li>Ozna\u010dme \\(p_i\\) pravd\u011bpodobnost toho, \u017ee b\u011bhem hled\u00e1n\u00ed projdeme a zkus\u00edme alespo\u0148 \\(i\\) p\u0159ihr\u00e1dek. Tedy pravd\u011bpodobnost toho, \u017ee p\u0159ihr\u00e1dky \\(h_1,...,h_{i\u22121}\\) jsou obsazen\u00e9.</li> <li>P\u0159ihr\u00e1dku \\(h_1\\) projdeme v\u017edy, proto \\(p_1 = 1\\).</li> <li>Pravd\u011bpodobnost \\(p_2\\) je pravd\u011bpodobnost toho, \u017ee p\u0159ihr\u00e1dka \\(h_1\\) (n\u00e1hodn\u011b vybran\u00e1 z \\(m\\) mo\u017enost\u00ed) je obsazena libovoln\u00fdm kl\u00ed\u010dem z \\(n\\) mo\u017en\u00fdch.</li> <li>Proto \\(p_2 = n/m = \u03b1\\)</li> <li>Obecn\u011b \\(p_{i+1}\\) je pravd\u011bpodobnost toho, \u017ee i p\u0159ihr\u00e1dka \\(h_i\\) je obsazen\u00e1, stejn\u011b jako \\(i \u2212 1\\) p\u0159edchoz\u00edch.</li> <li>\u010cili n\u00e1hodn\u011b vybran\u00e1 p\u0159ihr\u00e1dka ze zb\u00fdvaj\u00edc\u00edch \\(m \u2212 (i \u2212 1)\\) mo\u017en\u00fdch p\u0159ihr\u00e1dek je obsazena libovoln\u00fdm kl\u00ed\u010dem ze zb\u00fdvaj\u00edc\u00edch \\(n \u2212 (i \u2212 1)\\) mo\u017en\u00fdch kl\u00ed\u010d\u016f.</li> <li>Proto \\(p_{i+1} = p_i \\cdot (n \u2212 i + 1)/(m \u2212 i + 1) \\le p_i \u00b7 n/m = p_i \\cdot \u03b1\\)</li> <li>Indukc\u00ed dostaneme \\(p_{i+1} \\le \u03b1^i\\)</li> <li>Nech\u0165 \\(S\\) = st\u0159edn\u00ed hodnota po\u010dtu nav\u0161t\u00edven\u00fdch p\u0159ihr\u00e1dek.</li> <li>Pak \\(S = \\sum_{i=1}^m i \\cdot q_i\\), kde \\(q_i\\) je pravd\u011bpodobnost, \u017ee jsme nav\u0161t\u00edvili pr\u00e1v\u011b \\(i\\) p\u0159ihr\u00e1dek. Tedy, \u017ee p\u0159ihr\u00e1dky \\(h_1,...,h_{i\u22121}\\) jsou obsazen\u00e9 a p\u0159ihr\u00e1dka \\(h_i\\) je pr\u00e1zdn\u00e1.</li> <li>Proto\u017ee \\(\\mathbb{P}[h_1,...,h_{i\u22121}\\ jsou\\ obsazen\u00e9] =\\) \\(\\mathbb{P}[h_1,...,h_{i\u22121}\\ jsou\\ obsazen\u00e9\\ a\\ h_i\\ je\\ pr\u00e1zdn\u00e1] + \\mathbb{P}[h_1,...,h_{i\u22121}\\ jsou\\ obsazen\u00e9\\ a h_i\\ je\\ obsazen\u00e1]\\), plat\u00ed \\(p_i = q_i + p_{i+1}\\) \u010dili \\(q_i = p_i - p_{i+1}\\). Proto</li> </ul> \\[S = \\sum_{i=1}^{m} i \\cdot (p_i - p_{i+1})  = \\sum_{i=1}^{m} i \\cdot p_i - \\sum_{i=1}^{m} i \\cdot p_{i+1}\\] \\[= \\sum_{i=1}^{m} i \\cdot p_i - \\sum_{i=2}^{m} (i - 1) \\cdot p_i  = \\sum_{i=1}^{m} p_i \\cdot \\big(i - (i - 1)\\big)\\] \\[= \\sum_{i=1}^{m} p_i.\\] <ul> <li>Tedy</li> </ul> \\[S = \\sum_{i=1}^{m} p_i \\leq \\sum_{i=1}^{m} \\alpha^{i-1} &lt; \\sum_{i=0}^{\\infty} \\alpha^i = \\frac{1}{1-\\alpha}\\] <ul> <li>Nebo\u0165 \u03b1 &lt; 1 a jedn\u00e1 se tedy o konvergentn\u00ed geometrickou \u0159adu</li> </ul> Pozorov\u00e1n\u00ed <ul> <li>Jeliko\u017e \\(n \\lt m\\), plat\u00ed \\(\\forall i \\ge n + 2\\); \\(p_i = 0\\) a \\(\\forall i \\ge n + 2\\); \\(q_i = 0\\).</li> <li>Tud\u00ed\u017e \\(q_{n+1} = p_{n+1}\\).</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.4_Volba_vyhled%C3%A1vac%C3%AD_posloupnosti/#theorem-7.1","title":"V\u011bta O efektivit\u011b otev\u0159en\u00e9 adresace","text":"<p>Pokud jsou vyhled\u00e1vac\u00ed posloupnosti n\u00e1hodn\u00e9 permutace, pak ne\u00fasp\u011b\u0161n\u00e9 hled\u00e1n\u00ed nahl\u00e9dne v pr\u016fm\u011bru do nejv\u00fd\u0161e 1/(1 \u2212 \\(\u03b1\\)) p\u0159ihr\u00e1dek, kde \\(\u03b1 = n/m\\), \\(n \\lt m\\), je faktor napln\u011bn\u00ed.</p>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/","title":"7.5 Pravd\u011bpodobnostn\u00ed prostor","text":""},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#zavedeni-pojmu-pravdepodobnost","title":"Zaveden\u00ed pojmu pravd\u011bpodobnost","text":"<p>Definice 7.2 (Diskr\u00e9tn\u00ed pravd\u011bpodobnostn\u00ed prostor)</p> <p></p> <p>Definice 7.3 (Jev)</p>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#def-7.2","title":"Diskr\u00e9tn\u00ed pravd\u011bpodobnostn\u00ed prostor","text":"<p>Diskr\u00e9tn\u00ed pravd\u011bpodobnostn\u00ed prostor je dvojice (\\(\\Omega\\), \\(\\mathbf{P}\\)), kde</p> <ul> <li>\\(\\Omega\\) je kone\u010dn\u00e1 nebo spo\u010detn\u011b nekone\u010dn\u00e1 mno\u017eina element\u00e1rn\u00edch jev\u016f.</li> <li>\\(\\mathbf{P} : \\Omega \\rightarrow [0, 1]\\) je funkce, kter\u00e1 element\u00e1rn\u00edm jev\u016fm p\u0159i\u0159azuje jejich pravd\u011bpodobnosti takov\u00e1, \u017ee sou\u010det pravd\u011bpodobnost\u00ed  v\u0161ech element\u00e1rn\u00edch jev\u016f je roven \\(1\\), \u010dili \\(\\sum_{\\omega \\in \\Omega}{\\mathbf{P}(\\omega) = 1}\\)</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#def-7.3","title":"Jev","text":"<ul> <li>Jev je n\u011bjak\u00e1 mno\u017eina \\(A \\subseteq \\Omega\\) element\u00e1rn\u00edch jev\u016f.</li> <li>Pravd\u011bpodobnost jevu \\(A\\) je: \\(\\sum_{\\omega \\in A}{\\mathcal{\\mathbf{P}}(\\omega)}\\)</li> </ul>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#zakladni-vlastnosti-pravdepodobnosti","title":"Z\u00e1kladn\u00ed vlastnosti pravd\u011bpodobnosti","text":"<p>Definice 7.4 (Nez\u00e1vislost jev\u016f)</p> <p></p> <p>Definice 7.5 (Opa\u010dn\u00fd jev)</p> <p>Pozorov\u00e1n\u00ed</p> <p>\\(\\text{1.}\\) Pro ka\u017ed\u00e9 dva jevy \\(A, B\\) plat\u00ed:</p> \\[ \\mathbf{P}(A \\cup B) = \\mathbf{P}(A) + \\mathbf{P}(B) \u2212 \\mathbf{P}(A \\cap B) \\] <p>\\(\\text{2.}\\) Pro ka\u017ed\u00fd jev \\(A\\) plat\u00ed:</p> \\[ \\mathbf{P}(\\overline{A}) = 1 - \\mathbf{P}(A) \\]"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#def-7.4","title":"Nez\u00e1vislost jev\u016f","text":"<p>Dva jevy \\(A, B\\) nazveme nez\u00e1visl\u00e9, pokud:</p> \\[ \\mathbf{P}(A \\cap B) = \\mathbf{P}(A) \\cdot \\mathbf{P}(B) \\]"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#def-7.5","title":"Opa\u010dn\u00fd jev","text":"<p>Jev \\(\\overline{A} = \\Omega \\setminus A\\) se naz\u00fdv\u00e1 jev opa\u010dn\u00fd k jevu \\(A\\)</p>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#nahodna-velicina","title":"N\u00e1hodn\u00e1 veli\u010dina","text":"<p>Definice 7.6 (Diskr\u00e9tn\u00ed n\u00e1hodn\u00e1 veli\u010dina)</p> <ul> <li>Diskr\u00e9tn\u00ed n\u00e1hodn\u00e1 veli\u010dina tedy p\u0159i\u0159azuje ka\u017ed\u00e9mu element\u00e1rn\u00edmu jevu \\(\u03c9_{i} \\in \\Omega\\) n\u011bjakou \u010d\u00edselnou   hodnotu \\(x_{i} = X(\u03c9_{i})\\) a m\u016f\u017ee nab\u00fdvat pouze kone\u010dn\u00fd nebo spo\u010detn\u011b   nekone\u010dn\u00fd po\u010det hodnot \\(\\{x_{1}, x_{2}, . . .\\}\\)</li> <li>N\u00e1hodn\u00e1 veli\u010dina se tak\u00e9 n\u011bkdy naz\u00fdv\u00e1 n\u00e1hodn\u00e1 prom\u011bnn\u00e1 (random variable)</li> </ul> <p></p> <p>Definice 7.7 (St\u0159edn\u00ed hodnota n\u00e1hodn\u00e9 veli\u010diny)</p> <p></p> <p>V\u011bta 7.2 (O linearit\u011b st\u0159edn\u00ed hodnoty)</p> D\u016fkaz v\u011bty 7.2 <p>Bu\u010f \\((\\Omega, \\mathbf{P})\\) Diskr\u00e9tn\u00ed pravd\u011bpodobnostn\u00ed prostor, potom:</p> \\[ \\begin{align} \\mathbf{E}[\\alpha X + \\beta Y] &amp; =  \\sum_{\\omega \\in \\Omega}{(\\alpha X + \\beta Y)(\\omega) \\cdot \\mathbf{P}(\\omega)} = \\\\ &amp; = \\sum_{\\omega \\in \\Omega}{(\\alpha \\cdot X (\\omega) + \\beta \\cdot Y (\\omega)) \\cdot \\mathbf{P}(\\omega)} = \\\\ &amp; = \\sum_{\\omega \\in \\Omega}{\\alpha \\cdot X (\\omega) \\cdot \\mathbf{P}(\\omega)} + \\sum_{\\omega \\in \\Omega}{\\beta \\cdot Y (\\omega) \\cdot \\mathbf{P}(\\omega)} = \\\\ &amp; = \\alpha \\cdot \\sum_{\\omega \\in \\Omega}{X (\\omega) \\cdot \\mathbf{P}(\\omega)} + \\beta \\cdot \\sum_{\\omega \\in \\Omega}{Y (\\omega) \\cdot \\mathbf{P}(\\omega)} = \\\\ &amp; = \\alpha \\cdot \\mathbf{E}[X] + \\beta \\cdot \\mathbf{E}[Y] &amp; \\square \\end{align} \\] <p></p> <p>V\u011bta 7.3 (O opakov\u00e1n\u00ed nez\u00e1visl\u00fdch pokus\u016f)</p>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#def-7.6","title":"Diskr\u00e9tn\u00ed n\u00e1hodn\u00e1 veli\u010dina","text":"<p>Nech\u0165 \\((\\Omega, \\mathbf{P})\\) je diskr\u00e9tn\u00ed pravd\u011bpodobnostn\u00ed prostor. Pak diskr\u00e9tn\u00ed n\u00e1hodn\u00e1 veli\u010dina je funkce \\(X : \\Omega \\rightarrow \\mathbb{R}\\)</p>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#def-7.7","title":"St\u0159edn\u00ed hodnota n\u00e1hodn\u00e9 veli\u010diny","text":"<p>St\u0159edn\u00ed hodnota \\(\\mathbf{E}[X]\\) n\u00e1hodn\u00e9 veli\u010diny \\(X\\) je pr\u016fm\u011br v\u0161ech hodnot veli\u010diny \\(X\\) v\u00e1\u017een\u00fd pravd\u011bpodobnostmi p\u0159\u00edslu\u0161n\u00fdch element\u00e1rn\u00edch jev\u016f, tedy:</p> \\[ \\sum_{\\omega \\in \\Omega}{X(\\omega) \\cdot \\mathbf{P}(\\omega)} = \\sum_{x_{i}} x_{i} \\cdot \\mathbf{P}[X = x_{i}] \\] <p>Tato \u0159ada mus\u00ed konvergovat absolutn\u011b, jinak st\u0159edn\u00ed hodnotu nezav\u00e1d\u00edme.</p>"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#theorem-7.2","title":"V\u011bta O linearit\u011b st\u0159edn\u00ed hodnoty","text":"<p>Nech\u0165 \\(\\alpha\\) a \\(\\beta\\) jsou re\u00e1ln\u00e1 \u010d\u00edsla a nech\u0165 \\(X\\) a \\(Y\\) jsou n\u00e1hodn\u00e9 veli\u010diny, potom:</p> \\[ \\mathbf{E}[\\alpha X + \\beta Y] = \\alpha \\mathbf{E}[X] + \\beta \\mathbf{E}[Y] \\]"},{"location":"07_Randomizace_a_he%C5%A1ov%C3%A1n%C3%AD/7.5_Pravd%C4%9Bpodobnostn%C3%AD_prostor/#theorem-7.3","title":"V\u011bta O opakov\u00e1n\u00ed nez\u00e1visl\u00fdch pokus\u016f","text":"<p>Uva\u017eujme s\u00e9rii nez\u00e1visl\u00fdch pokus\u016f, ve kter\u00fdch sledujeme, zda nastal n\u011bjak\u00fd jev \\(J\\). Pravd\u011bpodobnost, \u017ee jev \\(J\\) nastane, je v ka\u017ed\u00e9m pokusu st\u00e1le stejn\u00e1 a rovna \\(p\\). Definujme n\u00e1hodnou veli\u010dinu \\(T\\) jako po\u0159ad\u00ed pokusu, ve kter\u00e9m jev \\(J\\) nastal poprv\u00e9, pak: </p> \\[ \\mathbf{E}[T] = \\frac{1}{p} \\]"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.1_Rekurze_a_metoda_Rozd%C4%9Bl_a_Panuj/","title":"8.1 Rekurze a metoda Rozd\u011bl a Panuj","text":"<p>Rekurzivn\u00ed algoritmus je postup \u0159e\u0161en\u00ed probl\u00e9mu nad vstupn\u00edmi daty, p\u0159i kter\u00e9m</p> <ul> <li>se stejn\u00fd postup aplikuje na jednu nebo v\u00edce \u010d\u00e1st\u00ed vstupn\u00edch dat (\u010dili men\u0161\u00ed instance probl\u00e9mu se \u0159e\u0161\u00ed stejn\u011b jako p\u016fvodn\u00ed probl\u00e9m),</li> <li>sou\u010dasn\u011b se poskytne p\u0159\u00edm\u00e9 \u0159e\u0161en\u00ed trivi\u00e1ln\u00ed instance probl\u00e9mu</li> <li>a \u0159e\u0161en\u00ed cel\u00e9ho probl\u00e9mu se sestav\u00ed z \u0159e\u0161en\u00ed podprobl\u00e9m\u016f.</li> </ul> <p>Tato metoda \u0159e\u0161en\u00ed probl\u00e9m\u016f rozd\u011blen\u00edm na podprobl\u00e9my \u0159e\u0161en\u00e9 stejn\u00fdm zp\u016fsobem se ozna\u010duje Rozd\u011bl a Panuj. P\u0159i vhodn\u00e9m pou\u017eit\u00ed m\u016f\u017ee tato technika v\u00e9st k p\u0159ekvapiv\u011b efektivn\u00edm algoritm\u016fm.</p> <p>V\u00fdhody rekurzivn\u00ed metody konstrukce algoritm\u016f:</p> <ul> <li>\u00daspornost: z\u00e1pis k\u00f3du je krat\u0161\u00ed.</li> <li>P\u0159irozenost: opakov\u00e1n\u00ed a samopodobnost jsou b\u011b\u017en\u00e9 v p\u0159\u00edrod\u011b.</li> <li>Intuitivnost: explicitn\u011b pojmenujeme to, co se opakuje v men\u0161\u00edm.</li> <li>Expresivnost: rekurzivn\u00ed z\u00e1pis umo\u017e\u0148uje snadn\u00e9 vyj\u00e1d\u0159en\u00ed slo\u017eitosti rekurentn\u00ed rovnic\u00ed (viz BI-MA2) a ov\u011b\u0159en\u00ed korektnosti.</li> </ul> <p>B\u011bhov\u00e9 prost\u0159ed\u00ed programovac\u00edho jazyka mus\u00ed za\u0159\u00eddit p\u0159es syst\u00e9mov\u00fd z\u00e1sobn\u00edk zano\u0159ov\u00e1n\u00ed a n\u00e1vraty z rekurze.</p>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.2_MergeSort/","title":"8.2 MergeSort","text":"<ul> <li>Jedn\u00e1 se o rychl\u00fd rekurzivn\u00ed algoritmus pro \u0159azen\u00ed, zalo\u017een\u00fd na   sl\u00e9v\u00e1n\u00ed se\u0159azen\u00fdch podposloupnost\u00ed.</li> <li>Posloupnost o jednom prvku je u\u017e se\u0159azen\u00e1.</li> <li>M\u011bjme vstupn\u00ed nese\u0159azenou posloupnost \\(n\\) prvk\u016f pro \\(n\\) \\(\\geq 2\\).</li> <li>Rozd\u011bl\u00edme ji na dv\u011b \u010d\u00e1sti polovi\u010dn\u00ed d\u00e9lky (\u0159ekn\u011bme prvn\u00edch   \\(\u230an/2\u230b\\) a zb\u00fdvaj\u00edc\u00edch \\(\u2308n/2\u2309\\) prvk\u016f).</li> <li>Rekurzivn\u00edm vol\u00e1n\u00edm t\u00e9ho\u017e algoritmu na ob\u011b poloviny je   se\u0159ad\u00edme.</li> <li>Ob\u011b se\u0159azen\u00e9 poloviny posl\u00e9ze slijeme dohromady do jedn\u00e9   se\u0159azen\u00e9 posloupnosti a m\u00e1me v\u00fdsledek.</li> </ul> <p>Vstup: posloupnost \\(n\\) \u010d\u00edsel  V\u00fdstup: vzestupn\u011b se\u0159azen\u00e1 posloupnost ze vstupu</p> <p></p> <p>Algoritmus 8.1 (Mergesort)</p> MergeSort(a1, . . . , an):<pre><code>Pokud n = 1: vra\u0165 jako v\u00fdsledek b1 = a1 a skon\u010di\nx1,..., x\u230an/2\u230b:= MergeSort(a1,..., a\u230an/2\u230b)\ny1, ..., y\u2308n/2\u2309:= MergeSort(a\u230an/2\u230b+1,..., an)\nVra\u0165 b1,..., bn := Merge(x1,..., x\u230an/2\u230b; y1,..., y\u2308n/2\u2309)\n</code></pre> <ul> <li>Procedura Merge m\u00e1 na vstupu dv\u011b vzestupn\u011b se\u0159azen\u00e9   posloupnosti (jednorozm\u011brn\u00e1 pole) a prov\u00e1d\u00ed jejich sl\u00e9v\u00e1n\u00ed do   jedin\u00e9 se\u0159azen\u00e9 posloupnosti.</li> <li>Dostaneme tak datov\u011b necitliv\u00fd, out-of-place a stabiln\u00ed   \u0159ad\u00edc\u00ed algoritmus.</li> </ul> <p>Vstup: dv\u011b vzestupn\u011b se\u0159azen\u00e9 posloupnosti V\u00fdstup: vzestupn\u011b se\u0159azen\u00e1 posloupnost vznikl\u00e1 slit\u00edm vstup\u016f</p> <p></p> <p>Algoritmus 8.2 (Merge)</p> Merge(x1, . . . , xm; y1, . . . , yn):<pre><code>i := 1, j := 1, k := 1\nDokud i \u2264 m a j \u2264 n, opakujeme:\n    Pokud xi \u2264 yj :                             //p\u0159esuneme prvek z x\n        zk := xi, i := i + 1 \n    Jinak:                                      //p\u0159esuneme prvek z y\n        zk := yj , j := j + 1\n    k := k + 1\nPokud i \u2264 m:                                     //p\u0159esuneme zbytek x\n    zk,...,zm+n := xi,...,xm\nPokud j \u2264 n:                                    //p\u0159esuneme zbytek y\n    zk,...,zm+n := yj,...,yn\nVra\u0165 z1,...,zm+n\n</code></pre>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.2_MergeSort/#priklad-razeni-pomoci-algoritmu-mergesort","title":"P\u0159\u00edklad \u0159azen\u00ed pomoc\u00ed algoritmu Mergesort","text":""},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.2_MergeSort/#casova-slozitost-algoritmu-mergesort","title":"\u010casov\u00e1 slo\u017eitost algoritmu MergeSort","text":"<p>Pozorov\u00e1n\u00ed</p> <ul> <li>Operace Merge pouze p\u0159esouv\u00e1 prvky a ka\u017ed\u00fd prvek p\u0159esune pr\u00e1v\u011b jednou.</li> <li>Jej\u00ed \u010dasov\u00e1 slo\u017eitost je tedy \\(\u0398(n + m)\\), kde \\(n\\), \\(m\\) jsou d\u00e9lky sl\u00e9van\u00fdch pol\u00ed.</li> <li>Vy\u017eaduje pomocnou pam\u011b\u0165 ve form\u011b pomocn\u00e9ho pole velikosti \\(\u0398(n + m)\\).</li> </ul> <p></p> <p>V\u011bta 8.1</p> D\u016fkaz V\u011bty 8.1 <ul> <li>Rozd\u011blen\u00ed posloupnosti a slit\u00ed se\u0159azen\u00fdch kus\u016f trv\u00e1 \u010das \\(cn\\).</li> <li>Algoritmus vol\u00e1 \\(2\u00d7\\) sebe sama na vstupy velikosti \\(n/2\\). Proto \\(T (1) = 1\\), \\(T (n) = 2\u00b7T (n/2) + cn\\).</li> <li>Po rozvinut\u00ed dostaneme: \\(T (n) = 2\u00b7(2\u00b7T (n/4) + cn/2) + cn =\\) \\(= 4\u00b7T (n/4) + 2cn =\\) \\(= 8\u00b7T (n/8) + 3cn =\\) \\(\u00b7\u00b7\u00b7\\) \\(= 2^k\u00b7T (n/2^k) + kcn.\\)</li> <li>Rekurze skon\u010d\u00ed, kdy\u017e \\(n/2^k = 1\\) \u010dili \\(k = log\\ n\\). T\u00edm dostaneme \\(T (n) = 2^{log\\ n}\u00b7T (1) + log\\ n\u00b7cn = \u0398(n) + cn\\ log\\ n = \u0398(n\\ log\\ n)\\).</li> </ul> <p></p> <p>V\u011bta 8.2</p> D\u016fkaz V\u011bty 8.2 <ul> <li>MergeSort si pamatuje lok\u00e1ln\u00ed prom\u011bnn\u00e9: vstup a jejich set\u0159\u00edd\u011bn\u00e9 poloviny, dohromady \\(\u0398(n)\\) pam\u011bti. Plus kontext pro n\u00e1vrat z rekurzivn\u00edho zano\u0159en\u00ed (\\(O(1)\\) pam\u011bti).</li> <li>Mimo to ob\u011b rekurzivn\u00ed vol\u00e1n\u00ed spot\u0159ebuj\u00ed dal\u0161\u00ed pam\u011b\u0165, ale jeliko\u017e v\u017edy b\u011b\u017e\u00ed pouze jedno z nich, sta\u010d\u00ed zapo\u010d\u00edtat pouze jedno.</li> <li>Dostaneme tuto rekurentn\u00ed rovnici (pro kladnou konstantu \\(d\\)): \\(M (1) = 1\\), \\(M (n) = dn + M (n/2)\\)</li> <li>To n\u00e1m pro \\(M (n)\\) d\u00e1v\u00e1 geometrickou \u0159adu \\(dn + dn/2 + dn/4 +\u00b7\u00b7\u00b7\\), kter\u00e1 m\u00e1 sou\u010det \\(\u0398(n)\\).</li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.2_MergeSort/#theorem-8.1","title":"\u010casov\u00e1 slo\u017eitost MergeSort","text":"<p>\u010casov\u00e1 slo\u017eitost MergeSort je \\(\u0398(n\\ log n)\\).</p>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.2_MergeSort/#theorem-8.2","title":"Pam\u011b\u0165ov\u00e1 slo\u017eitost MergeSort","text":"<p>Pam\u011b\u0165ov\u00e1 slo\u017eitost MergeSort je \\(\u0398(n)\\).</p>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.3_Rekurzivn%C3%AD_formulace_n%C3%A1soben%C3%AD_dvou_cel%C3%BDch_%C4%8D%C3%ADsel/","title":"8.3 Rekurzivn\u00ed formulace n\u00e1soben\u00ed dvou cel\u00fdch \u010d\u00edsel","text":"<ul> <li>Uk\u00e1\u017eeme nejprv, \u017ee i n\u00e1soben\u00ed cel\u00fdch \u010d\u00edsel lze popsat rekurzivn\u011b.</li> <li>M\u011bjme dv\u011b \\(n\\)-cifern\u00e1 \u010d\u00edsla \\(x\\) a \\(y\\), kter\u00e1 chceme vyn\u00e1sobit.</li> <li>Pro jednoduchost zat\u00edm p\u0159edpokl\u00e1dejme, \u017ee \\(n\\) je mocnina   dvou.</li> <li>Ob\u011b \u010d\u00edsla rozd\u011bl\u00edme na horn\u00edch \\(n/2\\) a doln\u00edch \\(n/2\\) cifer.   Plat\u00ed tedy</li> </ul> <p>\\(x = x_U \\cdot 10^{n/2} + x_L,\\) \\(y = y_U \\cdot 10^{n/2} + y_L,\\)</p> <ul> <li>kde \\(x_U, x_L, y_U, y_L\\) jsou (\\(n/2\\))-cifern\u00e1 \u010d\u00edsla.</li> <li>V\u00fdsledn\u00fd sou\u010din dvou n-cifern\u00fdch \u010d\u00edsel \\(xy\\) pak m\u016f\u017eeme   poskl\u00e1dat ze 4 sou\u010din\u016f \\(n/2\\) cifern\u00fdch \u010d\u00edsel:</li> </ul> \\[x\u00b7y= x_U\u00b7y_U\u00b710^n + (x_U\u00b7y_L + x_L\u00b7y_U)\u00b710^{n/2} + x_L\u00b7y_L\\] <ul> <li>Rekurzivn\u011b tedy spo\u010d\u00edt\u00e1me 4 sou\u010diny dvojic \u010d\u00edsel polovi\u010dn\u00ed d\u00e9lky:   \\(x_U\u00b7y_U, x_U\u00b7y_L, x_L\u00b7y_U\\) a \\(x_L\u00b7y_L\\).</li> <li>V\u00fdsledek z t\u011bchto d\u00edl\u010d\u00edch sou\u010din\u016f slo\u017e\u00edme pomoc\u00ed n\u011bkolik   \\(2n\\)-cifern\u00fdch s\u010d\u00edt\u00e1n\u00ed (s\u010d\u00edt\u00e1n\u00ed m\u00e1 line\u00e1rn\u00ed slo\u017eitost vzhledem k   po\u010dtu cifer) a n\u011bkolika n\u00e1soben\u00ed mocninou des\u00edtky (dopl\u0148ov\u00e1n\u00ed   nejv\u00fd\u0161e n nul na konec).</li> <li>\u0158e\u0161\u00edme tedy \u010dty\u0159i podprobl\u00e9my polovi\u010dn\u00ed velikosti a pak   provedeme n\u011bkolik operac\u00ed s line\u00e1rn\u00ed slo\u017eitost\u00ed vzhledem k n.</li> <li>Pro \u010dasovou slo\u017eitost proto plat\u00ed:</li> </ul> <p>\\(T (1) = 1\\), \\(T (n) = 4\u00b7T (n/2) + \u0398(n)\\).</p>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.3_Rekurzivn%C3%AD_formulace_n%C3%A1soben%C3%AD_dvou_cel%C3%BDch_%C4%8D%C3%ADsel/#strom-rekurzivnich-volani-nasobeni-cisel","title":"Strom rekurzivn\u00edch vol\u00e1n\u00ed n\u00e1soben\u00ed \u010d\u00edsel","text":"<ul> <li>Strom rekurzivn\u00edch vol\u00e1n\u00ed m\u00e1 n\u00e1sleduj\u00edc\u00ed vlastnosti:<ul> <li>Na jeho \\(i\\)-t\u00e9 hladin\u011b se nach\u00e1z\u00ed \\(4^i\\) vrchol\u016f, kter\u00e9 reprezentuj\u00ed   n\u00e1soben\u00ed dvou \u010d\u00edsel o \\(n/2^i\\) cifr\u00e1ch.</li> <li>V ka\u017ed\u00e9m vrcholu t\u00e9to hladiny tedy tr\u00e1v\u00edme \u010das \\(\u0398(n/2^i)\\) a na   cel\u00e9 hladin\u011b \\(4^i\u00b7\u0398(n/2^i) = \u0398(2^i\u00b7n)\\).</li> <li>Jeliko\u017e hladin je op\u011bt \\(log\\ n\\), str\u00e1v\u00edme jenom na posledn\u00ed hladin\u011b   \u010das \\(\u0398(2^{log\\ n} \u00b7n) = \u0398(n^2)\\).</li> </ul> </li> <li>\u010cili \\(T (n) = \u0398(n^2)\\) a oproti b\u011b\u017en\u00e9mu \u201e\u0161koln\u00edmu\u201c n\u00e1soben\u00ed jsme   si tedy nepomohli.</li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.3_Rekurzivn%C3%AD_formulace_n%C3%A1soben%C3%AD_dvou_cel%C3%BDch_%C4%8D%C3%ADsel/#vylepsene-nasobeni-cisel-karacubuv-algoritmus","title":"Vylep\u0161en\u00e9 n\u00e1soben\u00ed \u010d\u00edsel: Karacub\u016fv algoritmus","text":"<ul> <li>Hlavn\u00ed n\u00e1pad rychlej\u0161\u00edho n\u00e1soben\u00ed dvou \u010d\u00edsel pomoc\u00ed Karacubova   algoritmu vych\u00e1z\u00ed z post\u0159ehu, \u017ee t\u00e9ho\u017e efektu lze dos\u00e1hnout   pomoc\u00ed pouze 3 n\u00e1soben\u00ed \u010d\u00edsel polovi\u010dn\u00ed d\u00e9lky.</li> <li>Pro v\u00fdpo\u010det \\((x_U\u00b7y_L + x_L\u00b7y_U)\\) jsme pot\u0159ebovali 2 n\u00e1soben\u00ed \u010d\u00edsel   polovi\u010dn\u00ed d\u00e9lky.</li> <li>Trivi\u00e1ln\u011b plat\u00ed \\(x_U\u00b7y_L + x_L\u00b7y_U = (x_U + x_L)\u00b7(y_U + y_L)\u2212x_U\u00b7y_U\u2212x_L\u00b7y_L\\)</li> <li>Rekurzivn\u00ed zp\u016fsob n\u00e1soben\u00ed lze tedy p\u0159epsat na tvar \\(x\u00b7y=\\)</li> </ul> \\[x_U\u00b7y_U\u00b710^n +((x_U +x_L)\u00b7(y_U +y_L)\u2212x_U\u00b7y_U\u2212x_L\u00b7y_L)\u00b710^{n/2} +x_L\u00b7y_L\\] <ul> <li>M\u00edsto 4 n\u00e1soben\u00ed m\u00e1me pouze 3 a p\u0159ibyly 2 operace s\u010d\u00edt\u00e1n\u00ed, ale   ty maj\u00ed pouze line\u00e1rn\u00ed slo\u017eitost.</li> <li>Rekurzivn\u00ed n\u00e1hrada 1 nasoben\u00ed dv\u011bma s\u010d\u00edt\u00e1n\u00edmi zmen\u0161\u00ed \u010dasovou   slo\u017eitost.</li> </ul> <p>V\u011bta 8.3</p> D\u016fkaz V\u011bty 8.3 <ul> <li>Po\u010det operac\u00ed je \\(T (1) = 1\\),</li> <li>\\(T (n) = 3\u00b7T (n/2) + \u0398(n)\\).</li> <li>Strom rekurzivn\u00edch vol\u00e1n\u00ed vypad\u00e1 takto:<ul> <li>Na \\(i\\)-t\u00e9 hladin\u011b je \\(3^i\\) vrchol\u016f s (\\(n/2^i\\))-cifern\u00fdmi probl\u00e9my.</li> <li>Na \\(i\\)-t\u00e9 hladin\u011b nyn\u00ed dohromady tr\u00e1v\u00edme \u010das \\(\u0398(n\u00b7(3/2)^i)\\).</li> <li>Hloubka stromu se nezm\u011bnila a z\u016fst\u00e1v\u00e1 tedy nad\u00e1le \\(log\\ n\\).</li> <li>V sou\u010dtu p\u0159es v\u0161echny hladiny dostaneme:     \\(T (n) = \u0398( n\u00b7 [(3/2)^0 + (3/2)^1 +\u00b7\u00b7\u00b7(3/2)^{log\\ n}])\\)      .          .      \\(T (n) = \u0398 \\left( n \\cdot \\left[ \\left( \\frac{3}{2}\\right)^0 + \\left(\\frac{3}{2}\\right)^1 + ... + \\left(\\frac{3}{2}\\right)^{\\log{n}} \\right] \\right)\\)</li> <li>V\u00fdraz v hranat\u00fdch z\u00e1vork\u00e1ch je geometrick\u00e1 \u0159ada s koeficientem \\(\\frac{3}{2}\\)</li> <li>Tu m\u016f\u017eeme se\u010d\u00edst obvykl\u00fdm zp\u016fsobem na     \\(\\frac{ \\left( \\frac{3}{2}\\right)^{1 + \\log{n}} - 1}{\\frac{3}{2} - 1}\\)</li> <li>Kdy\u017e zanedb\u00e1me konstanty, obdr\u017e\u00edme \\((\\frac{3}{2})^{\\log{n}}\\)</li> <li>To d\u00e1le uprav\u00edme na     \\((2^{\\log{\\frac{3}{2}}})^{\\log{n}} = 2^{\\log{\\frac{3}{2} \\cdot \\log{n}}} = (2^{\\log{n}})^{\\log{\\frac{3}{2}}} = n^{\\log{\\frac{3}{2}}} = n^{\\log{3} - 1}\\)</li> <li>\u010casov\u00e1 slo\u017eitost na\u0161eho algoritmu tedy \u010din\u00ed      \\(\u0398(n\u00b7n^{\\log{3}\u22121}) = \u0398(n^{\\log{3}}) \u2248\u0398(n^{1,59})\\).</li> </ul> </li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.3_Rekurzivn%C3%AD_formulace_n%C3%A1soben%C3%AD_dvou_cel%C3%BDch_%C4%8D%C3%ADsel/#theorem-8.3","title":"\u010casov\u00e1 slo\u017eitost Karacubova algoritmu","text":"<p>\u010casov\u00e1 slo\u017eitost Karacubova algoritmu je \\(\u0398(n^{\\log_2{3}}) \u2248\u0398(n^{1,59})\\).</p>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.3_Rekurzivn%C3%AD_formulace_n%C3%A1soben%C3%AD_dvou_cel%C3%BDch_%C4%8D%C3%ADsel/#pseudokod-karacubova-algoritmu-pro-obecne-n","title":"Pseudok\u00f3d Karacubova algoritmu pro obecn\u00e9 \\(n\\)","text":"<ul> <li>Zat\u00edm jsme p\u0159edpokl\u00e1dali, \u017ee n je mocnina dvou.<ul> <li>Pro obecn\u00e9, resp. lich\u00e9 \\(n\\), si ze dvou mo\u017enost\u00ed, jak d\u011blit lich\u00fd   po\u010det cifer \\(n\\) na horn\u00ed a doln\u00ed polovinu pozic, vybereme   nap\u0159. \\(x = x_U\u00b710^{\u2308n/2\u2309}+ x_L\\) a \\(y= y_U\u00b710^{\u2308n/2\u2309}+ y_L\\).   Pak:</li> </ul> </li> </ul> <p>8.3 Karacubuv algoritmus</p> Karacuba(n, n-cifern\u00e1 \u010d\u00edsla x a y):<pre><code>Pokud n \u2264 42: vra\u0165 xy a skon\u010di\nk := \u2308n/2\u2309\nxU := \u230ax/10^k\u230b\nxL := x mod 10^k\nyU := \u230ay/10^k\u230b\nyL := y mod 10^k\np := Karacuba(\u230an/2\u230b, xU, yU)\nq := Karacuba(\u2308n/2\u2309, xL, yL)\nr := Karacuba(\u2308n/2\u2309+ 1, xU + xL, yU + yL)\nVra\u0165 p\u00b710^2k + (r\u2212p\u2212q)\u00b710^k + q\n</code></pre>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.4_Strassen%C5%AFv_algoritmus/","title":"8.4 Strassen\u016fv algoritmus","text":"<ul> <li>Na stejn\u00e9m principu je postaven\u00e9 i zrychlen\u00ed maticov\u00e9ho n\u00e1soben\u00ed.</li> <li>Rozd\u011bl\u00edme matice na \u010dtvrtiny (p\u0159edpokl\u00e1d\u00e1me \\(A, B, C \u2208 \\mathbb{R}^{n\u00d7n}\\) pro \\(n = 2^k\\)).</li> </ul> \\[ \\left( \\begin{matrix}   A_{11} &amp; A_{12} \\\\   A_{21} &amp; A_{22}\\\\ \\end{matrix} \\right) \\cdot \\left( \\begin{matrix}   B_{11} &amp; B_{12} \\\\   B_{21} &amp; B_{22}\\\\ \\end{matrix} \\right) = \\left( \\begin{matrix}   C_{11} &amp; C_{12} \\\\   C_{21} &amp; C_{22}\\\\ \\end{matrix} \\right)  \\] \\[ \\begin{align*}     M_1 &amp;= (A_{11} + A_{22}) \\cdot (B_{11} + B_{22}) \\\\     M_2 &amp;= (A_{21} + A_{22}) \\cdot B_{11} \\\\     M_3 &amp;= A_{11} \\cdot (B_{12} - B_{22}) \\\\     M_4 &amp;= A_{22} \\cdot (B_{21} - B_{11}) \\\\     M_5 &amp;= (A_{11} + A_{12}) \\cdot B_{22} \\\\     M_6 &amp;= (A_{21} - A_{11}) \\cdot (B_{11} + B_{12}) \\\\     M_7 &amp;= (A_{12} - A_{22}) \\cdot (B_{21} + B_{22}) \\end{align*} \\] \\[ A \\cdot B = \\begin{pmatrix}     M_1 + M_4 - M_5 + M_7 &amp; M_3 - M_5 \\\\     M_2 + M_4 &amp; M_1 - M_2 + M_3 + M_6 \\end{pmatrix}\\] <p>V\u011bta 8.4</p> <p>Dal\u0161\u00ed vylep\u0161en\u00ed na podobn\u00e9m principu</p> <ul> <li>Laderman\u016fv algoritmus (matice \\(3 \u00d73\\); celkem \\(23\\) n\u00e1soben\u00ed)</li> <li>...</li> <li>AlphaTensor (DeepAI)<ul> <li>pro matice \\(4 \u00d74\\) sta\u010d\u00ed \\(47\\) n\u00e1soben\u00ed (p\u0159edchoz\u00ed v\u00fdsledek 49; 1969)</li> <li>pro matice \\(5 \u00d75\\) sta\u010d\u00ed \\(96\\) n\u00e1soben\u00ed (p\u0159edchoz\u00ed v\u00fdsledek 98)</li> </ul> </li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.4_Strassen%C5%AFv_algoritmus/#theorem-8.4","title":"Slo\u017eitost Strassenova algoritmu","text":"<p>Slo\u017eitost Strassenova algoritmu je \\(O(n^{log_2{7}})\\).</p>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/","title":"8.5 QuickSelect","text":""},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#hledani-k-teho-nejmensiho-prvku-v-neserazene-posloupnosti","title":"Hled\u00e1n\u00ed k-t\u00e9ho nejmen\u0161\u00edho prvku v nese\u0159azen\u00e9 posloupnosti","text":"<ul> <li>P\u0159i pou\u017eit\u00ed metody Rozd\u011bl a Panuj se n\u011bkdy uk\u00e1\u017ee, \u017ee n\u011bkter\u00e9 z   \u010d\u00e1st\u00ed, na kter\u00e9 jsme vstup rozd\u011blili, nemus\u00edme v\u016fbec zpracov\u00e1vat.</li> <li>Typick\u00fdm p\u0159\u00edkladem je rekurzivn\u00ed popis \u0159e\u0161en\u00ed probl\u00e9mu nalezen\u00ed   k-t\u00e9ho nejmen\u0161\u00edho prvku v nese\u0159azen\u00e9 posloupnosti.</li> </ul> <p>Probl\u00e9m</p> <p>Na vstupu je nese\u0159azen\u00e1 posloupnost \\(X\\) o velikosti \\(n\\) prvk\u016f a \u010d\u00edslo \\(k\\), \\(k \u2264n\\). C\u00edlem je naj\u00edt \\(k\\)-t\u00fd nejmen\u0161\u00ed prvek v \\(X\\).</p> <ul> <li>Samoz\u0159ejm\u011b, \u017ee lze probl\u00e9m trivi\u00e1ln\u011b vy\u0159e\u0161it se\u0159azen\u00edm   posloupnosti v \u010dase \\(O(n \\log{n}).\\)</li> <li>Elegance n\u00e1sleduj\u00edc\u00edho \u0159e\u0161en\u00ed spo\u010d\u00edv\u00e1 v tom, \u017ee probl\u00e9m \u0159e\u0161\u00ed   \u0159\u00e1dov\u011b rychleji bez nutnosti vstupn\u00ed posloupnost se\u0159adit.</li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#idea-rychleho-algoritmu-vyberu-quickselect","title":"Idea rychl\u00e9ho algoritmu v\u00fdb\u011bru QuickSelect","text":"<ul> <li>Vybereme ze vstupn\u00ed posloupnosti \\(X\\) n\u011bjak\u00fd prvek, tzv. pivot.</li> <li>Vstupn\u00ed posloupnost pot\u00e9 rozd\u011bl\u00edme na t\u0159i \u010d\u00e1sti:<ul> <li>na levou \u010d\u00e1st \\(L\\), do kter\u00e9 p\u0159esuneme prvky men\u0161\u00ed ne\u017e pivot,</li> <li>na prost\u0159edn\u00ed \u010d\u00e1st \\(S\\), do kter\u00e9 p\u0159esuneme prvky rovn\u00e9 pivotovi,   a</li> <li>na pravou \u010d\u00e1st \\(P\\) , do kter\u00e9 p\u0159esuneme prvky v\u011bt\u0161\u00ed ne\u017e pivot.</li> </ul> </li> <li>Kdybychom posloupnost hypoteticky se\u0159adili, bude tvo\u0159ena   nejd\u0159\u00edve se\u0159azenou \u010d\u00e1st\u00ed \\(L\\), pak v\u0161emi prvky z \\(S\\) a kone\u010dn\u011b   se\u0159azenou \u010d\u00e1st\u00ed \\(P\\) . Z toho okam\u017eit\u011b dost\u00e1v\u00e1me algoritmus:</li> </ul> <p>Pozorov\u00e1n\u00ed</p> <ul> <li>Je-li \\(k \u2264|L|\\), je hledan\u00fd prvek \\(k\\)-t\u00fd nejmen\u0161\u00ed prvek v \u010d\u00e1sti \\(L\\).</li> <li>Je-li \\(|L|&lt; k \u2264|L|+ |S|\\), je hledan\u00fd prvek roven pivotovi.</li> <li>Je-li \\(k &gt; |L|+ |S|\\), je hledan\u00fd prvek \\((k \u2212|L|\u2212|S|)\\)-t\u00fd nejmen\u0161\u00ed prvek v \u010d\u00e1sti \\(P\\).</li> </ul> <p></p> <p>8.4 QuickSelect</p> QuickSelect(x1, . . . , xn; k):<pre><code>Pokud n = 1: vra\u0165 x1 a skon\u010di\np := n\u011bkter\u00fd z prvk\u016f x1, . . . , xn //pivot\nL := prvky z x1, . . . , xn, kter\u00e9 jsou men\u0161\u00ed ne\u017e p\nS := prvky z x1, . . . , xn, kter\u00e9 jsou rovny p\nP := prvky z x1, . . . , xn, kter\u00e9 jsou v\u011bt\u0161\u00ed ne\u017e p\nPokud k \u2264|L|: vra\u0165 QuickSelect(L, k)\nJinak pokud k \u2264 |L| + |S|: vra\u0165 p\nJinak: vra\u0165 QuickSelect(P, k \u2212 |L| \u2212 |S|)\n</code></pre>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#volba-pivota-pro-nejhorsi-casovou-slozitost","title":"Volba pivota pro nejhor\u0161\u00ed \u010dasovou slo\u017eitost","text":"<ul> <li>Rozd\u011blen\u00ed vstupn\u00ed posloupnosti na \\(L, S, P\\) trv\u00e1 line\u00e1rn\u00ed \u010das.</li> <li>Pak se QuickSelect rekurzivn\u011b zavol\u00e1 na \u010d\u00e1st \\(L\\) nebo \\(P\\).</li> <li>O kolik bude tato \u010d\u00e1st men\u0161\u00ed ne\u017e \\(n\\), to z\u00e1vis\u00ed zejm\u00e9na na hodnot\u00e1ch ve vstupn\u00ed posloupnosti a na zp\u016fsobu v\u00fdb\u011bru   pivota.</li> <li> <p>P\u0159\u00edklad sc\u00e9n\u00e1\u0159e vedouc\u00edho na nejhor\u0161\u00ed \u010dasovou slo\u017eitost:</p> <ul> <li>Zvol\u00edme-li pivota jako nejv\u011bt\u0161\u00ed prvek vstupu, bude \\(\\lvert L \\rvert = n - 1\\).</li> <li>Pokud nav\u00edc bude \\(k = 1\\), bude se QuickSelect rekurzivn\u011b volat pr\u00e1v\u011b na \\(L\\).</li> <li>To se v nejhor\u0161\u00edm p\u0159\u00edpad\u011b m\u016f\u017ee opakovat, tak\u017ee celkov\u00e1 \u010dasov\u00e1 slo\u017eitost v nejhor\u0161\u00edm p\u0159\u00edpad\u011b bude:   \\(\\Theta(n) + \\Theta(n - 1) + \\cdots + \\Theta(1) = \\Theta(n^2).\\)</li> <li>V dal\u0161\u00edm si uk\u00e1\u017eeme, jak m\u016f\u017eeme pomoc\u00ed randomizace pravd\u011bpodobnost tohoto sc\u00e9n\u00e1\u0159e minimalizovat.</li> </ul> </li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#volba-pivota-pro-lepsi-casovou-slozitost","title":"Volba pivota pro lep\u0161\u00ed \u010dasovou slo\u017eitost","text":"<ul> <li>P\u0159\u00edklad sc\u00e9n\u00e1\u0159e vedouc\u00edho na nejlep\u0161\u00ed \u010dasovou slo\u017eitosti:<ul> <li>Ide\u00e1ln\u00ed volbou pivota by byl medi\u00e1n dan\u00e9 (pod)posloupnosti.<ul> <li>\\(\\lvert L \\rvert\\) i \\(\\lvert P \\rvert\\) by byla nejv\u00fd\u0161e \\(\\lfloor n/2 \\rfloor\\) (   nebo\u0165 \\(\\lvert S \\rvert \\geq 1\\)) a d\u00e9lky podposloupnost\u00ed by v rekurzi exponenci\u00e1ln\u011b rychle klesaly.</li> <li>Pokud bychom medi\u00e1n dok\u00e1zali naj\u00edt v line\u00e1rn\u00edm \u010dase, bude \u010das:</li> </ul> </li> </ul> </li> </ul> \\[\\Theta(n) + \\Theta(n/2) + \\Theta(n/4) + \\cdots + \\Theta(1) = \\Theta(n).\\] <ul> <li> <p>K tomuto ide\u00e1ln\u00edmu \u0159e\u0161en\u00ed se m\u016f\u017eeme p\u0159ibl\u00ed\u017eit tak, \u017ee m\u00edsto medi\u00e1nu pou\u017eijeme tzv. skoromedi\u00e1n.</p> <ul> <li>Skoromedi\u00e1n je prvek, kter\u00fd le\u017e\u00ed kdekoli v prost\u0159edn\u00edch dvou \u010dtvrtin\u00e1ch se\u0159azen\u00e9 posloupnosti.</li> <li>Skoromedi\u00e1n bude tedy m\u00edt nalevo i napravo v\u017edy nejv\u00fd\u0161e \\(\\frac{3}{4} \\cdot n\\) prvk\u016f.</li> <li>Velikost vstupu bude tedy i v nejhor\u0161\u00edm p\u0159\u00edpad\u011b op\u011bt exponenci\u00e1ln\u011b klesat, by\u0165 pomaleji:   \\(O(n) + O\\left(\\frac{3}{4} \\cdot n\\right) + O\\left(\\left(\\frac{3}{4}\\right)^2 \\cdot n\\right) + \\cdots + O(1),\\)   co\u017e je op\u011bt geometrick\u00e1 \u0159ada se sou\u010dtem \\(O(n)\\).</li> </ul> </li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#jak-hledat-skoromedian","title":"Jak hledat skoromedi\u00e1n?","text":"<ul> <li>Pro libovolnou vstupn\u00ed posloupnost plat\u00ed z definice, \u017ee nejm\u00e9n\u011b   polovina jej\u00edch prvk\u016f jsou skoromedi\u00e1ny, viz mal\u00fd p\u0159\u00edklad n\u00ed\u017ee.</li> </ul> <ul> <li>Pokud budeme pivota vyb\u00edrat n\u00e1hodn\u011b, je pravd\u011bpodobnost   v\u00fdb\u011bru skoromedi\u00e1nu nejm\u00e9n\u011b 1/2.</li> <li>Pro ov\u011b\u0159en\u00ed, \u017ee n\u00e1hodn\u011b vybran\u00fd prvek je skoromedi\u00e1n, je t\u0159eba   celou posloupnost proj\u00edt, tedy line\u00e1rn\u00ed \u010das.</li> <li>Dost\u00e1v\u00e1me tak hezkou uk\u00e1zku u\u017eite\u010dn\u00e9 a efektivn\u00ed randomizace   algoritmu.</li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#popis-quickselectu-s-nahodnym-vyberem-pivota","title":"Popis QuickSelectu s n\u00e1hodn\u00fdm v\u00fdb\u011brem pivota","text":"<ul> <li>Nalezneme skoromedi\u00e1n nese\u0159azen\u00e9 posloupnosti \\(n\\) prvk\u016f:     1) Vybereme rovnom\u011brn\u011b n\u00e1hodn\u011b jeden z prvk\u016f posloupnosti        (\\(O(1)\\) \u010das).     2) Ov\u011b\u0159\u00edme, je-li vybran\u00fd prvek skoromedi\u00e1n (\\(\u0398(n)\\) \u010das).     3) Pokud ne, cel\u00fd postup opakujeme.</li> <li>Proto\u017ee pravd\u011bpodobnost, \u017ee se n\u00e1hodn\u00fdm v\u00fdb\u011brem stref\u00edme do   skoromedi\u00e1nu, je nejm\u00e9n\u011b \\(1/2\\), pot\u0159ebujeme k nalezen\u00ed   skoromedi\u00e1nu ve st\u0159edn\u00ed hodnot\u011b \\(2\\) pokusy.</li> <li>To vypl\u00fdv\u00e1 z V\u011bty o opakov\u00e1n\u00ed nez\u00e1visl\u00fdch pokus\u016f z minul\u00e9   p\u0159edn\u00e1\u0161ky: Uva\u017eujme s\u00e9rii nez\u00e1visl\u00fdch pokus\u016f, ve kter\u00fdch   sledujeme, zda nastal n\u011bjak\u00fd jev \\(J\\). Pravd\u011bpodobnost, \u017ee   nastane, je v ka\u017ed\u00e9m pokusu rovna \\(p\\). Pak po\u0159ad\u00ed pokusu, ve   kter\u00e9m jev \\(J\\) nastal poprv\u00e9, je ve st\u0159edn\u00ed hodnot\u011b \\(1/p\\).</li> <li>Po\u010det pokus\u016f v nejhor\u0161\u00edm p\u0159\u00edpad\u011b samoz\u0159ejm\u011b neum\u00edme nijak   omezit, ale pravd\u011bpodobnost, \u017ee se do skoromedi\u00e1nu nebudeme   opakovan\u011b strefovat, bude s po\u010dtem pokus\u016f klesat k nule.</li> </ul> <p>8.5 RandomQuickSelect</p> RandomQuickSelect(x1, . . . , xn; k):<pre><code>Pokud n = 1: vra\u0165 x1 a skon\u010di\np := xrandom(1,n) //pivot\n    Pokud p nen\u00ed skoromedi\u00e1n v x1, . . . , xn:\njdi zp\u011bt na \u0159\u00e1dek (2)\nL := prvky z x1, . . . , xn, kter\u00e9 jsou men\u0161\u00ed ne\u017e p\nS := prvky z x1, . . . , xn, kter\u00e9 jsou rovny p\nP := prvky z x1, . . . , xn, kter\u00e9 jsou v\u011bt\u0161\u00ed ne\u017e p\nPokud k \u2264 |L|: vra\u0165 RandomQuickSelect(L, k)\nJinak pokud k \u2264 |L| + |S|: vra\u0165 p\nJinak: vra\u0165 RandomQuickSelect(P, k \u2212 |L| \u2212 |S|)\n</code></pre>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#casova-slozitost-randomquickselect","title":"\u010casov\u00e1 slo\u017eitost RandomQuickSelect","text":"<p>V\u011bta 8.5 \u010casov\u00e1 slo\u017eitost RandomQuickSelect</p> D\u016fkaz V\u011bty 8.5 <ul> <li>Rozd\u011bl\u00edme b\u011bh algoritmu RandomQuickSelect na f\u00e1ze podle hloubky rekurze.</li> <li>V ka\u017ed\u00e9 f\u00e1zi zvol\u00edme n\u00e1hodn\u011b pivota, co\u017e zahrnuje ov\u011b\u0159en\u00ed v line\u00e1rn\u00edm \u010dase, \u017ee se jedn\u00e1 o skoromedi\u00e1n. Pak provedeme v line\u00e1rn\u00edm \u010dase rozd\u011blen\u00ed na \\(L, S, P\\) a pokud neskon\u010d\u00edme, p\u0159ejdeme do dal\u0161\u00ed rekurzivn\u00ed f\u00e1ze s \\(L\\) nebo \\(P\\) na vstupu.</li> <li>B\u011bhem ka\u017ed\u00e9 f\u00e1ze se vstup zmen\u0161\u00ed nejm\u00e9n\u011b o \u010dtvrtinu.</li> <li>V \\(i\\)-t\u00e9 f\u00e1zi je tedy na vstupu nejv\u00fd\u0161e \\((3/4)^{i-1} n\\) prvk\u016f.</li> <li>Definujme n\u00e1hodnou veli\u010dinu \\(T_i = \\text{po\u010det v\u00fdpo\u010detn\u00edch operac\u00ed (p\u0159esun\u016f, porovn\u00e1n\u00ed, atp)}\\) \\(i\\)-t\u00e9 f\u00e1ze.</li> <li> <p>Pak plat\u00ed:      \\(E[T_i] \u2264 (3/4)^{i\u22121} \u0398(n)\u00b7E\\)[# pokus\u016f k nalezen\u00ed skoromedi\u00e1nu]     \\(\u2264 (3/4)^{i\u22121} \u0398(n)\u00b72\\).</p> </li> <li> <p>N\u00e1hodn\u00e1 veli\u010dina celkov\u00e9ho po\u010dtu operac\u00ed algoritmu \\(T\\) je tedy: \\(T = T_1 + T_2 + \\cdots + T_\\ell\\), kde \\(\\ell = \\Theta(\\log n)\\).</p> </li> <li> <p>Vyu\u017eit\u00edm linearity st\u0159edn\u00ed hodnoty: \\(E[T] = E[T_1 + \\cdots + T_\\ell] = E[T_1] + \\cdots + E[T_\\ell] \\leq \\sum_{i=1}^\\ell (3/4)^{i-1} \\Theta(n) = \\Theta(n)\\).</p> </li> <li> <p>Tedy i v nejhor\u0161\u00edm p\u0159\u00edpad\u011b skoromedi\u00e1nu na hranic\u00edch vnit\u0159n\u00edch dvou \u010dtvrtin vstupn\u00ed posloupnosti je st\u0159edn\u00ed hodnota po\u010dtu v\u00fdpo\u010detn\u00edch operac\u00ed \\(O(n)\\), co\u017e je optim\u00e1ln\u00ed slo\u017eitost.</p> </li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#theorem-8.5","title":"\u010casov\u00e1 slo\u017eitost RandomQuickSelect","text":"<p>St\u0159edn\u00ed hodnota po\u010dtu v\u00fdpo\u010detn\u00edch operac\u00ed vykonan\u00fdch algoritmem RandomQuickSelect\\((x_1, . . . , x_n; k)\\) s n\u00e1hodn\u00fdm v\u00fdb\u011brem pivota je \\(O(n)\\).</p>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#dva-pristupy-k-randomizaci-quickselectu","title":"Dva p\u0159\u00edstupy k randomizaci QuickSelectu","text":"<ul> <li>Algoritmus RandomQuickSelect poskytuje ve st\u0159edn\u00ed hodnot\u011b   optim\u00e1ln\u00ed \u010dasovou slo\u017eitost pro libovoln\u00e9 vstupn\u00ed posloupnosti   t\u00edm, \u017ee pivot se vyb\u00edr\u00e1 n\u00e1hodn\u011b a p\u0159i tom o vstupn\u00ed   posloupnosti nic nep\u0159edpokl\u00e1d\u00e1me.</li> <li>Uva\u017eme obr\u00e1cen\u00fd p\u0159\u00edstup: P\u0159edpokl\u00e1dejme, \u017ee jako pivota v\u017edy   vol\u00edme deterministicky prvek na fixn\u00ed (nap\u0159. prvn\u00ed) pozici, ale   \u017ee vstupn\u00ed pole jsou dokonale n\u00e1hodn\u00e9 posloupnosti, \u010dili ka\u017ed\u00e1   permutace bude vstupem s pravd\u011bpodobnost\u00ed \\(1/n!\\).</li> <li>Pr\u016fm\u011brn\u00e1 \u010dasov\u00e1 slo\u017eitost QuickSelectu bude pr\u016fm\u011brem   \u010dasov\u00fdch slo\u017eitost\u00ed b\u011bhu algoritmu p\u0159es v\u0161ech \\(n!\\) vstup\u016f.</li> <li>Pro praktickou implementaci bychom pot\u0159ebovali um\u011bt dokonale   n\u00e1hodn\u011b permutovat vstupn\u00ed posloupnosti. To zde pops\u00e1no   nebude.</li> <li>Nazna\u010d\u00edme si te\u010f d\u016fkaz, \u017ee takto definovan\u00e1 slo\u017eitost je op\u011bt   \\(O(n)\\).</li> </ul> <p>V\u011bta 8.6</p> Hlavn\u00ed my\u0161lenka d\u016fkazu V\u011bty 8.6 <ul> <li>Vzhledem k n\u00e1hodnosti vstupu je prvn\u00ed prvek rovnom\u011brn\u011b n\u00e1hodn\u011b vybran\u00e9 \u010d\u00edslo z mno\u017einy \\({1, 2, . . . , n}\\).</li> <li>S pravd\u011bpodobnost\u00ed \\(1/2\\) se tedy tref\u00edme do skoromedi\u00e1nu vstupu.</li> <li>Po rozd\u011blen\u00ed vstupu na levou a pravou \u010d\u00e1st budou ob\u011b \u010d\u00e1sti op\u011bt n\u00e1hodn\u00e9 permutace, na nich\u017e se algoritmus chov\u00e1 stejn\u011b.</li> <li>Lze tedy pou\u017e\u00edt stejnou anal\u00fdzu jako u RandomQuickSelectu s t\u00edm rozd\u00edlem, \u017ee hloubka zano\u0159en\u00ed rekurze bude ve st\u0159edn\u00ed hodnot\u011b dvojn\u00e1sobn\u00e1 a v pr\u016fm\u011bru ka\u017ed\u00e9 dv\u011b hladiny sn\u00ed\u017e\u00ed velikost probl\u00e9mu na aspo\u0148 \\(3/4\\) p\u0159edchoz\u00ed.</li> </ul>"},{"location":"08_Rozd%C4%9Bl_a_Panuj/8.5_QuickSelect/#theorem-8.6","title":"Deterministick\u00fd QuickSelect s n\u00e1hodn\u00fdmi vstupy","text":"<p>Uva\u017eujme na vstupu rovnom\u011brn\u011b n\u00e1hodnou permutaci \\({1, . . . , n}\\). Jako pivota vol\u00edme prvek na prvn\u00ed pozici. Potom st\u0159edn\u00ed hodnota po\u010dtu operac\u00ed vykonan\u00fdch p\u0159i jednom b\u011bhu algoritmu je \\(O(n)\\).</p>"},{"location":"09_Quicksort/9.1_Quicksort/","title":"9.1 Quicksort","text":"<p>QuickSort je \u0159ad\u00edc\u00ed algoritmus zalo\u017een\u00fd na podobn\u00e9 my\u0161lence jako QuickSelect:</p> <ol> <li>Vybereme pivota a rozd\u011bl\u00edme vstup na levou \\(L\\) (prvky men\u0161\u00ed ne\u017e pivot), st\u0159edn\u00ed \\(S\\) (prvky rovn\u00e9 pivotu) a pravou \\(P\\) \u010d\u00e1st (prvky v\u011bt\u0161\u00ed ne\u017e pivot).</li> <li>V se\u0159azen\u00e9 posloupnosti budou vystupovat nejd\u0159\u00edve prvky z \\(L\\), pak ty z \\(S\\) a nakonec prvky z \\(P\\)</li> <li>Rekurzivn\u011b tedy se\u0159ad\u00edme levou \\(L\\) a pravou \\(P\\) \u010d\u00e1st (st\u0159edn\u00ed \\(S\\) je sama od sebe se\u0159azen\u00e1).</li> <li>V\u00fdsledn\u00e1 posloupnost vznikne spojen\u00edm \\(L\\), \\(S\\) a \\(P\\) za sebou </li> </ol> <p></p> <p>Algoritmus 9.1 (Quicksort)</p>"},{"location":"09_Quicksort/9.1_Quicksort/#algoritmus-quicksort","title":"Algoritmus Quicksort","text":"QuickSort(X = x1, . . . , xn)<pre><code>Pokud n \u2264 1: vra\u0165 X a skon\u010di\np := n\u011bkter\u00fd z prvk\u016f x1, . . . , xn //pivot\nL := prvky v X, kter\u00e9 jsou men\u0161\u00ed ne\u017e p\nS := prvky v X, kter\u00e9 jsou rovny p\nP := prvky v X, kter\u00e9 jsou v\u011bt\u0161\u00ed ne\u017e p\nL := QuickSort(L) //rekurzivn\u011b se\u0159a\u010f \u010d\u00e1st L\nP := QuickSort(P) //rekurzivn\u011b se\u0159a\u010f \u010d\u00e1st P\nY := L, S, P //spoj \u010d\u00e1sti za sebe\nVra\u0165 Y\n</code></pre>"},{"location":"09_Quicksort/9.1_Quicksort/#strom-rekurzivnich-volani-srv-quicksortu","title":"Strom rekurzivn\u00edch vol\u00e1n\u00ed (SRV) QuickSortu","text":"<ol> <li>V ko\u0159eni SRV m\u00e1me celou posloupnost \\(n\\) prvk\u016f, na prvn\u00ed hladin\u011b jej\u00ed levou a pravou \u010d\u00e1st, na druh\u00e9 hladin\u011b lev\u00e9 a prav\u00e9 \u010d\u00e1sti t\u011bchto \u010d\u00e1st\u00ed, a tak d\u00e1le, a\u017e v listech trivi\u00e1ln\u00ed posloupnosti d\u00e9lky \\(1\\)</li> <li>Sou\u010det velikost\u00ed v\u0161ech podprobl\u00e9m\u016f v libovoln\u00e9 hladin\u011b SRV je tedy nejv\u00fd\u0161e \\(n\\)</li> <li>Rozkl\u00e1d\u00e1n\u00ed vstupu i spojov\u00e1n\u00ed \u010d\u00e1st\u00ed jsou operace v line\u00e1rn\u00edm \u010dase.</li> <li>V ka\u017ed\u00e9m vrcholu SRV str\u00e1v\u00ed algoritmus \u010das \u00fam\u011brn\u00fd velikosti p\u0159\u00edslu\u0161n\u00e9ho podprobl\u00e9mu.</li> <li>Na jedn\u00e9 hladin\u011b SRV proto algoritmus str\u00e1v\u00ed \u010das \\(O(n)\\)</li> </ol>"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/","title":"9.2 Slo\u017eitost quicksortu","text":""},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#i-spravna-volba-pivotu","title":"I. Spr\u00e1vn\u00e1 volba pivotu","text":"<p>Pokud za pivoty vol\u00edme medi\u00e1ny nebo alespo\u0148 skoromedi\u00e1ny, pak:</p> <ul> <li>Velikosti podprobl\u00e9m\u016f klesaj\u00ed exponenci\u00e1ln\u011b: na \\(i\\)-t\u00e9 hladin\u011b SRV je velikost v\u011bt\u0161\u00edho z \\(L \\text{ , } P\\) nejv\u00fd\u0161e \\((\\frac{3}{4})^{i} \u00b7 n\\)</li> <li>SRV m\u00e1 tud\u00ed\u017e hloubku \\(O(log_{\\frac{4}{3}} n) = O (logn)\\)</li> <li>V sou\u010dtu p\u0159es v\u0161echny hladiny proto \u010dasov\u00e1 slo\u017eitost \u010din\u00ed \\(O(n log n)\\)</li> </ul> <p></p> <p>Slo\u017eitost p\u0159i spr\u00e1vn\u00e9 volb\u011b pivotu</p>"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#ii-spatna-volba-pivotu","title":"II. \u0160patn\u00e1 volba pivotu","text":"<p>Jestli\u017ee naopak vol\u00edme t\u00edm nejhor\u0161\u00edm zp\u016fsobem, nap\u0159. jako minima podposloupnost\u00ed na ka\u017ed\u00e9 hladin\u011b SRV, pak:</p> <ul> <li>Se na ka\u017ed\u00e9 hladin\u011b odd\u011bl\u00ed od vstupu jen \u00fasek o jednom prvku</li> <li>Hladin bude \\(\\Theta (n)\\)</li> <li>To povede na kvadratickou \u010dasovou slo\u017eitost.</li> </ul> <p></p> <p>Slo\u017eitost p\u0159i \u0161patn\u00e9 volb\u011b pivotu</p>"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#analyza-casove-slozitosti-quicksortu-s-nahodnou-volbou-pivota","title":"Anal\u00fdza \u010dasov\u00e9 slo\u017eitosti QuickSortu s n\u00e1hodnou volbou pivota","text":"<ul> <li>Zanalyzujeme nyn\u00ed variantu QuickSortu, ve kter\u00e9 budeme v ka\u017ed\u00e9 f\u00e1zi volit pivota n\u00e1hodn\u011b jako jeden z prvk\u016f na vstupu.</li> <li>To ud\u011bl\u00e1me podobn\u011b jako u QuickSelectu</li> </ul> <p>Pozorov\u00e1n\u00ed</p> <p>QuickSort porovn\u00e1 jednu dvojici prvk\u016f nejv\u00fd\u0161e jednou. Na ka\u017ed\u00e9 porovn\u00e1n\u00ed provede QuickSort pouze \\(O(1)\\) dal\u0161\u00edch operac\u00ed. Proto pro \u0159\u00e1dov\u00fd odhad jeho slo\u017eitosti posta\u010d\u00ed odhadnout po\u010det proveden\u00fdch porovn\u00e1n\u00ed.</p> <p></p> <p>V\u011bta 9.1 (o slo\u017eitosti QuickSortu s n\u00e1hodnou volbou pivota)</p> <p></p> <p>Definice 9.1 (Indik\u00e1tory)</p> <p>P\u0159\u00edklad</p> <p>Vezm\u011bme n\u00e1hodn\u00e9 \\(b\\)-bitov\u00e9 bin\u00e1rn\u00ed \u010d\u00edslo. Pro \\(i\\)-t\u00fd bit zavedeme n\u00e1hodnou prom\u011bnnou \\(X_{i}\\), nab\u00fdvaj\u00edc\u00ed hodnoty tohoto bitu.</p> <p>Potom \\(E[X_{i}] = \\frac{1}{2}\\) a \\(E[X] = E[X_{1} + \u00b7 \u00b7 \u00b7 + X_{b}] = \\frac{b}{2}\\)</p> <p>Lemma (sou\u010det harmonick\u00e9 \u0159ady)</p> <p>Pro sou\u010det harmonick\u00e9 \u0159ady \\(H_{n} = \\frac{1}{1} + \\frac{1}{2} + \u00b7 \u00b7 \u00b7 + \\frac{1}{n}\\) plat\u00ed \\(H_{n} = \\Theta(log n)\\)</p> D\u016fkaz (viz. BI-MA1) \\[ \\frac{1}{n} + ln(n) \\leq \\sum_{k=1}^{n}{\\frac{1}{k}} \\leq 1 + ln(n) \\] <p>a v\u00edme, \u017ee \\(ln(n) = \\Theta(log n)\\).</p>"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#theorem-9.1","title":"V\u011bta o slo\u017eitosti QuickSortu s n\u00e1hodnou volbou pivota","text":"<p>St\u0159edn\u00ed hodnota \u010dasov\u00e9 slo\u017eitosti QuickSortu s rovnom\u011brn\u011b n\u00e1hodnou volbou pivota je \\(O(n log n)\\)</p>"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#definition-9.1","title":"Indik\u00e1tory","text":"<p>N\u00e1hodn\u00fdm veli\u010din\u00e1m, kter\u00e9 nab\u00fdvaj\u00ed hodnoty 0 nebo 1 podle toho, zda n\u011bjak\u00e1 ud\u00e1lost nastala, se obvykle \u0159\u00edk\u00e1 indik\u00e1tory.</p> <p>Pro st\u0159edn\u00ed hodnotu indik\u00e1toru \\(X\\) tedy plat\u00ed:</p> \\[ EX = 0 \u00b7 P[X = 0] + 1 \u00b7 P[X = 1] = P[X = 1] \\]"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#dukaz-vety-o-analyze-quicksortu-shrnuti","title":"D\u016fkaz v\u011bty o anal\u00fdze QuickSortu \u2013 shrnut\u00ed","text":"<ul> <li>Vstupn\u00ed posloupnost \\(X = x_{1}, x_{2}, . . . , x_{n}\\)</li> <li>V\u00fdstupn\u00ed posloupnost \\(Y = y_{1}, . . . , y_{n}\\) - tedy se\u0159azen\u00e1 posloupnost</li> </ul> <p>Budeme ur\u010dovat st\u0159edn\u00ed po\u010det porovn\u00e1n\u00ed v pr\u016fb\u011bhu Quicksort</p> <ul> <li>Proto\u017ee pivota vol\u00edme n\u00e1hodn\u011b, je porovn\u00e1n\u00ed \\(y_{i}\\) s \\(y_{j}\\) n\u00e1hodn\u00fd jev. Pro \\(1 \\leq i \\lt j \\leq n\\) zavedeme n\u00e1hodn\u00e9 veli\u010diny \\(C_{ij}\\) takto:</li> </ul> \\[ C_{ij} = \\begin{cases}  1 &amp; \\text{pokud b\u011bhem \u0159azen\u00ed do\u0161lo k porovn\u00e1n\u00ed } y_{i} \\text{ s } y_{j} \\\\ 0 &amp; \\text{jinak}   \\end{cases} \\] <p>Pot\u00e9 ur\u010d\u00edme, \u017ee: </p> \\[ P[C_{ij} = 1] = \\frac{2}{(j \u2212 i + 1)} \\text{ a} \\] \\[ E[C] = E[ \\sum_{1 \\leq i \\lt j \\leq n}^{n}{ C_{ij}} ] = O(n log n) \\] <p>T\u00edm bude d\u016fkaz hotov.</p> <p>Lemma</p> <p>Pro \\(1 \\leq i \\lt j \\leq n\\) plat\u00ed \\(E[C_{ij} ] = P[Cij = 1] = \\frac{2}{(j \u2212 i + 1)}\\)</p> D\u016fkaz <ol> <li>Ur\u010deme pravd\u011bpodobnost porovn\u00e1n\u00ed \\(y_{i}\\) s \\(y_{j}\\) , \u010dili \\(P[C_{ij} = 1]\\)</li> <li>QuickSort porovn\u00e1v\u00e1 prvky pouze s pivotem, tak\u017ee jeden z prvk\u016f \\(y_{i}\\), \\(y_{j}\\) se t\u011bsn\u011b p\u0159ed porovn\u00e1n\u00edm mus\u00ed st\u00e1t pivotem.</li> <li>Sou\u010dasn\u011b ale \u017e\u00e1dn\u00fd prvek z \\(y_{i+1}, . . . , y_{j\u22121}\\) je\u0161t\u011b pivotem b\u00fdt nemohl, jinak by \\(y_{i}\\) a \\(y_{j}\\) pat\u0159ily do r\u016fzn\u00fdch \u010d\u00e1st\u00ed posloupnosti a nemohly by b\u00fdt porovn\u00e1ny.</li> <li>Jin\u00fdmi slovy, \\(C_{ij} = 1\\) pr\u00e1v\u011b tehdy, kdy\u017e se z prvk\u016f \\(y_{i}, y_{i+1}, . . . , y_{j}\\) stane pivotem jako prvn\u00ed bu\u010f \\(y_{i}\\) nebo \\(y_{j}\\)</li> <li>Proto\u017ee pivota vyb\u00edr\u00e1me n\u00e1hodn\u011b, m\u016f\u017ee b\u00fdt ka\u017ed\u00fd z prvk\u016f \\(y_{i}, . . . , y_{j}\\) vybr\u00e1n se stejnou pravd\u011bpodobnost\u00ed \\(\\frac{1}{(j \u2212 i + 1)}\\)</li> <li>Proto \\(P[C_{ij} = 1] = \\frac{2}{(j \u2212 i + 1)}\\)</li> </ol> <p></p> <p>D\u016fkaz v\u011bty o anal\u00fdze QuickSortu</p>"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#proof-9.1","title":"D\u016fkaz v\u011bty o anal\u00fdze QuickSortu","text":"<p>Definujme n\u00e1hodnou veli\u010dinu \\(C\\) jako celkov\u00fd po\u010det v\u0161ech porovn\u00e1n\u00ed proveden\u00fdch b\u011bhem b\u011bhu QuickSortu </p> <p>Pak \\(C = \\sum_{1 \\leq i \\lt j \\leq n}{C_{ij}}\\)</p> <p>Pro st\u0159edn\u00ed hodnotu celkov\u00e9ho po\u010dtu porovn\u00e1n\u00ed proveden\u00fdch b\u011bhem b\u011bhu QuickSortu tak dostaneme: </p> \\[ E[C] = \\sum_{1 \\leq i \\lt j \\leq n}{\\frac{2}{j - i + 1}} = 2 \\sum_{d=1}^{n-1}{} \\sum_{i=1}^{n-d}{\\frac{1}{d+1}} \\] <p>substituc\u00ed \\(j \u2212 i = d\\), \u010dili \\(1 \\leq d \\leq n \u2212 1, i \\geq 1\\) a \\(i \\leq n \u2212 d\\), a tedy:</p> \\[ E[C] \\lt 2 \\sum_{d=1}^{n-1}{} \\sum_{i=1}^{n-1}{\\frac{1}{d+1}} = 2(n-1) \\cdot \\sum_{d=1}^{n-1}{\\frac{1}{d+1}} &lt; 2n \\cdot \\sum_{d^{'} = 2}^{n}{\\frac{1}{d^{'}}} \\] <p>Na odhad posledn\u00ed sumy nyn\u00ed pou\u017eijeme lemma o sou\u010dtu harmonick\u00e9 \u0159ady, tedy:</p> \\[ E[C] \\lt 2n \\cdot \\Theta (log n) = O(n \\cdot log n) \\]"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#slozitost-quicksortu-v-prumeru-pres-vstupy","title":"Slo\u017eitost QuickSortu v pr\u016fm\u011bru p\u0159es vstupy","text":"<ul> <li>Pokud se bere pivot z pevn\u00e9 pozice (nap\u0159. prost\u0159edn\u00ed prvek), nen\u00ed QuickSort odoln\u00fd proti zlomysln\u00e9mu u\u017eivateli, kter\u00fd um\u00ed konstruovat vstupn\u00ed posloupnosti, kde na tyto pozice d\u00e1v\u00e1 nejhor\u0161\u00ed pivoty (nap\u0159. minima) a vnut\u00ed kvadratickou slo\u017eitost.</li> <li>Bez d\u016fkazu uve\u010fme, \u017ee i pro pevnou volbu pivota je ale \"\u0161patn\u00fdch\" vstup\u016f (vedouc\u00edch na \\(\\omega (n \\cdot log n)\\) slo\u017eitost) m\u00e1lo</li> <li>Ji\u017e jsme si vysv\u011btlili, \u017ee tomu se vyhneme n\u00e1hodnou volbou pivota, tedy randomizac\u00ed</li> <li>Stejn\u011b jako v minul\u00e9 p\u0159edn\u00e1\u0161ce u QuickSelectu, m\u016f\u017eeme i pro QuickSort zav\u00e9st slo\u017eitost v pr\u016fm\u011bru p\u0159es vstupy</li> <li>QuickSort bude deterministicky vyb\u00edrat pivota z pevn\u00e9 pozice.</li> <li>Na vstup mu ale budeme d\u00e1vat n\u00e1hodn\u00e9 posloupnosti a budeme po\u010d\u00edtat, jak dlouho v pr\u016fm\u011bru pob\u011b\u017e\u00ed.</li> </ul>"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#deterministicky-quicksort-s-nahodnymi-vstupy","title":"Deterministick\u00fd QuickSort s n\u00e1hodn\u00fdmi vstupy","text":"<p>V\u011bta 9.3 (o st\u0159edn\u00ed hodnot\u011b po\u010dtu operac\u00ed quicksortu)</p> <p>Hlavn\u00ed my\u0161lenka d\u016fkazu</p> <p>Vzhledem k n\u00e1hodnosti vstupu je prost\u0159edn\u00ed prvek rovnom\u011brn\u011b n\u00e1hodn\u011b vybran\u00e9 \u010d\u00edslo z mno\u017einy \\(\\{1, 2, . . . , n\\}\\) Lze tedy pou\u017e\u00edt obdobnou anal\u00fdzu jako ve V\u011bt\u011b o slo\u017eitosti QuickSortu s n\u00e1hodnou volbou pivota.</p>"},{"location":"09_Quicksort/9.2_Slo%C5%BEitost_quicksortu/#theorem-9.3","title":"V\u011bta o st\u0159edn\u00ed hodnot\u011b po\u010dtu operac\u00ed quicksortu","text":"<p>Uva\u017eujme na vstupu rovnom\u011brn\u011b n\u00e1hodn\u00e9 permutace \\(\\{1, . . . , n\\}\\) Jako pivota vol\u00edme v\u017edy prvek nap\u0159. na prost\u0159edn\u00ed pozici. Potom st\u0159edn\u00ed hodnota po\u010dtu operac\u00ed vykonan\u00fdch p\u0159i jednom b\u011bhu QuickSortu je \\(O(n \\cdot log n)\\)</p>"},{"location":"09_Quicksort/9.3_Doln%C3%AD_meze_vyhled%C3%A1v%C3%A1n%C3%AD/","title":"9.3 Doln\u00ed meze vyhled\u00e1v\u00e1n\u00ed","text":"<ul> <li>Nach\u00e1zen\u00ed doln\u00edch mez\u00ed slo\u017eitosti r\u016fzn\u00fdch probl\u00e9m\u016f jsou obecn\u011b obt\u00ed\u017en\u00e1.</li> <li> <p>Doln\u00ed meze slo\u017eitosti si v t\u00e9to p\u0159edn\u00e1\u0161ce uk\u00e1\u017eeme na dvou probl\u00e9mech:</p> <ul> <li>probl\u00e9m vyhled\u00e1v\u00e1n\u00ed v se\u0159azen\u00e9 \u010d\u00edseln\u00e9 posloupnosti a</li> <li>probl\u00e9m \u0159azen\u00ed nese\u0159azen\u00e9 \u010d\u00edseln\u00e9 posloupnosti.</li> </ul> </li> <li> <p>Doln\u00ed meze slo\u017eitosti budeme ur\u010dovat za n\u00e1sleduj\u00edc\u00edch p\u0159edpoklad\u016f:</p> <ul> <li>Algoritmy pracuj\u00ed v porovn\u00e1vac\u00edm modelu RAM, kde sm\u011bj\u00ed vstupn\u00ed prvky pouze vz\u00e1jemn\u011b porovn\u00e1vat a p\u0159\u00edpadn\u011b   p\u0159esouvat.</li> <li>Porovn\u00e1n\u00ed cmp(\\(a_{i}\\), \\(a_{j}\\) ) je bin\u00e1rn\u00ed operace, kter\u00e1 v konstantn\u00edm   \u010dase pro dva prvky \\(a_{i}\\) a \\(a_{j}\\) odpov\u00ed, zda plat\u00ed \\(a_{i} \\lt a_{j}\\) , \\(a_{i} = a_{j}\\)   nebo \\(a_{i} \\gt a_{j}\\)</li> <li>Uva\u017eujeme pouze deterministick\u00e9 algoritmy, kter\u00e9 nepou\u017e\u00edvaj\u00ed   \u017e\u00e1dn\u00fd zdroj n\u00e1hody a jejich\u017e ka\u017ed\u00fd krok je jednozna\u010dn\u011b ur\u010den   v\u00fdsledky krok\u016f p\u0159edchoz\u00edch.</li> </ul> </li> </ul>"},{"location":"09_Quicksort/9.3_Doln%C3%AD_meze_vyhled%C3%A1v%C3%A1n%C3%AD/#dolni-mez-slozitosti-vyhledavani","title":"Doln\u00ed mez slo\u017eitosti vyhled\u00e1v\u00e1n\u00ed","text":"<p>Definice 9.2 (Probl\u00e9m vyhled\u00e1v\u00e1n\u00ed v se\u0159azen\u00e9 posloupnosti)</p> <p></p> <p>V\u011bta 9.4 (o slo\u017eitosti vyhled\u00e1v\u00e1n\u00ed)</p> <p>Jin\u00fdmi slovy: \u017e\u00e1dn\u00fd deterministick\u00fd algoritmus v porovn\u00e1vac\u00edm modelu RAM nem\u016f\u017ee v nejhor\u0161\u00edm p\u0159\u00edpad\u011b nal\u00e9zt dan\u00e9 \u010d\u00edslo v \\(n\\)-prvkov\u00e9 se\u0159azen\u00e9 posloupnosti pou\u017eit\u00edm \\(o(log n)\\) operac\u00ed porovn\u00e1n\u00ed. To ale znamen\u00e1, \u017ee zn\u00e1m\u00e9 bin\u00e1rn\u00ed vyhled\u00e1v\u00e1n\u00ed s \\(O(log n)\\) srovn\u00e1n\u00edmi je optim\u00e1ln\u00ed algoritmus pro vyhled\u00e1v\u00e1n\u00ed.</p> D\u016fkaz v\u011bty 9.4 <ol> <li>Dok\u00e1\u017eeme, \u017ee pro libovoln\u00fd deterministick\u00fd vyhled\u00e1vac\u00ed algoritmus \\(S\\) a pro libovoln\u00e9 n a pro libovolnou vstupn\u00ed vzestupn\u011b se\u0159azenou posloupnost  \\(A = a_{1} \\lt a_{2} \\lt \u00b7 \u00b7 \u00b7 \\lt a_{n}\\) existuje \\(x\\) takov\u00e9, \u017ee algoritmus \\(S\\) p\u0159i hled\u00e1n\u00ed \\(x\\) v posloupnosti \\(A\\) provede \\(\\Omega (log n)\\) porovn\u00e1n\u00ed.</li> <li>Prvn\u00ed porovn\u00e1n\u00ed, kter\u00e9 algoritmus \\(S\\) se vstupem \\(A\\) provede, bude v\u017edy stejn\u00e9, nebo\u0165 je deterministick\u00fd.</li> <li>Porovn\u00e1n\u00ed typu cmp(\\(a_{i}\\), \\(a_{j}\\) ) dopadne tak\u00e9 v\u017edy stejn\u011b. </li> <li>A\u017e prvn\u00ed porovn\u00e1n\u00ed typu cmp(\\(x\\), \\(a_{i}\\)) m\u016f\u017ee pro r\u016fzn\u00e1 vstupn\u00ed \\(x\\) dopadnout r\u016fzn\u011b.</li> <li>Pro ka\u017ed\u00fd z mo\u017en\u00fdch v\u00fdsledk\u016f tohoto porovn\u00e1n\u00ed pokra\u010duje \\(S\\) deterministicky, tak\u017ee algoritmem \\(S\\) je pevn\u011b d\u00e1no, kter\u00e9 dal\u0161\u00ed porovn\u00e1n\u00ed se provede.</li> <li>A tak d\u00e1le, a\u017e se \\(S\\) zastav\u00ed s v\u00fdsledkem bu\u010f \\(x \\in A\\) nebo \\(x \\notin A\\)</li> <li> <p>Proto\u017ee \\(S\\) je deterministick\u00fd algoritmus, m\u016f\u017eeme jeho proveden\u00ed se vstupem \\(A\\) pro v\u0161echna mo\u017en\u00e1 \\(x\\) popsat takzvan\u00fdm rozhodovac\u00edm stromem \\(T_{S,A}\\)</p> <ul> <li>Ka\u017ed\u00fd vnit\u0159n\u00ed vrchol rozhodovac\u00edho stromu \\(T_{S,A}\\) je porovn\u00e1n\u00ed typu cmp(\\(x\\), \\(a_{i}\\)) a m\u00e1 tedy obecn\u011b t\u0159i syny, kte\u0159\u00ed odpov\u00eddaj\u00ed mo\u017en\u00fdm v\u00fdsledk\u016fm tohoto porovn\u00e1n\u00ed (&lt;, =, &gt;).</li> <li>M\u016f\u017ee se st\u00e1t, \u017ee n\u011bkter\u00fd z v\u00fdsledk\u016f nem\u016f\u017ee vzniknout, proto\u017ee by byl ve sporu s d\u0159\u00edve proveden\u00fdmi porovn\u00e1n\u00edmi. V takov\u00e9m p\u0159\u00edpad\u011b p\u0159\u00edslu\u0161n\u00fd syn neexistuje (je pr\u00e1zdn\u00fd).</li> <li>V listech \\(T_{S,A}\\) jsou jednotliv\u00e9 v\u00fdsledky hled\u00e1n\u00ed: bu\u010f pozice v \\(A\\), na kter\u00e9 se \\(x\\) vyskytuje, nebo odpov\u011b\u010f, \u017ee \\(x\\) v \\(A\\) neexistuje. Ka\u017ed\u00e9 mo\u017en\u00e9 proveden\u00ed algoritmu \\(S\\) se vstupem \\(A\\) pro n\u011bjak\u00e9 \\(x\\) odpov\u00edd\u00e1 n\u011bjak\u00e9 cest\u011b z ko\u0159ene \\(T_{S,A}\\) do listu.</li> </ul> </li> <li> <p>Rozhodovac\u00ed strom \\(T_{S,A}\\) je tedy tern\u00e1rn\u00ed (vrcholy maj\u00ed nejv\u00fd\u0161e 3 syny) s nejm\u00e9n\u011b \\(n + 1\\) listy (lze dok\u00e1zat, \u017ee m\u00e1 alespo\u0148 \\(2n + 1\\) list\u016f, ale my si vysta\u010d\u00edme s \\(n + 1\\) listy).</p> </li> <li>Proto\u017ee ka\u017ed\u00fd tern\u00e1rn\u00ed strom hloubky \\(h\\) m\u00e1 nejv\u00fd\u0161e \\(3^{h}\\) list\u016f, m\u00e1 \\(T_{S,A}\\) hloubku nejm\u00e9n\u011b \\(log_{3}n\\).</li> <li>V \\(T_{S,A}\\) tedy existuje cesta d\u00e9lky nejm\u00e9n\u011b \\(log_{3}n\\) a proto existuje \\(x\\), kter\u00e9 t\u00e9to cest\u011b odpov\u00edd\u00e1.</li> <li>A takov\u00e9 \\(x\\) \u201edonut\u00ed\u201c \\(S\\) vykonat nejm\u00e9n\u011b \\(log_{3}n\\) porovn\u00e1n\u00ed</li> </ol> <p></p> <p>P\u0159\u00edklad rozhodovac\u00edho strom \\(T_{S,A}\\) pro n\u011bjak\u00fd algoritmus \\(S\\) a n\u011bjak\u00fd vstup \\(A\\) d\u00e9lky \\(n = 3\\)</p>"},{"location":"09_Quicksort/9.3_Doln%C3%AD_meze_vyhled%C3%A1v%C3%A1n%C3%AD/#definition-9.2","title":"Probl\u00e9m vyhled\u00e1v\u00e1n\u00ed v se\u0159azen\u00e9 posloupnosti","text":"<ul> <li>Vstupem algoritmu je \u010d\u00edslo \\(n\\), vzestupn\u011b se\u0159azen\u00e1 posloupnost \\(A\\) \\(n\\) \u010d\u00edsel \\(a_{1}, . . . , a_{n}\\) a hledan\u00e9 \u010d\u00edslo \\(x\\)</li> <li>\u00dakolem algoritmu je zjistit, zda se \\(x\\) vyskytuje v \\(A\\)</li> </ul>"},{"location":"09_Quicksort/9.3_Doln%C3%AD_meze_vyhled%C3%A1v%C3%A1n%C3%AD/#theorem-9.4","title":"V\u011bta o slo\u017eitosti vyhled\u00e1v\u00e1n\u00ed","text":"<p>Ka\u017ed\u00fd deterministick\u00fd algoritmus v porovn\u00e1vac\u00edm modelu RAM, kter\u00fd \u0159e\u0161\u00ed probl\u00e9m vyhled\u00e1v\u00e1n\u00ed v se\u0159azen\u00e9 posloupnosti, pou\u017eije v nejhor\u0161\u00edm p\u0159\u00edpad\u011b \\(\\Omega (log n)\\) porovn\u00e1n\u00ed.</p>"},{"location":"09_Quicksort/9.4_Doln%C3%AD_meze_%C5%99azen%C3%AD/","title":"9.4 Doln\u00ed meze \u0159azen\u00ed","text":""},{"location":"09_Quicksort/9.4_Doln%C3%AD_meze_%C5%99azen%C3%AD/#dolni-mez-slozitosti-razeni-v-porovnavacim-modelu","title":"Doln\u00ed mez slo\u017eitosti \u0159azen\u00ed v porovn\u00e1vac\u00edm modelu","text":"<p>Definice 9.3 (Probl\u00e9m \u0159azen\u00ed)</p> <ul> <li>Podobn\u011b jako u vyhled\u00e1v\u00e1n\u00ed, si v porovn\u00e1vac\u00edm modelu odvod\u00edme t\u011bsnou doln\u00ed mez slo\u017eitosti probl\u00e9mu \u0159azen\u00ed.</li> <li>Tedy asymptoticky nepodkro\u010ditelnou slo\u017eitost \u0159e\u0161en\u00ed, kterou ale n\u011bkter\u00e9 zn\u00e1m\u00e9 algoritmy (HeapSort, MergeSort,   QuickSort) asymptoticky dosahuj\u00ed, a jsou tedy optim\u00e1ln\u00ed</li> </ul> <p></p> <p>Definice 9.4 (Invariant)</p> <p>P\u0159\u00edklad invariantu</p> <pre><code>int i = 0;\nwhile( i &lt; 10 ) {\n    i++;\n}\n// i = 10\n</code></pre> <p>Invariantem zde je podm\u00ednka \\(0 \\le i \\le 10\\)</p>"},{"location":"09_Quicksort/9.4_Doln%C3%AD_meze_%C5%99azen%C3%AD/#def-9.3","title":"Probl\u00e9m \u0159azen\u00ed","text":"<ul> <li>Vstup: \u010c\u00edslo \\(n\\) a posloupnost \u010d\u00edsel \\(A = a_{1}, a_{2}, . . . , a_{n}\\).</li> <li>V\u00fdstup: Takov\u00e1 permutace \\(A^{\u2032} = a_{1}^{\u2032}, a_{2}^{\u2032}, . . . , a_{n}^{\u2032}\\) vstupn\u00ed posloupnosti A,  \u017ee plat\u00ed \\(a_{1}^{\u2032} \\leq a_{2}^{\u2032} \\leq ... \\leq a_{n}^{\u2032}\\)</li> </ul>"},{"location":"09_Quicksort/9.4_Doln%C3%AD_meze_%C5%99azen%C3%AD/#def-9.4","title":"Invariant","text":"<p>Invariant je podm\u00ednka v algoritmu, kter\u00e1 mus\u00ed b\u00fdt spln\u011bna po celou dobu b\u011bhu programu.</p>"},{"location":"09_Quicksort/9.4_Doln%C3%AD_meze_%C5%99azen%C3%AD/#dolni-mez-slozitosti-razeni","title":"Doln\u00ed mez slo\u017eitosti \u0159azen\u00ed","text":"<ul> <li>Pro \u00fa\u010del stanoven\u00ed doln\u00ed meze p\u0159edpokl\u00e1d\u00e1me speci\u00e1ln\u00ed typ vstupn\u00ed \\(n\\) prvkov\u00e9 posloupnosti, a to permutaci   mno\u017einy \\(\\{1, . . . , n\\}\\)</li> <li>Probl\u00e9m \u0159azen\u00ed je z pohledu teorie informace ekvivalentn\u00ed probl\u00e9mu rozpozn\u00e1n\u00ed, o kterou permutaci z \\(n!\\) mo\u017en\u00fdch se na   vstupu jedn\u00e1.</li> <li>R\u016fzn\u00e9 vstupn\u00ed permutace je p\u0159itom t\u0159eba \u0159adit r\u016fzn\u00fdmi posloupnostmi porovn\u00e1n\u00ed a prohozen\u00ed.</li> <li>V\u00edme, \u017ee \\(e \\cdot \\frac{n^{n}}{e^{n}} \\leq n! \\leq en \\cdot \\frac{n^{n}}{e^{n}}\\) (viz BI-DML \u2013 Stirlingova formule).</li> <li>Po\u010det pot\u0159ebn\u00fdch bit\u016f pro rozpozn\u00e1n\u00ed permutace, a t\u00edm p\u00e1dem i pot\u0159ebn\u00fdch porovn\u00e1n\u00ed, tedy mus\u00ed   b\u00fdt \\(log(n!) \\geq log(e \\cdot \\frac{n^{n}}{e^{n}}) = log e + n \\cdot (log n \u2212 log e) = \\Omega (n \\cdot log n)\\)</li> <li>Stanovit doln\u00ed mez slo\u017eitosti \u0159azen\u00ed ale m\u016f\u017eeme pomoc\u00ed rozhodovac\u00edch strom\u016f podobn\u011b jako u probl\u00e9mu vyhled\u00e1v\u00e1n\u00ed.</li> </ul> <p>V\u011bta 9.5 (o slo\u017eitosti \u0159azen\u00ed)</p> D\u016fkaz v\u011bty 9.5 <ol> <li>Zvolme pevn\u00e9 \\(n\\) a uva\u017eujme vstupy \\(A = a_{1}, . . . , a_{n}\\), kter\u00e9 jsou permutacemi mno\u017einy \\(\\{1, . . . , n\\}\\)</li> <li>Uk\u00e1\u017eeme, \u017ee pro libovoln\u00fd \u0159adic\u00ed algoritmus \\(S\\) v porovn\u00e1vac\u00edm modelu RAM existuje \u201et\u011b\u017ek\u00fd\u201c vstup \\(A\\), kter\u00fd \u201edonut\u00ed\u201c \\(S\\) prov\u00e9st \\(\\Omega (n \\cdot log n)\\) porovn\u00e1n\u00ed.</li> <li> <p>Uprav\u00edme \\(S\\) tak, aby nejprve prov\u00e1d\u011bl v\u0161echna porovn\u00e1n\u00ed a teprve na konec prvky p\u0159eindexoval.</p> <ul> <li>Ka\u017ed\u00fd prvek si tedy pouze pamatuje pr\u016fb\u011b\u017en\u011b novou pozici a na v\u00fdslednou pozici se p\u0159esune a\u017e nakonec.</li> </ul> </li> <li> <p>Sestroj\u00edme rozhodovac\u00ed strom \\(T_{S}\\) popisuj\u00edc\u00ed v\u0161echny mo\u017en\u00e9 pr\u016fb\u011bhy algoritmu \\(S\\), tedy b\u011bhy pro v\u0161echny mo\u017en\u00e9 permutace.</p> </li> <li>Vnit\u0159n\u00ed vrcholy \\(T_{S}\\) jsou porovn\u00e1n\u00ed cmp(\\(a_{i}\\), \\(a_{j}\\) ) se dv\u011bma mo\u017en\u00fdmi v\u00fdsledky (rovnost tentokr\u00e1t nenastane d\u00edky volb\u011b vstupn\u00ed posloupnosti).</li> <li>Vynech\u00e1me v\u00fdsledky, kter\u00e9 jsou ve sporu s p\u0159edchoz\u00edmi porovn\u00e1n\u00edmi.</li> <li>V listu stromu algoritmus S provede napo\u010d\u00edtan\u00e9 prohozen\u00ed a zastav\u00ed se.</li> <li>Pro r\u016fzn\u00e9 vstupn\u00ed permutace \\(A\\) mus\u00ed algoritmus \\(S\\) skon\u010dit v r\u016fzn\u00fdch listech \\(T_{S}\\) (dv\u011b r\u016fzn\u00e9 permutace nelze se\u0159adit tout\u00e9\u017e posloupnost\u00ed p\u0159esun\u016f prvk\u016f).</li> <li>\\(T_{S}\\) je tedy bin\u00e1rn\u00ed zako\u0159en\u011bn\u00fd strom s \\(n!\\) listy, tak\u017ee mus\u00ed m\u00edt hloubku nejm\u00e9n\u011b \\(log(n!)\\), tedy \\(\\Omega(n \\cdot log n)\\)</li> <li>Proto mus\u00ed existovat vstupn\u00ed permutace A, pro kterou S provede \\(\\Omega(n \\cdot log n)\\) porovn\u00e1n\u00ed</li> </ol> <p></p> <p>P\u0159\u00edklad rozhodovac\u00edho stromu TS pro n\u011bjak\u00fd algoritmus S a n = 3</p>"},{"location":"09_Quicksort/9.4_Doln%C3%AD_meze_%C5%99azen%C3%AD/#theorem-9.5","title":"V\u011bta o slo\u017eitosti \u0159azen\u00ed","text":"<p>Ka\u017ed\u00fd deterministick\u00fd algoritmus v porovn\u00e1vac\u00edm modelu RAM, kter\u00fd se\u0159ad\u00ed \\(n\\)-prvkovou posloupnost, pou\u017eije v nejhor\u0161\u00edm p\u0159\u00edpad\u011b \\(\\Omega(n \\cdot log n)\\) porovn\u00e1n\u00ed.</p>"},{"location":"09_Quicksort/9.4_Doln%C3%AD_meze_%C5%99azen%C3%AD/#dolni-meze-slozitosti-dalsich-operaci","title":"Doln\u00ed meze slo\u017eitosti dal\u0161\u00edch operac\u00ed","text":"<p>D\u016fsledek</p> <p>Ka\u017ed\u00e1 korektn\u00ed implementace operace ExtractMin v bin\u00e1rn\u00ed hald\u011b (takov\u00e1, \u017ee po proveden\u00ed ExtractMin bude struktura spl\u0148ovat podm\u00ednky haldy) s \\(n\\) prvky mus\u00ed m\u00edt \u010dasovou slo\u017eitost \\(\\Omega(log n)\\) v nejhor\u0161\u00edm p\u0159\u00edpad\u011b.</p> D\u016fkaz <p>Sporem:</p> <ol> <li>P\u0159edpokl\u00e1dejme, \u017ee existuje algoritmus ExtractMin, kter\u00fd m\u00e1 v nejhor\u0161\u00edm p\u0159\u00edpad\u011b \u010dasovou slo\u017eitost \\(O(f (n))\\), kde \\(f (n) = o(log n)\\)</li> <li>M\u011bjme prvky \\(a_{1}, . . . , a_{n}\\) a ulo\u017eme je do pole P</li> <li>Na toto pole zavolejme funkci HeapBuild, kter\u00e1 z n\u011bj v \u010dase \\(O(n)\\) vytvo\u0159\u00ed korektn\u00ed bin\u00e1rn\u00ed haldu.</li> <li>Potom zavolejme \\(n\\)-kr\u00e1t funkci ExtractMin, \u010d\u00edm\u017e vyp\u00ed\u0161eme se\u0159azenou posloupnost.</li> <li>Dost\u00e1v\u00e1me t\u00edm algoritmus, kter\u00fd se\u0159ad\u00ed n \u010d\u00edsel v celkov\u00e9m \u010dase \\(n \\cdot O(f (n)) = o(n log n)\\)</li> <li>To je ale spor s p\u0159edchoz\u00ed v\u011btou o slo\u017eitosti probl\u00e9mu \u0159azen\u00ed, kter\u00e1 dokazuje, \u017ee takov\u00fd algoritmus neexistuje.</li> </ol>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/","title":"9.5 Speci\u00e1ln\u00ed \u0159ad\u00edc\u00ed algoritmy","text":"<ul> <li>Nyn\u00ed si uk\u00e1\u017eeme dva algoritmy, kter\u00e9 dok\u00e1\u017eou se\u0159adit \\(n\\) \u010d\u00edsel v nejhor\u0161\u00edm p\u0159\u00edpad\u011b rychleji ne\u017e v   \u010dase \\(O(n \\cdot log n)\\)</li> <li>P\u0159i tom to nebude ve sporu s doln\u00ed mez\u00ed slo\u017eitosti probl\u00e9mu \u0159azen\u00ed, proto\u017ee tyto rychlej\u0161\u00ed algoritmy nepracuj\u00ed v   porovn\u00e1vac\u00edm modelu RAM (nejsou tedy postaveny na operaci porovn\u00e1n\u00ed), ale pro \u0159azen\u00ed vyu\u017e\u00edvaj\u00ed s v\u00fdhodou n\u011bjakou   speci\u00e1ln\u00ed vlastnost vstupn\u00ed posloupnosti.</li> <li>Nelze je tedy pou\u017e\u00edt na se\u0159azen\u00ed obecn\u00e9 vstupn\u00ed posloupnosti \\(n\\) \u010d\u00edsel.</li> </ul> <p>Definice 9.5 (Porovn\u00e1vac\u00ed model RAM)</p>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#def-9.5","title":"Porovn\u00e1vac\u00ed model RAM","text":"<p>V porovn\u00e1vac\u00edm modelu RAM lze jen porovn\u00e1vat a p\u0159esouvat prvky. Porovn\u00e1v\u00e1n\u00ed je operace CMP(\\(x,y\\)), ta je konstantn\u00ed a deterministick\u00e1 a m\u00e1 3 v\u00fdstupy: \\(\\lt, \\gt, =\\)</p>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#countingsort","title":"CountingSort","text":"<ul> <li>CountingSort je algoritmus pro \u0159azen\u00ed \\(n\\) cel\u00fdch \u010d\u00edsel z mno\u017einy \\(\\{1, . . . , r\\}\\)</li> <li>Omezen\u00ed rozsahu vstupn\u00edch hodnot je pr\u00e1v\u011b tou speci\u00e1ln\u00ed vlastnost\u00ed.</li> <li>Nejd\u0159\u00edv projde vstupn\u00ed pole a spo\u010d\u00edt\u00e1 pro ka\u017ed\u00e9 \u010d\u00edslo z mno\u017einy \\(\\{1, . . . , r\\}\\), kolikr\u00e1t se ve vstupn\u00edm poli   vyskytuje (tedy vypo\u010dte histogram).</li> <li>Nad t\u00edmto polem po\u010dt\u016f v\u00fdskyt\u016f pak vypo\u010dte prefixov\u00fdm sou\u010dtem pozice, kde budou po se\u0159azen\u00ed za\u010d\u00e1tky oblast\u00ed tvo\u0159en\u00fdch   stejn\u00fdmi \u010d\u00edsly z mno\u017einy \\(\\{1, . . . , r\\}\\).</li> <li>A jako posledn\u00ed krok proch\u00e1z\u00ed podruh\u00e9 vstupn\u00ed pole, pro ka\u017ed\u00fd jeho prvek ur\u010d\u00ed pozici, na kter\u00e9 se m\u00e1 nach\u00e1zet po   se\u0159azen\u00ed a na tuto pozici jej p\u0159esune.</li> </ul> <p>\u0158ad\u00ed tedy v \u010dase \\(\\Theta (n + r)\\) s pam\u011b\u0165ovou n\u00e1ro\u010dnost\u00ed \\(\\Theta(n + r)\\)</p> <p></p> <p>Algoritmus 9.2 (CountingSort)</p>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#algoritmus-countingsort","title":"Algoritmus CountingSort","text":"CountingSort(x1, . . . , xn \u2208 {1, . . . , r})<pre><code>Pro j := 1, . . . , r:\n    pocet[j] := 0\nPro i := 1, . . . , n:\n    pocet[xi] := pocet[xi] + 1 //histogram v\u00fdskyt\u016f\nzacatek[1] := 1\nPro j := 2, . . . , r: //prefixov\u00fd sou\u010det\n    zacatek[j] := zacatek[j \u2212 1] + pocet[j \u2212 1]\nPro i := 1, . . . , n:\n    vystup[zacatek[xi]] := xi //p\u0159esun na spo\u010d\u00edtan\u00e9 pozice\n    zacatek[xi] := zacatek[xi] + 1\nVra\u0165 v\u00fdsledek vystup[1], . . . , vystup[n]\n</code></pre> <p>D\u016fle\u017eit\u00e9 pozorov\u00e1n\u00ed o modelu RAM</p> <p>Pam\u011b\u0165 RAMu tvo\u0159\u00ed pole celo\u010d\u00edseln\u00fdch bun\u011bk, kter\u00e9 jsou adresovateln\u00e9 cel\u00fdmi \u010d\u00edsly, nikoliv prvky posloupnosti!</p>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#vlastnosti-algoritmu-countingsort","title":"Vlastnosti algoritmu CountingSort","text":"<p>Pozorov\u00e1n\u00ed</p> <ul> <li>Algoritmus CountingSort korektn\u011b \u0159ad\u00ed cel\u00e1 \u010d\u00edsla z mno\u017einy \\(\\{1, . . . , r\\}\\) a je stabiln\u00ed</li> <li>CountingSort nen\u00ed in-place ani nen\u00ed datov\u011b citliv\u00fd</li> <li>Proto\u017ee \u010dasov\u00e1 slo\u017eitost je \\(\\Theta (n + r)\\), \u0159\u00edk\u00e1me, \u017ee pro \\(r = O(n)\\) m\u00e1 CountingSort line\u00e1rn\u00ed slo\u017eitost.</li> </ul>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#lexikograficke-razeni-k-tic","title":"Lexikografick\u00e9 \u0159azen\u00ed k-tic","text":"<ul> <li>M\u011bjme \\(n\\) uspo\u0159\u00e1dan\u00fdch \\(k\\)-tic \\(X_{1}, . . . , X_{n}\\) prvk\u016f z mno\u017einy \\(\\{1, . . . , r\\}\\) (   \u010dili \\(X_{i} \\in \\{1, . . . , r\\}^{k})\\)</li> <li>Sou\u0159adnice \\(k\\)-tic \u010d\u00edslujeme zleva doprava od jedn\u00e9: \\(X_{i} = (x_{i,1}, x_{i,2}, . . . , x_{i,k})\\)</li> <li>\u00dakolem je se\u0159adit \\(k\\)-tice slovn\u00edkov\u011b (lexikograficky).</li> <li>Vyu\u017eijeme toho, \u017ee CountingSort je stabiln\u00ed, a \u0159ad\u00edme takto:</li> </ul> <p>Algoritmus 9.3 (LexCountingSort)</p> <ul> <li>Na stejn\u00e9m principu je zalo\u017een\u00fd algoritmus RadixSort pro \u0159azen\u00ed v\u00edcecifern\u00fdch \u010d\u00edsel (viz cvi\u010den\u00ed).</li> </ul>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#algoritmus-lexcountingsort","title":"Algoritmus LexCountingSort","text":"LexCountingSort(k-tice X1, . . . , Xn)<pre><code>S := X1, . . . , Xn\nPro i := k, . . . , 1:\n    S := CountingSort(S) podle sou\u0159adnice i\nVra\u0165 S\n</code></pre>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#priklad-behu-algoritmu-lexcountingsort","title":"P\u0159\u00edklad b\u011bhu algoritmu LexCountingSort","text":"<p>V jednotliv\u00fdch sloupc\u00edch je po\u0159ad\u00ed \u010d\u00edsel po proveden\u00ed p\u0159\u00edslu\u0161n\u00e9 iterace \\(i\\)-smy\u010dky algoritmu.</p> <p></p> <p>P\u0159\u00edklad b\u011bhu algoritmu LexCountingSort</p>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#korektnost-algoritmu-lexcountingsort","title":"Korektnost algoritmu LexCountingSort","text":"<p>V\u011bta 9.6 (o korektnosti algoritmu LexCountingSort)</p> D\u016fkaz v\u011bty 9.6 <p>Dok\u00e1\u017eeme indukc\u00ed p\u0159es \u010d\u00edslo sou\u0159adnice n\u00e1sleduj\u00edc\u00ed invariant:</p> <p>Po proveden\u00ed iterace cyklu s \u010d\u00edslem \\(i\\) plat\u00ed, \u017ee vstupn\u00ed pole \\(k\\)-tic o\u0159ezan\u00fdch na \\(i\\text{-tou}\\) a\u017e \\(k\\text{-tou}\\) sou\u0159adnici je lexikograficky se\u0159azen\u00e9.</p> <ol> <li>IZ: Plat\u00ed evidentn\u011b pro prvn\u00ed iteraci s \\(i = k\\), kdy v \\(S\\) jsou hodnoty se\u0159azeny podle posledn\u00ed sou\u0159adnice.</li> <li>IK: P\u0159edpokl\u00e1dejme, \u017ee invariant plat\u00ed pro v\u0161echna \\(j, i \\lt j \\leq k\\)</li> <li>\u0158azen\u00ed v iteraci s \u010d\u00edslem \\(i\\) posouv\u00e1 dop\u0159edu v po\u0159ad\u00ed nejprve \\(k\\text{-tice}\\) maj\u00edc\u00ed na sou\u0159adnici \\(i\\) hodnotu 1, pokud existuj\u00ed.</li> <li>Proto\u017ee tyto \\(k-\\text{tice}\\) o\u0159\u00edznut\u00e9 na \\((i + 1)\\text{-tou}\\) a\u017e \\(k\\text{-tou}\\) sou\u0159adnici byly v p\u0159edchoz\u00edch iterac\u00edch se\u0159azeny spr\u00e1vn\u011b a CountingSort je stabiln\u00ed, bude tato skupina \\(k\\text{-tic}\\) o\u0159\u00edznut\u00fdch na \\(i\\text{-tou}\\) a\u017e \\(k\\text{-tou}\\) sou\u0159adnici tak\u00e9 se\u0159azena spr\u00e1vn\u011b</li> <li>Pak bude podobn\u00fdm zp\u016fsobem p\u0159\u00edpadn\u011b n\u00e1sledovat skupina \\(k\\text{-tic}\\), maj\u00edc\u00edch na sou\u0159adnici \\(i\\) hodnotu 2, pak 3, atd</li> <li>Po skon\u010den\u00ed iterace cyklu s \u010d\u00edslem \\(i\\) budou tedy \\(k\\text{-tice}\\) o\u0159\u00edznut\u00e9 na \\(i\\text{-tou}\\) a\u017e \\(k\\text{-tou}\\) sou\u0159adnici se\u0159azeny spr\u00e1vn\u011b</li> </ol>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#theorem-9.6","title":"V\u011bta o korektnosti algoritmu LexCountingSort","text":"<p>Algoritmus LexCountingSort \u0159ad\u00ed vstupn\u00ed \\(k\\)-tice spr\u00e1vn\u011b lexikograficky a je stabiln\u00ed</p>"},{"location":"09_Quicksort/9.5_Speci%C3%A1ln%C3%AD_%C5%99ad%C3%ADc%C3%AD_algoritmy/#slozitost-algoritmu-lexcountingsort","title":"Slo\u017eitost algoritmu LexCountingSort","text":"<p>V\u011bta o slo\u017eitosti algoritmu LexCountingSort</p> <ul> <li>\u010casov\u00e1 slo\u017eitost LexCountingSort je \\(\\Theta(k \\cdot (n + r))\\), co\u017e je line\u00e1rn\u00ed s d\u00e9lkou vstupu \\((k \\cdot n)\\) pro pevn\u00e9 \\(k\\) a \\(r\\)</li> <li>Pam\u011b\u0165ov\u00e1 slo\u017eitost \u010din\u00ed \\(\\Theta(kn + r)\\)</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.1_Dynamick%C3%A9_programov%C3%A1n%C3%AD/","title":"10.1 Dynamick\u00e9 programov\u00e1n\u00ed","text":"<ul> <li>DP je dal\u0161\u00ed technika n\u00e1vrhu algoritm\u016f, kter\u00e1 je zalo\u017een\u00e1 na rekurzivn\u00edm rozkladu probl\u00e9mu na podprobl\u00e9my.</li> <li>Na rozd\u00edl od klasick\u00e9 metody Rozd\u011bl a panuj, metoda DP vyu\u017e\u00edv\u00e1 toho, \u017ee se podprobl\u00e9my b\u011bhem rekurzivn\u00edho rozkladu   opakuj\u00ed.</li> <li>Podm\u00ednkou pou\u017eit\u00ed DP je tedy opakovan\u00fd v\u00fdskyt stejn\u00fdch podprobl\u00e9m\u016f p\u0159i rekurzivn\u00edm rozkladu.</li> <li>DP pak vede na mnohem rychlej\u0161\u00ed algoritmy ne\u017e p\u0159\u00edmo\u010dar\u00fd rekurzivn\u00ed rozklad.</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.1_Dynamick%C3%A9_programov%C3%A1n%C3%AD/#princip-dynamickeho-programovani-memoizace","title":"Princip Dynamick\u00e9ho programov\u00e1n\u00ed (memoizace)","text":"<ol> <li>Formulujeme \u0159e\u0161en\u00ed dan\u00e9ho probl\u00e9mu rekurzivn\u011b rozkladem na \u0159e\u0161en\u00ed podprobl\u00e9m\u016f.</li> <li>Pop\u00ed\u0161eme \u0159e\u0161en\u00ed pomoc\u00ed rekurzivn\u00edho algoritmu, kter\u00fd m\u00e1 exponenci\u00e1ln\u00ed slo\u017eitost.</li> <li>Identifikujeme opakovan\u00e9 v\u00fdpo\u010dty stejn\u00fdch podprobl\u00e9m\u016f.</li> <li>Vytvo\u0159\u00edme pr\u00e1zdnou tabulku hodnot \u0159e\u0161en\u00ed podprobl\u00e9m\u016f.</li> <li>Vlo\u017e\u00edme do n\u00ed hodnoty \u0159e\u0161en\u00ed trivi\u00e1ln\u00edch instanc\u00ed.</li> <li>P\u0159ed v\u00fdpo\u010dtem \u0159e\u0161en\u00ed podprobl\u00e9mu se pod\u00edv\u00e1me do tabulky.</li> <li>Pokud je pol\u00ed\u010dko tohoto podprobl\u00e9mu ji\u017e vypo\u010dten\u00e9, vezmeme jeho hodnotu.</li> <li>Jinak tento podprobl\u00e9m vy\u0159e\u0161\u00edme pomoc\u00ed vol\u00e1n\u00ed rekurze.</li> <li>Po n\u00e1vratu z rekurze zap\u00ed\u0161eme v\u00fdsledek do p\u0159\u00edslu\u0161n\u00e9ho pol\u00ed\u010dka tabulky.</li> </ol>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.1_Dynamick%C3%A9_programov%C3%A1n%C3%AD/#princip-dynamickeho-programovani-iterace-bottom-up","title":"Princip Dynamick\u00e9ho programov\u00e1n\u00ed (iterace - bottom-up)","text":"<ul> <li>P\u0159edchoz\u00ed obecn\u00fd postup vede na v\u00fdpo\u010det \u0159\u00edzen\u00fd shora dol\u016f:   \u0159e\u0161en\u00ed probl\u00e9mu vyvol\u00e1v\u00e1 \u0159e\u0161en\u00ed podprobl\u00e9m\u016f a vypl\u0148ov\u00e1n\u00ed jejich   pol\u00ed\u010dek v tabulce.</li> <li>Jakmile ale dok\u00e1\u017eeme zkonstruovat tabulku hodnot \u0159e\u0161en\u00ed   podprobl\u00e9m\u016f, uv\u011bdom\u00edme si, \u017ee ji lze vypl\u0148ovat bez rekurze, \u010dili   itera\u010dn\u011b, zvol\u00edme-li vhodn\u00e9 po\u0159ad\u00ed (topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed) od trivi\u00e1ln\u00edch koncov\u00fdch   \u0159e\u0161en\u00ed sm\u011brem k \u0159e\u0161en\u00ed cel\u00e9ho probl\u00e9mu.</li> <li>T\u00edm z\u00edsk\u00e1me \u0159\u00e1dov\u011b stejn\u011b rychl\u00fd, ale obvykle je\u0161t\u011b jednodu\u0161\u0161\u00ed   algoritmus, kter\u00fd vypln\u00ed tabulku zdola nahoru.</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.2_V%C3%BDpo%C4%8Det_Fibonacciho_%C4%8D%C3%ADsla/","title":"10.2 V\u00fdpo\u010det Fibonacciho \u010d\u00edsla","text":"<p>Algoritmus 10.1 (FibRec)</p> <pre><code>FibRec(n)\n    Pokud n \u2264 2: Vra\u0165 1\n    Jinak: Vra\u0165 FibRec(n \u2212 1) + FibRec(n \u2212 2)\n</code></pre> <p>Pozorov\u00e1n\u00ed</p> <p>\u010casov\u00e1 slo\u017eitost vol\u00e1n\u00ed funkce <code>FibRec(n)</code> je \\(\\Theta(F(n))\\), kde \\(F(n)\\) je \\(n\\)-t\u00e9 Fibonacciho \u010d\u00edslo,  tedy \\(\\Theta(\\Phi^{n+1})\\), kde \\(\\Phi \\approx 1,61\\) je hodnota zlat\u00e9ho \u0159ezu.</p> D\u016fkaz \u010dasov\u00e9 slo\u017eitosti FibRec <ul> <li>Ve stromu rekurzivn\u00edch vol\u00e1n\u00ed (SRV) je ka\u017ed\u00fd vrchol bu\u010fto list nebo vnit\u0159n\u00ed vrchol s p\u0159esn\u011b 2 syny (SRV je pln\u00fd bin\u00e1rn\u00ed strom). </li> <li>Po\u010det vnit\u0159n\u00edch vrchol\u016f je tedy nejv\u00fd\u0161e po\u010det list\u016f.</li> <li>Libovoln\u00fd vnit\u0159n\u00ed vrchol vrac\u00ed sou\u010det hodnot ze sv\u00fdch syn\u016f, neboli sou\u010det hodnot v\u0161ech list\u016f le\u017e\u00edc\u00edch pod n\u00edm.</li> <li>Ka\u017ed\u00fd list p\u0159itom vrac\u00ed hodnotu 1.</li> <li>Celkem tedy SRV obsahuje p\u0159esn\u011b \\(F(n)\\) list\u016f.</li> </ul> <p></p>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.2_V%C3%BDpo%C4%8Det_Fibonacciho_%C4%8D%C3%ADsla/#vypocet-fibonacciho-cisla-memoizace","title":"V\u00fdpo\u010det Fibonacciho \u010d\u00edsla - memoizace","text":"<ul> <li>Pou\u017eijeme tabulku \\(T\\), na po\u010d\u00e1tku obsahuj\u00edc\u00ed nedefinovan\u00e9 hodnoty.</li> <li>Hodnotu \\(F(i)\\) zap\u00ed\u0161eme do \\(T[i]\\), jakmile na ni p\u0159i prov\u00e1d\u011bn\u00ed   rekurzivn\u00edho algoritmu poprv\u00e9 naraz\u00edme a poprv\u00e9 ji vypo\u010dteme.</li> <li>P\u0159i ka\u017ed\u00e9m rekurzivn\u00edm vol\u00e1n\u00ed se nejd\u0159\u00edv pod\u00edv\u00e1me do pol\u00ed\u010dka \\(T\\),   odpov\u00eddaj\u00edc\u00edho dan\u00e9mu podprobl\u00e9mu, zda ji\u017e neobsahuje d\u0159\u00edve   vypo\u010dten\u00e9 \u0159e\u0161en\u00ed.</li> <li>Pokud ano, rekurzi nevol\u00e1me a vezmeme hodnotu z tabulky.</li> <li>Pokud ne, vol\u00e1me rekurzi.</li> <li>T\u00e9to technice se \u0159\u00edk\u00e1 memoizace.</li> </ul> <p>Algoritmus 10.2 (FibMem)</p> <pre><code>FibMem(n)\n    Pokud je T[n] definov\u00e1no: Vra\u0165 T[n]\n    Pokud n \u2264 2: T[n] := 1\n    Jinak: T[n] := FibMem(n \u2212 1) + FibMem(n \u2212 2)\n    Vra\u0165 T[n]\n</code></pre> <p>Pozorov\u00e1n\u00ed</p> <p>\u010casov\u00e1 slo\u017eitost vol\u00e1n\u00ed funkce <code>FibMem(n)</code> je \\(O(n)\\).</p> D\u016fkaz \u010dasov\u00e9 slo\u017eitosti FibMem <ul> <li>K rekurzivn\u00edmu vol\u00e1n\u00ed nyn\u00ed dojde jedin\u011b tehdy, vypl\u0148ujeme-li dosud nedefinovan\u00e9 pol\u00ed\u010dko tabulky.</li> <li>Proto\u017ee na po\u010d\u00e1tku jsou v\u0161echna pol\u00ed\u010dka pr\u00e1zdn\u00e1, stane se toto \\(n\\)-kr\u00e1t, z toho dvakr\u00e1t trivi\u00e1ln\u011b pro  \\(F(1)\\) a \\(F(2)\\).</li> <li>SRV m\u00e1 tedy \\(n \u2212 2\\) vnit\u0159n\u00edch vrchol\u016f a tedy \\(n \u2212 1\\) list\u016f.</li> <li>Celkem tedy \\(O(n)\\) vrchol\u016f, kde v ka\u017ed\u00e9m str\u00e1v\u00edme \\(O(1)\\) \u010das</li> </ul> <p></p>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.2_V%C3%BDpo%C4%8Det_Fibonacciho_%C4%8D%C3%ADsla/#vypocet-fibonacciho-cisla-iterace","title":"V\u00fdpo\u010det Fibonacciho \u010d\u00edsla - iterace","text":"<ul> <li>V\u0161imn\u011bme si ale, \u017ee pokud tabulku \\(T\\) budeme vypl\u0148ovat od   nejmen\u0161\u00edch hodnot k nejv\u011bt\u0161\u00edm, v\u016fbec rekurzi nepot\u0159ebujeme a sta\u010d\u00ed   jednoduch\u00e1 iterace. (topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed)</li> </ul> <p>Algoritmus 10.3 (FibIter)</p> <pre><code>FibIter(n)\n    T[1] := 1\n    T[2] := 1\n    Pro k := 3,..., n:\n    T[k] := T[k \u2212 1] + T[k \u2212 2]\n    Vra\u0165 T[n]\n</code></pre> <p>Pozorov\u00e1n\u00ed</p> <p><code>FibIter(n)</code> funguje korektn\u011b a m\u00e1 \u010dasovou slo\u017eitost \\(O(n)\\).</p>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.3_Nejdel%C5%A1%C3%AD_roustouc%C3%AD_podposloupnost_%28LIS%29/","title":"10.3 Nejdel\u0161\u00ed roustouc\u00ed podposloupnost (LIS)","text":"<ul> <li>Vy\u0159e\u0161\u00edme nejd\u0159\u00edv jednodu\u0161\u0161\u00ed probl\u00e9m <code>DelkaNrpRec(i)</code>:<ul> <li>Pro dan\u00e9 \\(i\\) vr\u00e1t\u00ed d\u00e9lku NRP za\u010d\u00ednaj\u00edc\u00ed pr\u00e1v\u011b prvkem \\(x_i\\).</li> </ul> </li> <li>Postupn\u011b projdeme v\u0161echna \\(x_j\\) potenci\u00e1ln\u011b navazuj\u00edc\u00ed na \\(x_i\\).</li> <li>Pro ka\u017ed\u00e9 takov\u00e9 \\(x_j\\) zavol\u00e1me rekurzivn\u011b tot\u00e9\u017e    (\u010d\u00edm\u017e vypo\u010d\u00edt\u00e1me d\u00e9lku NRP za\u010d\u00ednaj\u00edc\u00ed prvkem \\(x_j\\)).</li> <li>Ze v\u0161ech potenci\u00e1ln\u011b navazuj\u00edc\u00edch prvk\u016f \\(x_j\\) si pak vybereme ten,   kter\u00fd m\u00e1 svou NRP nejdel\u0161\u00ed a k d\u00e9lce jeho NRP p\u0159i\u010dteme   jedni\u010dku.</li> </ul> <p>Algoritmus 10.4 (DelkaNrpRec)</p> <pre><code>DelkaNrpRec(i)\n    d := 1\n    Pro j := i + 1,..., n:\n        Pokud x_j &gt; x_i:\n            d := max(d, 1 + DelkaNrpRec(j))\nVra\u0165 d\n</code></pre> <p>Lemma o \u010dasov\u00e9 slo\u017eitosti DelkaNrpRec</p> <p>\u010casov\u00e1 slo\u017eitost <code>DelkaNrpRec(0)</code> je \\(O(2^n)\\).</p> D\u016fkaz \u010dasov\u00e9 slo\u017eisti DelkaNrpRec <ul> <li>Struktura SRV z\u00e1vis\u00ed na velikostech prvk\u016f vstupn\u00ed posloupnosti, proto\u017ee se rekurze vol\u00e1 pouze pro potenci\u00e1ln\u011b navazuj\u00edc\u00ed prvky.</li> <li>Nejv\u00edce se rekurze vol\u00e1 v p\u0159\u00edpad\u011b monotonn\u011b rostouc\u00ed posloupnosti a pak m\u00e1 SRV tvar binomi\u00e1ln\u00edho stromu \\(B_n\\)</li> <li>V obecn\u00e9m p\u0159\u00edpad\u011b je SRV podstromem \\(B_n\\)</li> </ul> <ul> <li>D\u00e9lku NRP cel\u00e9 vstupn\u00ed posloupnosti z\u00edsk\u00e1me tak, \u017ee zavol\u00e1me   <code>DelkaNrpRec(i)</code> postupn\u011b pro \\(i = 1,\\dots, n\\) a vezmeme maximum z v\u00fdsledk\u016f.</li> <li>Elegantn\u011bj\u0161\u00ed je ale dodefinovat \\(x_0 = -\\infty\\), zavolat pouze   <code>DelkaNrpRec(0)</code> a ode\u010d\u00edst z v\u00fdsledku jedni\u010dku, nebo\u0165 \\(x_0\\) se   bude v optim\u00e1ln\u00edm \u0159e\u0161en\u00ed NRP v\u017edy zaru\u010den\u011b vyskytovat.</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.3_Nejdel%C5%A1%C3%AD_roustouc%C3%AD_podposloupnost_%28LIS%29/#delka-nrp-memoizace","title":"D\u00e9lka NRP - memoizace","text":"<ul> <li>Pro sn\u00ed\u017een\u00ed \u010dasov\u00e9 slo\u017eitosti pou\u017eijeme op\u011bt techniku memoizace.</li> <li>Zavedeme tabulku \\(T[0,\\dots, n]\\), na po\u010d\u00e1tku pr\u00e1zdnou.</li> <li>Na konci m\u00e1 b\u00fdt v \\(T[i]\\) ulo\u017eena d\u00e9lka nejdel\u0161\u00ed ze v\u0161ech   rostouc\u00edch podposloupnost\u00ed za\u010d\u00ednaj\u00edc\u00edch prvkem \\(x_i\\).</li> </ul> <p>Algoritmus 10.5 (DelkaNrpMem)</p> <pre><code>DelkaNrpMem(i)\n    Pokud je T[i] definov\u00e1no: Vra\u0165 T[i]\n    T[i] := 1\n    Pro j := i + 1,..., n:\n        Pokud x_j &gt; x_i:\n            T[i] := max(T[i], 1 + DelkaNrpMem(j))\n    Vra\u0165 T[i]\n</code></pre> <p>Lemma o \u010dasov\u00e9 slo\u017eitosti DelkaNrpMem</p> <ul> <li>Funkci <code>DelkaNrpMem</code> m\u016f\u017eeme zavolat pouze pro \\(n + 1\\) r\u016fzn\u00fdch argument\u016f.</li> <li>Poka\u017ed\u00e9 v n\u00ed str\u00e1v\u00edme \u010das \\(O(n)\\), tak\u017ee celkov\u00fd \u010das je \\(O(n^2)\\).</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.3_Nejdel%C5%A1%C3%AD_roustouc%C3%AD_podposloupnost_%28LIS%29/#delka-nrp-iterace","title":"D\u00e9lka NRP - iterace","text":"<ul> <li>Pokud za\u010dneme vypl\u0148ovat tabulku v opa\u010dn\u00e9m sm\u011bru od nejv\u011bt\u0161\u00edho \\(i\\) k nejmen\u0161\u00edmu, rekurze se m\u016f\u017eeme zbavit \u00fapln\u011b.</li> </ul> <p>Algoritmus 10.6 (DelkaNrpIter)</p> <pre><code>DelkaNrpIter(x1,...,xn)\n    x_0 := \u2212\u221e\n    Pro i := n, n \u2212 1,...,0:\n        T[i] := 1\n        Pro j := i + 1,...,n:\n            Pokud x_i &lt; x_j a T[i] &lt; 1 + T[j]:\n                T[i] := 1 + T[j]\n    Vra\u0165 T[0] \u2212 1\n</code></pre> <p>Pozorov\u00e1n\u00ed</p> <p><code>DelkaNrpIter</code> m\u00e1 kvadratickou \u010dasovou slo\u017eitost.</p> <p>Pozorov\u00e1n\u00ed</p> <p>Algoritmus se d\u00e1 vylep\u0161it (\u0159\u00e1dky 4 - 6) za pomoc\u00ed augmentace AVL stromu   a dostat se na slo\u017eitost \\(O(n \\cdot log(n))\\) </p> <p>Lemma o korektnosti DelkaNrpIter</p> <p>Po skon\u010den\u00ed <code>DelkaNrpIter</code> je v \\(T[i]\\) ulo\u017eena d\u00e9lka nejdel\u0161\u00ed ze v\u0161ech rostouc\u00edch podposloupnost\u00ed za\u010d\u00ednaj\u00edc\u00edch prvkem \\(x_i\\).</p> D\u016fkaz korektnosti DelkaNrpIter <ul> <li>Zp\u011btnou indukc\u00ed podle \\(i\\), tj. od \\(n\\) k 1.</li> <li>Pokud je na konci \\(T[i] = 1\\), je \\(x_i\\) maximem v \\(x_i,\\dots, x_n\\).</li> <li>Pokud \\(T[i]\\) vzniklo jako \\(1 + T[j]\\) a tedy optim\u00e1ln\u00ed \u0159e\u0161en\u00ed pro \\(X = x_i,\\dots, x_n\\) za\u010d\u00edn\u00e1 dvojic\u00ed \\(x_i\\), \\(x_j\\), pak z n\u011bj odebr\u00e1n\u00edm \\(x_i\\)  vznikne optim\u00e1ln\u00ed \u0159e\u0161en\u00ed pro krat\u0161\u00ed vstup \\(X' = x_j,\\dots, x_n\\) za\u010d\u00ednaj\u00edc\u00ed \\(x_j\\), jeho\u017e d\u00e9lka je v \\(T[j]\\). </li> <li>Sporem: Kdyby existovalo lep\u0161\u00ed \u0159e\u0161en\u00ed pro krat\u0161\u00ed vstup \\(X'\\),  mohli bychom ho roz\u0161\u00ed\u0159it o \\(x_i\\) a z\u00edskat lep\u0161\u00ed \u0159e\u0161en\u00ed pro p\u016fvodn\u00ed \\(X\\).</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.3_Nejdel%C5%A1%C3%AD_roustouc%C3%AD_podposloupnost_%28LIS%29/#konstrukce-nrp-iterace","title":"Konstrukce NRP - iterace","text":"<ul> <li>B\u011bhem v\u00fdpo\u010dtu d\u00e9lky NRP si sta\u010d\u00ed p\u0159i ka\u017ed\u00e9m nalezen\u00ed lep\u0161\u00edho \u0159e\u0161en\u00ed   zapamatovat i p\u0159\u00edslu\u0161n\u00fd navazuj\u00edc\u00ed prvek.</li> </ul> <p>Algoritmus 10.7 (NrpIter)</p> <pre><code>NrpIter(x_1,...,x_n)\n    x_0 := \u2212\u221e\n    Pro i := n, n \u2212 1,...,0:\n        T[i] := 1\n        N[i] := \u22a5\n        Pro j := i + 1,...,n:\n            Pokud x_i &lt; x_j a T[i] &lt; 1 + T[j]:\n                T[i] := 1 + T[j]\n                N[i] := j\n</code></pre> <p></p> <p>Lemma</p> <p>NRP je po skon\u010den\u00ed v\u00fdpo\u010dtu <code>NrpIter</code> podposloupnost s indexy \\(N[0], N[N[0]], N[N[N[0]]],\\dots\\)</p> D\u016fkaz koreknosti NrpIter <ul> <li>Kdykoliv se na\u0161lo v\u011bt\u0161\u00ed \\(T[i]\\), ulo\u017eil se do \\(N[i]\\) index druh\u00e9ho prvku p\u0159\u00edslu\u0161n\u00e9 del\u0161\u00ed rostouc\u00ed podposloupnosti za\u010d\u00ednaj\u00edc\u00ed prvkem \\(x_i\\).</li> <li>Po skon\u010den\u00ed proto \\(N[0]\\) \u0159\u00edk\u00e1, jak\u00fd prvek je v optim\u00e1ln\u00edm \u0159e\u0161en\u00ed cel\u00e9 \u00falohy prvn\u00ed, N[N[0]] ud\u00e1v\u00e1 druh\u00fd a tak d\u00e1le.</li> <li>Pokud \\(N[i] = \\bot (nil)\\), pak xi je maximem v \\(x_i,\\dots,x_n\\) a ka\u017ed\u00e1 p\u0159\u00edpadn\u00e1 rostouc\u00ed podposloupnost zde kon\u010d\u00ed.</li> <li>Pokud existuje v\u00edce \u0159e\u0161en\u00ed, <code>NrpIter</code> vr\u00e1t\u00ed to, kter\u00e9 za\u010d\u00edn\u00e1 nejv\u00edce vlevo.</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.3_Nejdel%C5%A1%C3%AD_roustouc%C3%AD_podposloupnost_%28LIS%29/#nrp-grafovy-pohled","title":"NRP - Grafov\u00fd pohled","text":"<ul> <li>Uka\u017eme si, \u017ee konstrukci NRP lze formulovat jako grafov\u00fd probl\u00e9m.</li> <li>Sestroj\u00edme orientovan\u00fd graf \\(G\\), kde<ul> <li>vrcholy jsou prvky \\(x_0,\\dots,x_{n+1}\\), kde dodefinujeme \\(x_0 = \u2212\\infty\\) a \\(x_{n+1} = +\\infty\\)</li> <li>\\(x_i\\) vedou hrany do potenci\u00e1ln\u011b navazuj\u00edc\u00edch vrchol\u016f \\(x_j\\)   (pro kter\u00e9 plat\u00ed \\(j &gt; i\\) a \\(x_j &gt; x_i\\)),</li> </ul> </li> </ul> <ul> <li>Ka\u017ed\u00e1 rostouc\u00ed podposloupnost odpov\u00edd\u00e1 n\u011bjak\u00e9 orientovan\u00e9 cest\u011b v \\(G\\).</li> <li>Konstrukce NRP je tedy ekvivalentn\u00ed nalezen\u00ed nejdel\u0161\u00ed   orientovan\u00e9 cesty, kter\u00e1 za\u010d\u00edn\u00e1 v \\(x_0\\) a kon\u010d\u00ed v \\(x_{n+1}\\).</li> <li>\\(G\\) m\u00e1 \\(\\Theta(n)\\) vrchol\u016f a \\(O(n^2)\\) hran.</li> </ul> <p>Pozorov\u00e1n\u00ed</p> <p>\\(G\\) je acyklick\u00fd orientovan\u00fd graf a po\u0159ad\u00ed vrchol\u016f \\(x_0,\\dots,x_{n+1}\\) je jeho topologick\u00e9 uspo\u0159\u00e1d\u00e1n\u00ed.</p> <ul> <li>Nejdel\u0161\u00ed cestu v \\(G\\) pak nalezneme v \u010dase \\(O(n^2)\\) algoritmem velmi podobn\u00fdm algoritmu <code>NrpIter</code>:<ul> <li>Proch\u00e1z\u00edme pozp\u00e1tku topologick\u00fdm uspo\u0159\u00e1d\u00e1n\u00edm \\(x_n,\\dots,x_0\\).</li> <li>Pro ka\u017ed\u00e9 \\(x_i\\) sestroj\u00edme nejdel\u0161\u00ed cestu z \\(x_i\\) do \\(x_{n+1}\\) tak, \u017ee   projdeme v\u0161echny hrany  (\\(x_i\\), \\(x_j\\)) \\(\\in E(G)\\) a vybereme takov\u00e9ho   souseda \\(x_j\\) , jeho\u017e cesta do \\(x_{n+1}\\) je nejdel\u0161\u00ed.</li> </ul> </li> <li>To je pom\u011brn\u011b typick\u00e9: DP je \u010dasto ekvivalentn\u00ed s hled\u00e1n\u00edm cesty   (\u010di s jin\u00fdm probl\u00e9mem) ve vhodn\u00e9m grafu.</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.4_Edita%C4%8Dn%C3%AD_vzd%C3%A1lenost_%C5%99et%C4%9Bzc%C5%AF_%28EV%C5%98%29/","title":"10.4 Edita\u010dn\u00ed vzd\u00e1lenost \u0159et\u011bzc\u016f (EV\u0158)","text":"<p>Definice 10.0 (Levenshteinova vzd\u00e1lenost)</p> <ul> <li>Uva\u017eujme \u0159et\u011bzce nad abecedou \\(\\Sigma\\).</li> <li>Edita\u010dn\u00ed operac\u00ed na \u0159et\u011bzci nazveme vlo\u017een\u00ed znaku, smaz\u00e1n\u00ed znaku nebo z\u00e1m\u011bnu jednoho znaku jin\u00fdm.</li> <li>Edita\u010dn\u00ed vzd\u00e1lenost \u0159et\u011bzc\u016f (EV\u0158) \\(x = x_1,\\dots,x_m\\) a \\(y = y_1,\\dots,y_n\\), zna\u010d\u00edme \\(L(x, y)\\),  je nejmen\u0161\u00ed po\u010det edita\u010dn\u00edch operac\u00ed pot\u0159ebn\u00fdch k tomu, abychom z \u0159et\u011bzce \\(x\\) vytvo\u0159ili \u0159et\u011bzec \\(y\\).</li> </ul> <p>Nap\u0159. pro \\(\\Sigma = {a,b,c}\\) je \\(L(abba, cba) = 2\\), jeliko\u017e:</p> <p></p>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.4_Edita%C4%8Dn%C3%AD_vzd%C3%A1lenost_%C5%99et%C4%9Bzc%C5%AF_%28EV%C5%98%29/#evr-idea-rekurzivniho-reseni","title":"EV\u0158 - idea rekurzivn\u00edho \u0159e\u0161en\u00ed","text":"<ul> <li>V nejkrat\u0161\u00ed posloupnosti edita\u010dn\u00edch operac\u00ed se ka\u017ed\u00e9ho znaku   t\u00fdk\u00e1 nejv\u00fd\u0161e jedna edita\u010dn\u00ed operace, tak\u017ee edita\u010dn\u00ed operace   lze v\u017edy uspo\u0159\u00e1dat zleva doprava.</li> <li>M\u016f\u017eeme si tedy p\u0159edstavit, \u017ee proch\u00e1z\u00edme \\(x = x_1,\\dots,x_m\\) zleva   doprava a postupn\u011b ho p\u0159etv\u00e1\u0159\u00edme na \\(y = y_1,\\dots,y_n\\) a hled\u00e1me   nejmen\u0161\u00ed po\u010det edita\u010dn\u00edch operac\u00ed, kter\u00fdmi to dok\u00e1\u017eeme.<ul> <li>Pokud \\(x_1 = y_1\\), m\u016f\u017eeme prvn\u00ed znak ponechat beze zm\u011bny a   rekurzivn\u011b pak tud\u00ed\u017e plat\u00ed \\(L(x,y) = L(x_2 \\dots x_m, y_2 \\dots y_n)\\).</li> <li>Jinak m\u00e1me 3 mo\u017enosti, z nich\u017e vol\u00edme tu, kter\u00e1 d\u00e1 nejmen\u0161\u00ed \u0159e\u0161en\u00ed:<ol> <li>Znak \\(x_1\\) zam\u011bn\u00edme za \\(y_1\\).     Pak \\(L(x,y) = 1 + L(x_2 \\dots x_m, y_2 \\dots y_n)\\).</li> <li>Znak \\(x_1\\) sma\u017eeme.     Pak \\(L(x,y) = 1 + L(x_2 \\dots x_m, y_1 \\dots y_n)\\).</li> <li>P\u0159ed \u0159et\u011bzec \\(x\\) vlo\u017e\u00edme znak \\(y_1\\).     Pak \\(L(x,y) = 1 + L(x_1 \\dots x_m, y_2 \\dots y_n)\\).</li> </ol> </li> </ul> </li> <li>Edita\u010dn\u00ed vzd\u00e1lenost 2 \u0159et\u011bzc\u016f lze tedy vypo\u010d\u00edtat rekurzivn\u011b z   edita\u010dn\u00edch vzd\u00e1lenost\u00ed jejich pod\u0159et\u011bzc\u016f, p\u0159esn\u011bji jejich suffix\u016f.</li> <li>Pokud \\(x_1 = y_1\\)</li> </ul> \\[ L(x_1 \\dots x_m, y_1 \\dots y_n) = L(x_2 \\dots x_m, y_2 \\dots y_n) \\] <ul> <li>Pokud \\(x_1 \\ne y_1\\)</li> </ul> \\[ L(x_1, \\dots, x_m, y_1, \\dots, y_n) = 1 + \\min \\begin{cases} L(x_2, \\dots, x_m, y_2, \\dots, y_n), \\\\ L(x_2, \\dots, x_m, y_1, \\dots, y_n), \\\\ L(x_1, \\dots, x_m, y_2, \\dots, y_n) \\end{cases}. \\] <ul> <li>Rekurzivn\u00ed vol\u00e1n\u00ed budou m\u00edt na vstupu suffixov\u00e9 \u0159et\u011bzce   \\(x_i,\\dots,x_m\\) a \\(y_j,\\dots,y_n\\) pro \\(i = 1,\\dots, m + 1\\) a   \\(j = 1,\\dots, n + 1\\).</li> </ul> <p>Algoritmus 10.8 (EvrRec)</p> <pre><code>EvrRec(i, j)                        // i, j=indexy za\u010d\u00e1tk\u016f suffix\u016f x, y\n    Pokud i &gt; m: Vra\u0165 n \u2212 j + 1     // vlo\u017een\u00ed zbytku y za x\n    Pokud j &gt; n: Vra\u0165 m \u2212 i + 1     // smaz\u00e1n\u00ed zbytku x\n    \u2113_z := EvrRec(i + 1, j + 1)     // \u0159e\u0161en\u00ed pokud by x_i = y_j\n    Pokud x_i = \u0338= y_j:              // test nutnosti korekce\n        \u2113_z := \u2113_z + 1              // korekce z\u00e1m\u011bnou y_j za x_i\n    \u2113_s := 1 + EvrRec(i + 1, j)     // smaz\u00e1n\u00ed x_i\n    \u2113_v := 1 + EvrRec(i, j + 1)     // vlo\u017een\u00ed y_j p\u0159ed x_i\n    Vra\u0165 min(\u2113_z, \u2113_s, \u2113_v)\n</code></pre> <ul> <li>\\(L(x, y)\\) se rovn\u00e1 hodnot\u011b, kterou vr\u00e1t\u00ed vol\u00e1n\u00ed <code>EvrRec(1, 1)</code>.</li> </ul> <p>Lemma \u010dasov\u00e9 slo\u017eitosti EvrRec</p> <p>\u010casov\u00e1 slo\u017eitost <code>EvrRec</code> pro \u0159et\u011bzce d\u00e9lky \\(m\\) a \\(n\\) je  \\(T(m, n) = \\Omega(3^{min(m,n)})\\) a \\(T(m, n) = O(3^{m+n\u22121})\\).</p> D\u016fkaz \u010dasov\u00e9 slo\u017eitosti EvrRec <ul> <li>Rekurze se v listech SRV zastav\u00ed, je-li jeden ze suffix\u016f pr\u00e1zdn\u00fd.</li> <li>Struktura SRV tedy z\u00e1vis\u00ed na \\(m\\) a \\(n\\). Nech\u0165 B\u00daNO \\(m \\ge n\\).</li> <li>SRV je tern\u00e1rn\u00ed: algoritmus zkoum\u00e1 rekurzivn\u011b z\u00e1m\u011bnu, smaz\u00e1n\u00ed a vlo\u017een\u00ed pro ka\u017edou dvojici nepr\u00e1zdn\u00fdch suffix\u016f.</li> <li>Nejmen\u0161\u00ed mo\u017en\u00e1 hloubka zano\u0159en\u00ed rekurze je \\(n\\), nap\u0159. kdy\u017e krat\u0161\u00ed \u0159et\u011bzec je prefixem del\u0161\u00edho: \\(x = y_1 \\dots y_n x_{n+1} \\dots x_m\\).</li> <li>Naopak nejv\u011bt\u0161\u00ed mo\u017en\u00e1 hloubka zano\u0159en\u00ed rekurze je \\(m + n \u2212 1\\), kdy d\u00e9lky \u0159et\u011bzc\u016f se zkracuj\u00ed st\u0159\u00eddav\u011b tak, abychom se dostali na oba suffixy d\u00e9lky jedna.</li> <li>V ka\u017ed\u00e9m uzlu SRV provede \\(O(1)\\) operac\u00ed.</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.4_Edita%C4%8Dn%C3%AD_vzd%C3%A1lenost_%C5%99et%C4%9Bzc%C5%AF_%28EV%C5%98%29/#evr-memoizace","title":"EV\u0158 - memoizace","text":"<ul> <li>Hodnotu, kterou vr\u00e1t\u00ed prvn\u00ed zavol\u00e1n\u00ed <code>EvrMem(i, j)</code>, ukl\u00e1d\u00e1me do   pol\u00ed\u010dka \\(M[i, j], i = 1,\\dots, m + 1, j = 1, . . . , n + 1\\).</li> <li>Na konci m\u00e1 b\u00fdt \\(M[i, j] = L(x_i \\dots  x_m, y_j \\dots y_n)\\), kde<ul> <li>\\(x_i \\dots x_m = \\epsilon\\), pokud \\(i = m + 1\\) a</li> <li>\\(y_j \\dots y_n = \\epsilon\\), pokud \\(j = n + 1\\).</li> </ul> </li> <li>\u0158e\u0161en\u00ed je na konci v \\(M[1, 1]\\).</li> </ul> <p>Algoritmus 10.9 (EvrMem)</p> <pre><code> EvrMem(i, j)                           // i, j=indexy za\u010d\u00e1tk\u016f suffix\u016f x, y\n    Pokud je M[i, j] definov\u00e1no: Vra\u0165 M[i, j]\n    Pokud i &gt; m: M[i, j] := n \u2212 j + 1; Vra\u0165 M[i, j];\n    Pokud j &gt; n: M[i, j] := m \u2212 i + 1; Vra\u0165 M[i, j];\n    \u2113_z := EvrMem(i + 1, j + 1)         // \u0159e\u0161en\u00ed pokud by x_i = y_j\n    Pokud x_i = \u0338= y_j:                  // test nutnosti korekce\n        \u2113_z := \u2113_z + 1                  // korekce z\u00e1m\u011bnou y_j za x_i\n    \u2113_s := 1 + EvrMem(i + 1, j)         // smaz\u00e1n\u00ed x_i\n    \u2113_v := 1 + EvrMem(i, j + 1)         //vlo\u017een\u00ed y_j p\u0159ed x_i\n    M[i, j] := min(\u2113_z, \u2113_s, \u2113_v)\n    Vra\u0165 M[i, j]\n</code></pre> <p>Pozorov\u00e1n\u00ed</p> <p>\u010casov\u00e1 i pam\u011b\u0165ov\u00e1 slo\u017eitost <code>EvrMem(1, 1)</code> je \\(O(mn)\\).</p>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.4_Edita%C4%8Dn%C3%AD_vzd%C3%A1lenost_%C5%99et%C4%9Bzc%C5%AF_%28EV%C5%98%29/#evr-iterativni-reseni","title":"EV\u0158 - iterativn\u00ed \u0159e\u0161en\u00ed","text":"<ul> <li>Iterativn\u00ed \u0159e\u0161en\u00ed, kdy po\u010d\u00edt\u00e1me polo\u017eky tabulky \\(T\\) z prav\u00e9ho   doln\u00edho rohu sm\u011brem k lev\u00e9mu horn\u00edmu rohu, kdy \u0159e\u0161en\u00ed pro dva   \u0159et\u011bzce vybereme jako minimum z ji\u017e zn\u00e1m\u00fdch \u0159e\u0161en\u00ed pro v\u00fd\u0161e   popsan\u00e9 t\u0159i kombinace jejich suffix\u016f, je ponech\u00e1na na cvi\u010den\u00ed</li> </ul> <p>Iterativn\u00ed p\u0159edpis \u0159e\u0161en\u00ed EV\u0158</p> <ul> <li>M\u011bjme slova \\(A\\) a \\(B\\) a tabulku \\(M[n, m]\\), kde \\(n = |A|\\) a \\(m = |B|\\)</li> <li>Pot\u00e9 pro krok iterace plat\u00ed </li> </ul> \\[    M[i,j] =          \\begin{cases}         M[i+1,j+1]&amp;{if A[i] = B[j]} \\\\         1 + \\min{M[i+1, j], M[i, j+1], M[i+1, j+1]}         \\end{cases} \\] <ul> <li>Ka\u017ed\u00e9 \\(M[i,j]\\) z\u00e1vis\u00ed pouze na v\u011bt\u0161\u00edch \\(i\\),\\(j\\) jedn\u00e1 se tedy o DAG</li> <li>Iterovat budeme postupn\u011b po \u0159\u00e1dc\u00edch resp. sloupc\u00edch od prav\u00e9ho doln\u00edho rohu</li> <li>Z\u00e1kladn\u00ed krok</li> </ul> \\[     (\\forall i \\in \\hat{n})(M[i,m] = i), (\\forall j \\in \\hat{m})(M[n,j] = j) \\] <ul> <li>V\u00fdsledek bude \\(M[0,0]\\)</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.5_Optimalizace_BVS/","title":"10.5 Optimalizace BVS","text":"<ul> <li>Pro danou mno\u017einu hodnot nen\u00ed BVS jednozna\u010dn\u011b ur\u010den\u00fd.</li> <li>Ne v\u017edy je nejd\u016fle\u017eit\u011bj\u0161\u00edm faktorem hloubka cel\u00e9ho stromu.</li> <li>Ob\u010das je d\u016fle\u017eit\u00e1 hloubka dan\u00e9ho prvku/kl\u00ed\u010de a frekvence jeho vyhled\u00e1v\u00e1n\u00ed.</li> <li>M\u011bjme data obsahuj\u00edc\u00ed prvky 8, 11, 16, 20, 25.</li> <li>Nech\u0165 je vypozorov\u00e1no v posledn\u00edch tis\u00edci vyhled\u00e1v\u00e1n\u00edch, \u017ee   prvek 8 je vyhled\u00e1v\u00e1n 100kr\u00e1t, prvek 11 je vyhled\u00e1v\u00e1n 250kr\u00e1t a   dal\u0161\u00ed prvky po \u0159ad\u011b 50, 400 a 200kr\u00e1t.</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.5_Optimalizace_BVS/#histogramove-bvs-myslenka","title":"Histogramov\u00e9 BVS - my\u0161lenka","text":"<ul> <li>Hledan\u00e9 BVS mus\u00ed m\u00edt n\u011bjak\u00fd ko\u0159en.</li> <li>Jeliko\u017e ko\u0159en nezn\u00e1me a proto\u017ee nen\u00ed v\u016fbec jasn\u00e9 jak poznat   spr\u00e1vn\u00fd ko\u0159en, rezignujeme a \u201eprost\u011b vyzkou\u0161\u00edme v\u0161echny\u201c.</li> <li>Jestli\u017ee jsme jako ko\u0159en zvolili hodnotu r, rozd\u011bl\u00ed se na\u0161e data na    dv\u011b \u010d\u00e1sti \\(L = \\{1, \\dots , r \u2212 1\\}\\) a \\(R = \\{r + 1, \\dots , n\\}\\).</li> <li>Na\u0161\u00edm dal\u0161\u00edm \u00fakolem pak bude naleznout nejlep\u0161\u00ed mo\u017en\u00e9 stromy   \\(T_L\\) a \\(T_R\\) pro tato data a z\u00edskat v\u00fdsledek.</li> <li>Data obsa\u017een\u00e1 v \\(L\\) i v \\(R\\) z\u00edskaj\u00ed jedno vyhled\u00e1v\u00e1n\u00ed nav\u00edc.</li> </ul> \\[ 1 \\cdot p_r + \\sum_{i \\in L}(1 + h_L(i))p_i + \\sum_{i \\in R}(1 + h_R(i))p_i = \\sum_{i \\in [n]} p_i + \\sum_{i \\in L} h_L(i)p_i + \\sum_{i \\in R} h_R(i)p_i \\] <ul> <li>kde \\(h_L(i)\\) a \\(h_R(i)\\) ozna\u010duj\u00ed p\u0159\u00edslu\u0161n\u00e9 hladiny ve stromech pro data v \\(L\\) a \\(R\\).</li> </ul> <p>Algoritmus 10.10 (BVSOPT_rec)</p> <pre><code>BVSOPT_rec(p_1,...,p_n)\n    Pokud n = 0: Vra\u0165 0\n    x := Sum(i\u2208[n], p_i)\n    m := +\u221e\n    Pro r = 1,...,n:\n        L := {p_1,..., p_{r\u22121}}, R := {p_{r+1},..., p_n}\n        c_L := BVSOPT_rec(L)\n        c_R := BVSOPT_rec(R)\n        m := min(m, c_L + c_R)\n    Vra\u0165 m + x\n</code></pre> <p>Pozorov\u00e1n\u00ed o BVSOPT_rec</p> <p><code>BVSOPT_rec(p_1,...,p_n)</code> je kone\u010dn\u00fd a vrac\u00ed hodnotu n\u011bjak\u00e9ho BVS.</p> <p>Lemma o korektnosi BVSOPT_rec</p> <p><code>BVSOPT_rec(p_1,...,p_n)</code> vrac\u00ed hodnotu optim\u00e1ln\u00edho \u0159e\u0161en\u00ed.</p> D\u016fkaz korektnosti BVSOPT_rec <ul> <li><code>BVSOPT_rec(p_1,...,p_n)</code> vrac\u00ed hodnotu pro n\u011bjak\u00fd BVS a tedy speci\u00e1ln\u011b vrac\u00ed horn\u00ed odhad na optimum.</li> <li>Obr\u00e1cen\u011b pak uva\u017eme n\u011bjak\u00e9 optim\u00e1ln\u00ed \u0159e\u0161en\u00ed \u2013 tedy bin\u00e1rn\u00ed vyhled\u00e1vac\u00ed strom \\(T\\).</li> <li>Form\u00e1ln\u011b dokazujeme indukc\u00ed podle velikosti (tj. po\u010dtu vrchol\u016f) stromu \\(T\\).</li> </ul> <p>ZI: Pro jednovrcholov\u00e9 stromy jist\u011b vrac\u00ed optim\u00e1ln\u00ed \u0159e\u0161en\u00ed.</p> <p>IK: </p> <ul> <li>Nech\u0165 tedy \\(T\\) m\u00e1 alespo\u0148 2 vrcholy a nech\u0165 \\(r\\) je jeho ko\u0159en (<code>BVSOPT_rec</code> zkou\u0161\u00ed \\(r\\)).</li> <li>D\u00e1le se strom \\(T\\) skl\u00e1d\u00e1 z lev\u00e9ho podstromu \\(T_L\\), kter\u00fd obsahuje data \\(L\\) (obdobn\u011b pro \\(R\\)).</li> <li>Proto\u017ee \\(T_L\\) m\u00e1 alespo\u0148 o jeden vrchol m\u00e9n\u011b ne\u017e \\(T\\), lze na n\u011bho aplikovat induk\u010dn\u00ed p\u0159edpoklad, tedy <code>BVSOPT_rec(L)</code> vr\u00e1t\u00ed hodnotu optim\u00e1ln\u00edho \u0159e\u0161en\u00ed (nanejv\u00fd\u0161 takov\u00e9 ceny jako \\(T_L\\)).</li> <li>Stejn\u011b pro \\(T_R\\).</li> <li>Pak ale cena vr\u00e1cen\u00e1 <code>BVSOPT_rec</code> je nanejv\u00fd\u0161 takov\u00e1 jako je cena \\(T\\).</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.5_Optimalizace_BVS/#histogramove-bvs-memoizace","title":"Histogramov\u00e9 BVS - memoizace","text":"<ul> <li>Indexy \\(l, u \\in n\\) \u2013 odkud kam sahaj\u00ed aktivn\u00ed data.</li> <li>Pomocn\u00e9 pole \\(M[n][n]\\) incializovan\u00e9 na \\(\\bot\\).</li> </ul> <p>Algoritmus 10.11 (BVSOPT)</p> <pre><code> BVSOPT(\u2113, u)\n    Pokud (M[\u2113, u] \u0338= \u22a5): Vra\u0165 M[\u2113, u]\n    Pokud (\u2113 &gt; u): Vra\u0165 M[\u2113][u] := 0\n    x := Sum(i=\u2113 to u, p_i)\n    m := +\u221e\n    Pro ka\u017ed\u00e9 r \u2208 {\u2113, . . . , u}:\n        c_L := BVSOPT(\u2113, r \u2212 1)\n        c_R := BVSOPT(r + 1, u)\n        m := min(m, c_L + c_R)\n    Vra\u0165 M[\u2113][u] := m + x    \n</code></pre> <p>Lemma o \u010dasov\u00e9 slo\u017eitosti BVSOPT</p> <p><code>BVSOPT(1, n)</code> po\u010d\u00edt\u00e1 v \u010dase \\(O(n^3)\\).</p> <p>K zamy\u0161len\u00ed</p> <p>\u010casov\u00e1 slo\u017eitos se d\u00e1 vylep\u0161it na \\(O(n^2)\\) pomoc\u00ed chyt\u0159ej\u0161\u00edho v\u00fdb\u011bru ko\u0159enu (\u0159\u00e1dek 6)</p>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.6_Triangulace_konvexn%C3%ADho_mnoho%C3%BAheln%C3%ADku/","title":"10.6 Triangulace konvexn\u00edho mnoho\u00faheln\u00edku","text":"<p>Definice 10.1 (Triangulace)</p> <p>Nech\u0165 \\(U\\) je konvexn\u00ed \\(n\\)-\u00faheln\u00edk, \\(n \\gt 3\\), zadan\u00fd kart\u00e9zsk\u00fdmi sou\u0159adnicemi vrchol\u016f \\(a_1, a_2,\\dots, a_n\\) v rovin\u011b \u010d\u00edslovan\u00fdmi proti sm\u011bru hodinov\u00fdch ru\u010di\u010dek. Pak</p> <ul> <li>Diagon\u00e1la \\(a_ia_j\\) = \u00fase\u010dka spojuj\u00edc\u00ed 2 nesousedn\u00ed vrcholy \\(a_i, a_j\\). </li> <li>Triangulace \\(U\\) = takov\u00e1 podmno\u017eina jeho diagon\u00e1l, kter\u00e1 rozd\u011bluje plochu \\(U\\) na troj\u00faheln\u00edky a ve kter\u00e9 se \u017e\u00e1dn\u00e9 dv\u011b diagon\u00e1ly neprot\u00ednaj\u00ed (a\u017e na sv\u00e9 koncov\u00e9 vrcholy).</li> </ul> <p></p> <p>Pozorov\u00e1n\u00ed</p> <p>Ka\u017ed\u00e1 triangulace \\(n\\)-\u00faheln\u00edku sest\u00e1v\u00e1 z \\(n \u2212 3\\) diagon\u00e1l a d\u011bl\u00ed \\(U\\) na \\(n \u2212 2\\) troj\u00faheln\u00edk\u016f.</p> <p></p> <p>Definice 10.2 (Vlastnosti triangulace)</p> <ul> <li>D\u00e9lku diagon\u00e1ly \\(a_ia_j\\) zna\u010d\u00edme \\(\\Vert a_ia_j \\Vert\\).</li> <li>Velikost triangulace je sou\u010det d\u00e9lek jej\u00edch diagon\u00e1l.</li> <li>Minim\u00e1ln\u00ed triangulace mnoho\u00faheln\u00edku (MTM) \\(U\\) je ta z triangulac\u00ed \\(U\\), kter\u00e1 m\u00e1 minim\u00e1ln\u00ed velikost.</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.6_Triangulace_konvexn%C3%ADho_mnoho%C3%BAheln%C3%ADku/#problem-minimalni-triangulace-mnohouhelniku","title":"Probl\u00e9m minim\u00e1ln\u00ed triangulace mnoho\u00faheln\u00edku","text":"<ul> <li>Na vstupu je konvexn\u00ed \\(n\\)-\u00faheln\u00edk \\(U\\) zadan\u00fd kart\u00e9zsk\u00fdmi sou\u0159adnicemi vrchol\u016f \\(a_1, a_2,\\dots, a_n\\) v rovin\u011b.</li> <li>\u00dakolem je ur\u010dit velikost jeho minim\u00e1ln\u00ed triangulace, p\u0159\u00edpadn\u011b takovou triangulaci vypsat.</li> </ul>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.6_Triangulace_konvexn%C3%ADho_mnoho%C3%BAheln%C3%ADku/#velikost-mtm-myslenka","title":"Velikost MTM - my\u0161lenka","text":"<ul> <li>Ke ka\u017ed\u00e9 hran\u011b mnoho\u00faheln\u00edku v ka\u017ed\u00e9m \u0159e\u0161en\u00ed \u201ep\u0159il\u00e9h\u00e1\u201c jeden troj\u00faheln\u00edk.</li> <li>Speci\u00e1ln\u011b je to pravda pro hranu \\(a_1a_n\\) na kterou se zam\u011b\u0159\u00edme.</li> <li>Zvol\u00edme-li libovoln\u00fd takov\u00fd troj\u00faheln\u00edk \\(T\\), rozd\u011bl\u00edme mnoho\u00faheln\u00edk \\(U\\) na dva men\u0161\u00ed    (z nich\u017e n\u011bkter\u00fd m\u016f\u017ee b\u00fdt pr\u00e1zdn\u00fd).</li> </ul> <ul> <li>Ka\u017ed\u00e1 triangulace se skl\u00e1d\u00e1 z diagon\u00e1l obsa\u017een\u00fdch v n\u011bjak\u00e9m troj\u00faheln\u00edku \\(T\\) a z triangulace men\u0161\u00edho mnoho\u00faheln\u00edka   nebo obou men\u0161\u00edch mnoho\u00faheln\u00edk\u016f</li> <li>Minim\u00e1ln\u00ed triangulace se tedy skl\u00e1d\u00e1 z diagon\u00e1l obsa\u017een\u00fdch v n\u011bjak\u00e9m troj\u00faheln\u00edku \\(T\\) a z minim\u00e1ln\u00edch triangulac\u00ed   men\u0161\u00edch mnoho\u00faheln\u00edk\u016f. Tyto triangulace najdeme rekurzivn\u011b.</li> <li>Proto\u017ee dop\u0159edu nev\u00edme, kter\u00fd troj\u00faheln\u00edk pat\u0159\u00ed do minim\u00e1ln\u00ed triangulace, mus\u00edme vyzkou\u0161et v\u0161echny.</li> </ul> <p>Algoritmus 10.12 (MtmRec)</p> <pre><code>MtmRec(a_1,..., a_n)\n    Pokud n = 3: Vra\u0165 0\n    M := \u221e\n    Pro k := 2,...,n \u2212 1:\n    // hrana a_1,a_n bude v troj\u00faheln\u00edku a_1,a_n,a_k,\n    // ten rozd\u011bl\u00ed a_1,...,a_n na a_1,...,a_k a a_k,...,a_n.\n        Pokud k = 2: M_1 := 0\n        Pokud k \u2265 3: M_1 := MtmRec(a_1,...,a_k) + ||a_1,a_k||\n        Pokud k \u2264 n \u2212 2: M_2 := MtmRec(a_k,...,a_n) + ||a_k,a_n||\n        Pokud k = n \u2212 1: M_2 := 0\n    M := min(M, M_1 + M_2)\n    Vra\u0165 M\n</code></pre> <p>Fakt o po\u010dtu r\u016fzn\u00fdch triangulac\u00ed</p> <p>Po\u010det r\u016fzn\u00fdch triangulac\u00ed konvexn\u00edho \\(n\\)-\u00faheln\u00edku je d\u00e1n \\((n \u2212 2)\\)-t\u00fdm  Catalanov\u00fdm \u010d\u00edslem \\(C(n - 2) = \\frac{1}{n-1} \\binom{2n-4}{n-2} = 2^{\\Theta(n)}\\)</p> <p>D\u016fsledek faktu o po\u010dtu triangulac\u00ed</p> <p><code>MtmRec</code> m\u00e1 exponenci\u00e1ln\u00ed \u010dasovou slo\u017eitost.</p>"},{"location":"10_Dynamick%C3%A9_programov%C3%A1n%C3%AD/10.6_Triangulace_konvexn%C3%ADho_mnoho%C3%BAheln%C3%ADku/#velikost-mtm-memoizace","title":"Velikost MTM - memoizace","text":"<ul> <li>Definujeme nyn\u00ed hodnoty \\(M[i, j]\\) jako<ul> <li>velikost minim\u00e1ln\u00ed triangulace mnoho\u00faheln\u00edku \\(a_i ,\\dots, a_j\\).</li> </ul> </li> <li>\u010c\u00edslo \\(M[i, j]\\) m\u00e1 smysl pro \\(j \\gt i + 2\\) (mnoho\u00faheln\u00edk je tvo\u0159en aspo\u0148 t\u0159emi vrcholy).</li> <li>Zjevn\u011b \\(M[i, i + 2] = 0\\).</li> <li>Hodnota \\(M[1, n]\\) p\u0159edstavuje velikost minim\u00e1ln\u00ed triangulace cel\u00e9ho \\(a_1,\\dots, a_n\\), tedy \u0159e\u0161en\u00ed \u00falohy Velikost MTM.</li> <li>Hodnoty \\(M[i, j]\\) budeme po\u010d\u00edtat postupn\u011b podle velikosti mnoho\u00faheln\u00edka, tedy podle rozd\u00edlu \\(j \u2212 i\\).</li> <li>Obecn\u011b, p\u0159i v\u00fdpo\u010dtu \\(M[i, j]\\) je t\u0159eba zkusit v\u0161echny troj\u00faheln\u00edky \\(T\\), kter\u00e9 p\u0159il\u00e9haj\u00ed stranou k \u00fase\u010dce \\(a_ia_j\\).</li> <li>Jejich t\u0159et\u00ed vrchol \\(a_k\\) je n\u011bkter\u00fd z \\(a_{i+1}, a_{i+2},\\dots, a_{j\u22121}\\), \u010dili \\(k \\in \\{i + 1,\\dots, j \u2212 1\\}\\).</li> </ul> <ul> <li>Pokud t\u0159et\u00ed vrchol \\(a_k\\) je n\u011bkter\u00fd z \\(a_{i+2},\\dots, a_{j\u22122}\\), pak troj\u00faheln\u00edk \\(T\\) rozd\u011bl\u00ed zkouman\u00fd mnoho\u00faheln\u00edk na   dva men\u0161\u00ed mnoho\u00faheln\u00edky, jejich\u017e optim\u00e1ln\u00ed triangulace jsme ji\u017e spo\u010d\u00edtali d\u0159\u00edve.</li> <li>Tak\u017ee hled\u00e1me \\(k\\), kter\u00e9 vede na minimum v\u00fdrazu</li> </ul> \\[ M[i, j] = \\min_{i+2 \\le k \\le j-2} (M[i, k] + \\Vert a_i a_k \\Vert + M[k,j] + \\Vert a_k a_j \\Vert) \\] <p>Algoritmus MtmIter</p> <pre><code>MtmIter(a_1,..., a_n)\n    Pro i := 1,..., n:\n    M[i, i + 2] := 0\n    Pro s := 4,..., n:  //velikost mnoho\u00faheln\u00edka\n        Pro i := 1,..., n \u2212 s + 1:\n            j := i + s \u2212 1\n            M[i, j] := \u221e\n            Pro k := i + 1,..., j \u2212 1:\n                Pokud k = i + 1: M_1 := 0\n                Pokud k \u2265 i + 2: M_1 := M[i, k] + ||a_i,a_k||\n                Pokud k \u2264 j \u2212 2: M_2 := M[k, j] + ||a_k,a_j||\n                Pokud k = j \u2212 1: M_2 := 0\n                M[i, j] := min(M[i, j], M_1 + M_2)\n    Vra\u0165 M[1, n]\n</code></pre> <p>Pozorov\u00e1n\u00ed o \u010dasov\u00e9 slo\u017eitosti MtmIter</p> <p>\u010casov\u00e1 slo\u017eitost algoritmu <code>MtmIter</code> je \\(O(n^3)\\) a pam\u011b\u0165ov\u00e1 \\(O(n^2)\\).</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.1_Probl%C3%A9m_minim%C3%A1ln%C3%AD_kostry_grafu/","title":"11.1 Probl\u00e9m minim\u00e1ln\u00ed kostry grafu","text":""},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.1_Probl%C3%A9m_minim%C3%A1ln%C3%AD_kostry_grafu/#motivace","title":"Motivace","text":"<ul> <li>Napadl sn\u00edh a v\u0161echny ulice m\u011bsta jsou zasn\u011b\u017een\u00e9.</li> <li>Kter\u00e9 ulice prohrneme, aby \u0161lo dojet odkudkoliv kamkoliv, a p\u0159itom n\u00e1m prohrnut\u00ed sn\u011bhu dalo co nejm\u00e9n\u011b pr\u00e1ce?</li> </ul> <ul> <li> <p>Tato ot\u00e1zka vede na hled\u00e1n\u00ed tzv. minim\u00e1ln\u00ed kostry grafu.</p> </li> <li> <p>Popi\u0161me nyn\u00ed probl\u00e9m form\u00e1ln\u011b.</p> </li> <li>P\u0159ipomenut\u00ed: Kostra grafu \\(G\\) je podgraf, kter\u00fd obsahuje v\u0161echny vrcholy a je to strom, a m\u00e1 tedy \\(|V (G)| \u2212 1\\) hran.</li> </ul> <p></p> <p>Definice 11.1 (Minim\u00e1ln\u00ed kostra grafu)</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.1_Probl%C3%A9m_minim%C3%A1ln%C3%AD_kostry_grafu/#def-11.1","title":"Minim\u00e1ln\u00ed kostra grafu","text":"<ul> <li>M\u011bjme souvisl\u00fd neorientovan\u00fd graf \\(G = (V, E)\\).  Ka\u017ed\u00e9 hran\u011b \\(e \\in E\\) p\u0159i\u0159ad\u00edme \u010d\u00edselnou v\u00e1hu \\(w(e)\\), kde \\(w: E \\to \\mathbb{R}\\). Takov\u00fd graf se naz\u00fdv\u00e1 hranov\u011b ohodnocen\u00fd.</li> <li>V\u00e1hovou funkci m\u016f\u017eeme p\u0159irozen\u011b roz\u0161\u00ed\u0159it na podgrafy: V\u00e1ha \\(w(H)\\) podgrafu \\(H \\subseteq G\\) je sou\u010det vah jeho hran.</li> <li>Kostra hranov\u011b ohodnocen\u00e9ho grafu G je minim\u00e1ln\u00ed, pokud m\u00e1 mezi v\u0161emi jeho kostrami nejmen\u0161\u00ed v\u00e1hu.</li> </ul>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/","title":"11.2 Jarn\u00edk\u016fv algoritmus","text":"<ul> <li>Nejjednodu\u0161\u0161\u00ed algoritmus pro hled\u00e1n\u00ed minim\u00e1ln\u00ed kostry poch\u00e1z\u00ed z roku 1930, kdy ho vymyslel \u010desk\u00fd matematik Vojt\u011bch   Jarn\u00edk.</li> <li>Tehdy my\u0161lenka zapadla a a\u017e pozd\u011bji byla n\u011bkolikr\u00e1t znovuobjevena \u2013 proto se algoritmu \u0159\u00edk\u00e1 t\u00e9\u017e Prim\u016fv.</li> </ul> <p>Algoritmus 11.1 (Jarn\u00edk\u016fv)  </p> <p></p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#algo-11.1","title":"Algoritmus Jarn\u00edk","text":"<p>Vstup</p> <p>Souvisl\u00fd hranov\u011b ohodnocen\u00fd graf \\(G\\)</p> <p>V\u00fdstup</p> <p>Minim\u00e1ln\u00ed kostra \\(G\\)</p> <p>Idea</p> <ul> <li>Za\u010dneme se stromem, kter\u00fd obsahuje libovoln\u00fd jeden vrchol a \u017e\u00e1dn\u00e9 hrany.</li> <li>Vybereme nejleh\u010d\u00ed hranu incidentn\u00ed s t\u00edmto vrcholem.</li> <li>P\u0159id\u00e1me ji do stromu i s nov\u00fdm koncov\u00fdm vrcholem.</li> <li>Postup opakujeme: v ka\u017ed\u00e9m dal\u0161\u00edm kroku p\u0159id\u00e1v\u00e1me nejleh\u010d\u00ed z hran, kter\u00e9 vedou mezi vrcholy dosud vytvo\u0159en\u00e9ho stromu a zbytkem grafu.</li> <li>Takto pokra\u010dujeme, dokud nevznikne cel\u00e1 kostra.</li> </ul> <p>Algoritmus</p> Algoritmus MinKostraJarn\u00edk (G = (V, E), w: E \u2192 R):<pre><code>v0 := libovoln\u00fd vrchol grafu\nT := strom obsahuj\u00edc\u00ed pouze vrchol v0 a \u017e\u00e1dn\u00e9 hrany\nDokud existuje hrana {u, v} takov\u00e1, \u017ee u \u2208 V(T) a v \u0338\u2208 V(T)\n    P\u0159idej nejleh\u010d\u00ed takovou hranu spolu s v do T\nVra\u0165 T\n</code></pre>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#hladove-algoritmy","title":"Hladov\u00e9 algoritmy","text":"<ul> <li>Jarn\u00edk\u016fv algoritmus je typick\u00fdm p\u0159\u00edkladem tzv. hladov\u00e9ho algoritmu (angl. greedy algorithm).</li> <li>V ka\u017ed\u00e9m okam\u017eiku vyb\u00edr\u00e1me lok\u00e1ln\u011b nejlep\u0161\u00ed hranu.</li> <li>Minim\u00e1ln\u00ed kostra je jedn\u00edm z \u0159\u00eddk\u00fdch p\u0159\u00edpad\u016f, kdy hladov\u00fd algoritmus skute\u010dn\u011b spo\u010dte optim\u00e1ln\u00ed \u0159e\u0161en\u00ed.</li> <li>Dok\u00e1\u017eeme postupn\u011b, \u017ee Jarn\u00edk\u016fv algoritmus skute\u010dn\u011b vr\u00e1t\u00ed minim\u00e1ln\u00ed kostru.</li> </ul>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#dukaz-korektnosti-jarnikova-algoritmu","title":"D\u016fkaz korektnosti Jarn\u00edkova algoritmu","text":"<ul> <li>Nejprve uk\u00e1\u017eeme, \u017ee se Jarn\u00edk\u016fv algoritmus spu\u0161t\u011bn\u00fd na souvisl\u00e9m hranov\u011b ohodnocen\u00e9m grafu zastav\u00ed a vygeneruje   kostru.</li> <li>D\u00e1le budeme pro jednoduchost p\u0159edpokl\u00e1dat hranov\u011b ohodnocen\u00fd graf s unik\u00e1tn\u00edmi vahami a dok\u00e1\u017eeme, \u017ee m\u00e1 jedinou   minim\u00e1ln\u00ed kostru a Jarn\u00edk\u016fv algoritmus ji vytvo\u0159\u00ed.</li> <li>K tomu zavedeme pojem element\u00e1rn\u00edho \u0159ezu grafu.</li> <li>Pot\u00e9 uk\u00e1\u017eeme, \u017ee Jarn\u00edk\u016fv algoritmus vyd\u00e1 minim\u00e1ln\u00ed kostru i v p\u0159\u00edpad\u011b, \u017ee v\u00e1hy nejsou unik\u00e1tn\u00ed (viz graf v p\u0159edchoz\u00edm   p\u0159\u00edkladu).</li> </ul>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#1-konecnost-jarnikova-algoritmu","title":"1. Kone\u010dnost Jarn\u00edkova algoritmu","text":"<p>Lemma 11.1 (o kone\u010dnosti Jarn\u00edkova algoritmu)</p> D\u016fkaz Lemmatu 11.1 <ul> <li>Graf \\(T\\) konstruovan\u00fd algoritmem vznik\u00e1 z jednoho vrcholu postupn\u00fdm p\u0159id\u00e1v\u00e1n\u00edm list\u016f.</li> <li>Tak\u017ee \\(T\\) je v ka\u017ed\u00e9m okam\u017eiku v\u00fdpo\u010dtu strom.</li> <li>V ka\u017ed\u00e9 iteraci se \\(|V(T)|\\) zv\u011bt\u0161\u00ed o \\(1\\).</li> <li>Dokud \\(V(T) \\ne V(G)\\), mus\u00ed d\u00edky souvislosti \\(G\\) existovat hrana mezi \\(V(T)\\) a \\(V(G) \\setminus V(T)\\), kterou m\u016f\u017ee algoritmus p\u0159idat do \\(T\\).</li> <li>To znamen\u00e1, \u017ee algoritmus se zastav\u00ed, a\u017e kdy\u017e \\(V(T) = V(G)\\).</li> <li>Tehdy je ale \\(T\\) kostra.</li> </ul>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#theorem-11.1","title":"Lemma o kone\u010dnosti Jarn\u00edkova algoritmu","text":"<p>Jarn\u00edk\u016fv algoritmus se po \\(|V| - 1\\) iterac\u00edch zastav\u00ed a vyd\u00e1 n\u011bjakou kostru zadan\u00e9ho grafu \\(G = (V, E)\\).</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#2-spravnost-jarnikova-algoritmu","title":"2. Spr\u00e1vnost Jarn\u00edkova algoritmu","text":"<p>Definice 11.2 (Element\u00e1rn\u00ed \u0159ezy v grafu)</p> <p></p> <p>Lemma 11.2 (o \u0159ezech v grafu s unik\u00e1tn\u00edmi vahami)</p> D\u016fkaz Lemmatu 11.2 <ul> <li>Dok\u00e1\u017eeme obm\u011bn\u011bnou implikaci: Pokud n\u011bjak\u00e1 kostra \\(T\\) neobsahuje hranu \\(e\\), pak nen\u00ed minim\u00e1ln\u00ed.</li> <li>Ozna\u010dme \\(A\\) a \\(B\\) mno\u017einy vrchol\u016f ur\u010duj\u00edc\u00ed element\u00e1rn\u00ed \u0159ez \\(R\\).</li> <li>Hrana \\(e = \\{a,b\\}\\), \\(a \\in A\\), \\(b \\in B\\), je nejleh\u010d\u00ed v \\(R\\).</li> <li>Nech\u0165 \\(T\\) je kostra neobsahuj\u00edc\u00ed \\(e\\).</li> <li>Proto\u017ee \\(T\\) je strom, existuje v n\u011bm jedin\u00e1 cesta \\(P(a,b)\\) a ta mus\u00ed alespo\u0148 jednou p\u0159ekro\u010dit element\u00e1rn\u00ed \u0159ez \\(R\\).</li> <li>Nech\u0165 \\(f = \\{a^\u2032,b^\u2032\\}\\), \\(a^\u2032 \\in A\\), \\(b^\u2032 \\in B\\), je libovoln\u00e1 hrana, kde se to stalo.</li> </ul> <p></p> <ul> <li>Nyn\u00ed z kostry \\(T\\) odebereme hranu \\(f\\).</li> <li>T\u00edm se kostra rozpadne na dva stromy \\(T_a\\), \\(T_b\\), z nich\u017e jeden obsahuje \\(a\\) a druh\u00fd \\(b\\).</li> <li>P\u0159id\u00e1n\u00edm hrany \\(e\\) stromy op\u011bt propoj\u00edme a t\u00edm z\u00edsk\u00e1me jinou kostru \\(T^\u2032\\).</li> <li>Plat\u00ed \\(w(T^\u2032) = w(T) \u2212 w(f) + w(e)\\).</li> <li>Proto\u017ee e je nejleh\u010d\u00ed hrana v element\u00e1rn\u00edm \u0159ezu a v\u00e1hy jsou unik\u00e1tn\u00ed, mus\u00ed platit \\(w(f) \\gt w(e)\\).</li> <li>Proto \\(w(T^\u2032) \\lt w(T)\\) a tud\u00ed\u017e \\(T\\) nen\u00ed minim\u00e1ln\u00ed kostra.</li> </ul> <p>Varov\u00e1n\u00ed</p> <p>Zm\u00ednka existence jedin\u00e9 cesty \\(P(a,b)\\) a n\u00e1sledn\u00e9 vybr\u00e1n\u00ed hrany \\(f\\), kter\u00e1 le\u017e\u00ed n\u011bkde na t\u00e9to cest\u011b je d\u016fle\u017eit\u00e1.</p> <p>Pouh\u00e9 vybr\u00e1n\u00ed n\u00e1hodn\u00e9 hrany \\(f\\) (kter\u00e1 p\u0159ekra\u010duje element\u00e1rn\u00ed \u0159ez) a n\u00e1sledn\u00e9 prohozen\u00ed \\(f\\) a \\(e\\) by nevedlo ke spr\u00e1vn\u00e9mu z\u00e1v\u011bru.</p> <p></p> <p>V\u011bta 11.3 (o minim\u00e1ln\u00ed kost\u0159e Jarn\u00edk)</p> D\u016fkaz V\u011bty 11.3 <ul> <li>Jarn\u00edk\u016fv algoritmus v ka\u017ed\u00e9m kroku vybere jedine\u010dnou nejleh\u010d\u00ed hranu element\u00e1rn\u00edho \u0159ezu mezi vrcholy dosud vytvo\u0159en\u00e9ho stromu a zbytkem grafu, kter\u00e1 je v\u017edy dle lemmatu obsa\u017eena v ka\u017ed\u00e9 minim\u00e1ln\u00ed kost\u0159e.</li> <li>To ale znamen\u00e1, \u017ee kostra vytvo\u0159en\u00e1 Jarn\u00edkov\u00fdm algoritmem je podgrafem ka\u017ed\u00e9 minim\u00e1ln\u00ed kostry.</li> <li>Proto\u017ee ale v\u0161echny kostry dan\u00e9ho grafu maj\u00ed stejn\u00fd po\u010det hran, znamen\u00e1 to, \u017ee vytvo\u0159en\u00e1 kostra je v\u0161em minim\u00e1ln\u00edm kostr\u00e1m rovna a je tud\u00ed\u017e unik\u00e1tn\u00ed.</li> </ul> <p>D\u016fsledek</p> <p>Minim\u00e1ln\u00ed kostra je jednozna\u010dn\u011b ur\u010dena uspo\u0159\u00e1d\u00e1n\u00edm hran podle vah, na konkr\u00e9tn\u00edch hodnot\u00e1ch vah nez\u00e1le\u017e\u00ed. Toto plat\u00ed nebo\u0165 Jarn\u00edk\u016fv algoritmus v\u00e1hy hran mezi sebou pouze porovn\u00e1v\u00e1.</p> <ul> <li>Pokud tedy pro ka\u017ed\u00fd element\u00e1rn\u00ed \u0159ez grafu G existuje pr\u00e1v\u011b jedna nejleh\u010d\u00ed hrana, pak m\u00e1 G pr\u00e1v\u011b jednu minim\u00e1ln\u00ed   kostru.</li> <li>Protip\u0159\u00edklad na obr\u00e1zku v\u00fd\u0161e ale ukazuje, \u017ee neplat\u00ed obr\u00e1cen\u00e1 implikace, tedy: Pokud m\u00e1 graf G pr\u00e1v\u011b jednu minim\u00e1ln\u00ed   kostru,   pak pro ka\u017ed\u00fd element\u00e1rn\u00ed \u0159ez grafu G (ne)existuje pr\u00e1v\u011b jedna nejleh\u010d\u00ed hrana.</li> </ul>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#def-11.2","title":"Element\u00e1rn\u00ed \u0159ezy v grafu","text":"<p>Nech\u0165 A je n\u011bjak\u00e1 podmno\u017eina vrchol\u016f grafu \\(G = (V, E)\\) a \\(B\\) jej\u00ed dopln\u011bk, tj. \\(B = V \\setminus A\\). Mno\u017ein\u011b v\u0161ech hran, kter\u00e9 le\u017e\u00ed jedn\u00edm vrcholem v \\(A\\) a druh\u00fdm v \\(B\\), budeme \u0159\u00edkat element\u00e1rn\u00ed \u0159ez grafu \\(G\\) ur\u010den\u00fd mno\u017einami \\(A\\) a \\(B\\).</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#theorem-11.2","title":"Lemma o \u0159ezech v grafu s unik\u00e1tn\u00edmi vahami","text":"<p>Nech\u0165 \\(G\\) je souvisl\u00fd ohodnocen\u00fd graf s unik\u00e1tn\u00edmi vahami, \\(R\\) n\u011bjak\u00fd jeho element\u00e1rn\u00ed \u0159ez a \\(e\\) nejleh\u010d\u00ed hrana tohoto \u0159ezu. Pak (ka\u017ed\u00e1) minim\u00e1ln\u00ed kostra grafu \\(G\\) obsahuje hranu \\(e\\).</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#theorem-11.3","title":"V\u011bta o minim\u00e1ln\u00ed kost\u0159e Jarn\u00edk","text":"<p>Souvisl\u00fd graf s unik\u00e1tn\u00edmi vahami m\u00e1 pr\u00e1v\u011b jednu minim\u00e1ln\u00ed kostru a Jarn\u00edk\u016fv algoritmus tuto kostru vytvo\u0159\u00ed.</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#korektnost-jarnikova-algoritmu-pro-neunikatni-vahy","title":"Korektnost Jarn\u00edkova algoritmu pro neunik\u00e1tn\u00ed v\u00e1hy","text":"<ul> <li>Pokud nejsou v\u00e1hy unik\u00e1tn\u00ed, m\u016f\u017ee v dan\u00e9 iteraci existovat n\u011bkolik nejleh\u010d\u00edch   hran \\(\\{a, b\\}\\), \\(a \\in V(T)\\), \\(b \\notin V(T)\\) a Jarn\u00edk\u016fv algoritmus v\u017edy jednu z nich vybere.</li> <li>Lemma o \u0159ezech sta\u010d\u00ed upravit n\u00e1sledovn\u011b.</li> </ul> <p>Lemma 11.4 (o \u0159ezech v grafu s opakuj\u00edc\u00edmi se vahami hran)</p> D\u016fkaz Lemmatu 11.4 <ul> <li>Ozna\u010dme \\(A\\) a \\(B\\) mno\u017einy vrchol\u016f, kter\u00fdmi je ur\u010den element\u00e1rn\u00ed \u0159ez \\(R\\).</li> <li>Nech\u0165 \\(T^\u2032\\) neobsahuje \\(e\\) a nech\u0165 \\(e = \\{a,b\\}\\).</li> <li>Bu\u010f \\(P\\) unik\u00e1tn\u00ed cesta mezi vrcholy \\(a\\) a \\(b\\) v \\(T^\u2032\\).</li> <li>Cesta \\(P\\) proch\u00e1z\u00ed element\u00e1rn\u00edm \u0159ezem \\(R\\).</li> <li>Nech\u0165 \\(f\\) je libovoln\u00e1 hrana v \\(E(P) \\cap R\\).</li> <li>Potom \\(T := T^\u2032 \u2212 f + e\\) je kostra a plat\u00ed, \u017ee \\(w(T) \\le w(T^\u2032)\\).</li> </ul> <p>D\u016fsledek</p> <p>Pokud G obsahuje v\u00edce minim\u00e1ln\u00edch koster d\u00edky existenci hran se stejnou vahou, pak Jarn\u00edk\u016fv algoritmus jednu z nich zkonstruuje.</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#theorem-11.4","title":"Lemma o \u0159ezech v grafu s opakuj\u00edc\u00edmi se vahami hran","text":"<p>Nech\u0165 \\(G\\) je souvisl\u00fd ohodnocen\u00fd graf, \\(R\\) je element\u00e1rn\u00ed \u0159ez v \\(G\\) a \\(e\\) je libovoln\u00e1 nejleh\u010d\u00ed hrana v \\(R\\). Pro ka\u017edou minim\u00e1ln\u00ed kostru \\(T^\u2032\\) existuje minim\u00e1ln\u00ed kostra \\(T\\) takov\u00e1, \u017ee</p> <ul> <li>\\(T^\u2032\\) a \\(T\\) se mohou li\u0161it pouze na hran\u00e1ch obsa\u017een\u00fdch v \\(R\\) a</li> <li>\\(T\\) obsahuje \\(e\\)</li> </ul>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.2_Jarn%C3%ADk%C5%AFv_algoritmus/#slozitost-jarnikova-algoritmu","title":"Slo\u017eitost Jarn\u00edkova algoritmu","text":"<p>Pozorov\u00e1n\u00ed</p> <p>Naivn\u00ed implementace Jarn\u00edkova algoritmu nad grafem \\(G = (V,E)\\), reprezentovan\u00fdm seznamem soused\u016f m\u00e1 \u010dasovou slo\u017eitost \\(O(|V| \\cdot |E|)\\) (\\(|V|\\) kr\u00e1t hled\u00e1me nejleh\u010d\u00ed hranu v seznamu nejv\u00fd\u0161e \\(|E|\\) hran) a pam\u011b\u0165ovou slo\u017eitost \\(O(|V| + |E|)\\).</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.3_Implementace_Jarn%C3%ADkova_algoritmu/","title":"11.3 Implementace Jarn\u00edkova algoritmu","text":"<ul> <li>V Jarn\u00edkov\u011b algoritmu opakovan\u011b vyb\u00edr\u00e1me nejleh\u010d\u00ed hranu a odstra\u0148ujeme ji ze seznamu.</li> <li>Z P\u0159edn\u00e1\u0161ky 4 v\u00edme, \u017ee efektivn\u00ed odeb\u00edr\u00e1n\u00ed minim z dynamicky se m\u011bn\u00edc\u00ed mno\u017einy dok\u00e1\u017ee bin\u00e1rn\u00ed halda.</li> <li> <p>Uka\u017eme si nyn\u00ed tedy implementaci pomoc\u00ed bin\u00e1rn\u00ed haldy.</p> </li> <li> <p>Vrcholy grafu \\(G\\) jsou udr\u017eov\u00e1ny v bin\u00e1rn\u00ed hald\u011b \\(H\\) uspo\u0159\u00e1dan\u00e9 podle hodnoty kl\u00ed\u010d\u016f \\(d\\), ur\u010duj\u00edc\u00edch \u201evzd\u00e1lenost\u201c   vrchol\u016f od dosud vybudovan\u00e9ho stromu v dan\u00e9m kroku algoritmu.</p> </li> <li>Na po\u010d\u00e1tku je \\(d(v)\\) nekone\u010dno pro v\u0161echny vrcholy a zvolen\u00fd \\(v_0\\) m\u00e1 nulu.</li> <li>Z haldy vybereme pomoc\u00ed ExtractMin vrchol \\(u\\) s minim\u00e1ln\u00edm \\(d\\), \u010d\u00edm\u017e ho p\u0159id\u00e1me ke stromu a p\u0159epo\u010dteme pro jeho   sousedy \\(v\\)   vzd\u00e1lenosti \\(d\\).</li> <li>Pokud se jejich \\(d\\) zm\u011bnilo, pomoc\u00ed DecreaseKey aktualizujeme haldu a vrchol \\(u\\) se st\u00e1v\u00e1 jejich p\u0159edch\u016fdcem.</li> <li>Minimum aktualizovan\u00e9 haldy je rovno v\u00e1ze nejleh\u010d\u00ed hrany v element\u00e1rn\u00edm \u0159ezu mezi nov\u00fdm \\(T\\) a zbytkem grafu.</li> </ul> <p></p> <p>V\u011bta 11.5 (o \u010dasov\u00e9 slo\u017eitosti Jarn\u00edkova algoritmu s bin\u00e1rn\u00ed haldou)</p> <p>\u010casov\u00e1 slo\u017eitost MinKostraJarn\u00edk p\u0159i pou\u017eit\u00ed bin\u00e1rn\u00ed haldy je \\(O(|E|\\ \\log|V|)\\).</p> D\u016fkaz v\u011bty 11.5 <ul> <li>Inicializace zabere \\(O(|V|)\\).</li> <li>Operace s bin\u00e1rn\u00ed haldou:<ul> <li>Provedeme \\(|V| \u2212 1\\) kr\u00e1t operaci HeapExtractMin \u2013 celkem \\(O(|V|\\ \\log|V|)\\).</li> <li>Ka\u017ed\u00e1 hrana m\u016f\u017ee zp\u016fsobit vol\u00e1n\u00ed operace HeapDecreaseKey \u2013 celkem \\(O(|E|\\ \\log |V|)\\).</li> </ul> </li> </ul> <p>Dohromady dost\u00e1v\u00e1me \\(O(|V|) + O(|V|\\ \\log|V|) + O(|E|\\ \\log|V|) = O(|E|\\ \\log|V|)\\).</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.4_Kruskal%C5%AFv_algoritmus/","title":"11.4 Kruskal\u016fv algoritmus","text":"<p>Algoritmus 11.2 (Kruskal\u016fv)  </p> <p></p> <p></p> <p>Lemma 11.6 (o korektnosti Kruskalova algoritmu)</p> <p>Kruskal\u016fv algoritmus se zastav\u00ed a vyd\u00e1 minim\u00e1ln\u00ed kostru.</p> D\u016fkaz lemmatu 11.6 <ul> <li>Kone\u010dnost: cyklus se vykon\u00e1 \\(m\\)-kr\u00e1t.</li> <li>Spr\u00e1vnost: Uk\u00e1\u017eeme nejd\u0159\u00edve, \u017ee pokud algoritmus p\u0159id\u00e1 hranu \\(e = \\{u,v\\}\\) do \\(T\\), pak \\(e\\) le\u017e\u00ed v minim\u00e1ln\u00ed kost\u0159e.</li> <li>Pokud algoritmus \\(e\\) p\u0159id\u00e1, stane se tak v okam\u017eiku, kdy se vrcholy \\(u\\) a \\(v\\) nach\u00e1zej\u00ed v n\u011bjak\u00fdch dvou rozd\u00edln\u00fdch stromech \\(T_u\\) a \\(T_v\\) lesa \\(T\\).</li> <li>Hrana \\(e\\) p\u0159itom le\u017e\u00ed v element\u00e1rn\u00edm \u0159ezu odd\u011bluj\u00edc\u00edm strom \\(T_u\\) od zbytku grafu.</li> <li>Hrana \\(e\\) mus\u00ed b\u00fdt nejleh\u010d\u00ed hrana element\u00e1rn\u00edho \u0159ezu odd\u011bluj\u00edc\u00edho strom \\(T_u\\) od zbytku grafu, nebo\u0165 p\u0159\u00edpadnou leh\u010d\u00ed hranu by algoritmus potkal d\u0159\u00edve a p\u0159idal by ji do \\(T\\).</li> <li>Hrana \\(e\\) tedy le\u017e\u00ed v minim\u00e1ln\u00ed kost\u0159e podle lemmatu o \u0159ezech.</li> <li>Nyn\u00ed si uk\u00e1\u017eeme, \u017ee v\u00fdsledn\u00fd \\(T\\) je souvisl\u00fd.</li> <li>Pokud by nebyl, uva\u017eme dva rozd\u00edln\u00e9 stromy \\(T_u\\) a \\(T_v\\) lesa \\(T\\) a element\u00e1rn\u00ed \u0159ez odd\u011bluj\u00edc\u00ed strom \\(T_u\\) od zbytku grafu.</li> <li>Proto\u017ee je graf \\(G\\) souvisl\u00fd, je tento element\u00e1rn\u00ed \u0159ez nepr\u00e1zdn\u00fd a m\u00e1 n\u011bjakou hranu \\(e\\).</li> <li>Kdy\u017e algoritmus zkoumal hranu \\(e\\), nemohla tvo\u0159it cyklus (netvo\u0159\u00ed ho ani ve v\u00fdsledn\u00e9m \\(T\\)), tak\u017ee by ji algoritmus musel p\u0159idat, co\u017e je spor.</li> <li>V\u00fdstupem algoritmu je tedy kostra, kter\u00e1 je podgrafem minim\u00e1ln\u00ed kostry \u2013 tedy minim\u00e1ln\u00ed kostra.</li> </ul>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.4_Kruskal%C5%AFv_algoritmus/#algo-11.2","title":"Algoritmus Kruskal","text":"<p>Vstup</p> <p>Souvisl\u00fd hranov\u011b ohodnocen\u00fd graf \\(G = (V,E)\\). Nech\u0165 \\(n = |V|\\) a \\(m = |E|\\).</p> <p>V\u00fdstup</p> <p>Minim\u00e1ln\u00ed kostra \\(G\\)</p> <p>Idea</p> <ul> <li>Kruskal\u016fv algoritmus je tak\u00e9 zalo\u017een na hladov\u00e9m p\u0159\u00edstupu:za\u010dne lesem tvo\u0159en\u00fdm pouze samotn\u00fdmi vrcholy bez hran a  zkou\u0161\u00ed p\u0159id\u00e1vat hrany od nejleh\u010d\u00ed po nejt\u011b\u017e\u0161\u00ed a zahazuje ty, kter\u00e9 by vytvo\u0159ily cyklus.</li> </ul> <p>Algoritmus</p> Algoritmus MinKostraKruskal(G = (V, E), w: E \u2192 R):<pre><code>Se\u0159a\u010f hrany podle vah: w(e1) \u2264 \u00b7 \u00b7 \u00b7 \u2264 w(em)\nT := (V, \u2205) //po\u010d\u00e1te\u010dn\u00ed les bez hran\nPro i := 1, . . . , m opakuj:\n    ozna\u010d u, v krajn\u00ed vrcholy hrany ei\n    Pokud u a v le\u017e\u00ed v r\u016fzn\u00fdch komponent\u00e1ch lesa T:\n        E(T) := E(T) \u222a {ei}\nVra\u0165 T\n</code></pre>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.5_Implementace_Kruskalova_algoritmu/","title":"11.5 Implementace Kruskalova algoritmu","text":"<p>Definice 11.3 (Struktura Union-Find)</p> <p></p> <p>Algoritmus 11.3 Implementace Kruskalova algoritmu s Union-Find</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.5_Implementace_Kruskalova_algoritmu/#def-11.3","title":"Struktura Union-Find","text":"<p>Struktura Union-Find reprezentuje rozklad mno\u017einy objekt\u016f \\(X\\) a podporuje operace:</p> <ul> <li>Init(\\(X\\)) vytvo\u0159\u00ed strukturu, ve kter\u00e9 je ka\u017ed\u00fd element z \\(X\\) ve vlastn\u00ed mno\u017ein\u011b.</li> <li>Find(\\(u\\)) vr\u00e1t\u00ed identifik\u00e1tor mno\u017einy obsahuj\u00edc\u00ed element \\(u\\).</li> <li>Union(\\(u,v\\))  sjednot\u00ed mno\u017einy obsahuj\u00edc\u00ed prvky \\(u\\) a \\(v\\) (pokud jsou ze stejn\u00e9 mno\u017einy, struktura z\u016fstane nezm\u011bn\u011bn\u00e1).</li> </ul>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.5_Implementace_Kruskalova_algoritmu/#algo-11.3","title":"Algoritmus Kruskal s Union-Find","text":"<p>Vstup</p> <p>Souvisl\u00fd graf G s vahami na hran\u00e1ch</p> <p>V\u00fdstup</p> <p>Kostra T s minim\u00e1ln\u00ed v\u00e1hou</p> <p>Idea</p> <ul> <li>Kruskal\u016fv algoritmus mus\u00ed nejprve se\u0159adit hrany. Na to pou\u017eijeme pochopiteln\u011b optim\u00e1ln\u00ed \u0159ad\u00edc\u00ed algoritmus.</li> <li>Za\u010dne s lesem izolovan\u00fdch vrchol\u016f a testuje postupn\u011b hrany, zda jejich vrcholy le\u017e\u00ed ve dvou r\u016fzn\u00fdch stromov\u00fdch komponent\u00e1ch lesa a pokud ano, spoj\u00ed tyto komponenty pomoc\u00ed t\u00e9to hrany do v\u011bt\u0161\u00ed.</li> <li>To vede na vyu\u017eit\u00ed struktury Union-Find</li> <li>Struktura Union-Find reprezentuje komponenty souvislosti aku\u00e1ln\u00edho grafu a operace pak speci\u00e1ln\u011b jsou:<ul> <li>Init(\\(V\\)) zalo\u017e\u00edme strukturu \u2013 ka\u017ed\u00fd vrchol je v samostatn\u00e9 komponent\u011b.</li> <li>Find(\\(u\\)) vr\u00e1t\u00ed identifik\u00e1tor komponenty, ve kter\u00e9 le\u017e\u00ed vrchol \\(u\\).</li> <li>Pokud pro testovanou hranu \\(\\{u,v\\}\\) plat\u00ed, \u017ee \\(u\\) a \\(v\\) pat\u0159\u00ed do r\u016fzn\u00fdch komponent (tj. Find\\((u)\\ne\\)Find\\((v)\\)), pak Union(\\(u,v\\)) tyto komponenty spoj\u00ed do jedn\u00e9 (p\u0159id\u00e1me \\(\\{u,v\\}\\) do konstruovan\u00e9 kostry).</li> </ul> </li> </ul> <p>Algoritmus</p> Algoritmus MinKostraKruskal(G = (V, E), w: E \u2192 R):<pre><code>Uspo\u0159\u00e1dej hrany podle vah: w(e1) \u2264 \u00b7 \u00b7 \u00b7 \u2264 w(em)\nT := (V, \u2205) //pocatecni les izolovan\u00fdch vrchol\u016f\nU := Init(V )\nPro i := 1, . . . , m opakuj:\n    ozna\u010d u, v krajn\u00ed vrcholy hrany ei\n    a := U \u2192 Find(u); b := U \u2192 Find(v);\n    Pokud a \u0338= b:\n        E(T) := E(T) \u222a {ei}\n        U \u2192 Union(a, b)\nVra\u0165 T\n</code></pre>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.5_Implementace_Kruskalova_algoritmu/#casova-slozitost-kruskalova-algoritmu","title":"\u010casov\u00e1 slo\u017eitost Kruskalova algoritmu","text":"<ul> <li>P\u0159ipome\u0148me, \u017ee \\(n = |V|\\) a \\(m = |E|\\).</li> <li>\u0158azen\u00ed hran trv\u00e1 \\(O(m \\log m) = O(m \\log {n^2}) = O(m \\log n)\\).</li> <li>Zbytek algoritmu testuje hrany pomoc\u00ed operace Find a spojuje men\u0161\u00ed stromy do v\u011bt\u0161\u00edch strom\u016f pomoc\u00ed operace Union.</li> </ul> <p>V\u011bta 11.7 (o \u010dasov\u00e9 slo\u017eitosti Kruskalova algoritmu)</p> <p>Kruskal\u016fv algoritmus vytvo\u0159\u00ed minim\u00e1ln\u00ed kostru v \u010dase \\(O(m \\log n + T_i(n) + m \\cdot T_f(n) + n \\cdot T_u(n))\\), kde \\(T_i(n), T_f(n)\\) a \\(T_u(n)\\) jsou \u010dasov\u00e9 slo\u017eitosti operac\u00ed Init, Find a Union v Union-Find struktu\u0159e nad mno\u017einou velikosti \\(n\\).</p> D\u016fkaz v\u011bty 11.7 <p>Zalo\u017e\u00ed strukturu Union-Find. P\u0159i testov\u00e1n\u00ed hran se nejv\u00fd\u0161e 2m-kr\u00e1t zavol\u00e1 Find a (n \u2212 1)-kr\u00e1t se zavol\u00e1 Union.</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.6_Union_Find_pokra%C4%8Dov%C3%A1n%C3%AD/","title":"11.6 Union Find pokra\u010dov\u00e1n\u00ed","text":""},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.6_Union_Find_pokra%C4%8Dov%C3%A1n%C3%AD/#implementace-struktury-union-find-pomoci-pole","title":"Implementace struktury Union-Find pomoc\u00ed pole","text":"<ul> <li>Trivi\u00e1ln\u00ed p\u0159\u00edstup: pou\u017eijeme pole, kter\u00e9 ka\u017ed\u00e9mu elementu p\u0159i\u0159ad\u00ed \u010d\u00edslo jeho mno\u017einy.</li> <li>Find p\u0159e\u010dte \u010d\u00edslo mno\u017einy z pole v konstantn\u00edm \u010dase.</li> <li>Union p\u0159i slu\u010dov\u00e1n\u00ed mno\u017ein projde v\u0161echny elementy jedn\u00e9 mno\u017einy a p\u0159i\u0159ad\u00ed jim \u010d\u00edslo t\u00e9 druh\u00e9.</li> </ul> <p>Pozorov\u00e1n\u00ed</p> <p>P\u0159i reprezentaci polem je \u010dasov\u00e1 slo\u017eitost</p> <ul> <li>Init\\(T_i(n) = O(n)\\),</li> <li>Find\\(T_f(n) = O(1)\\) a</li> <li>Union\\(T_u(n) = O(n)\\).</li> </ul> <p>\u010casov\u00e1 slo\u017eitost Kruskalova algoritmu by tedy byla \\(O(m \\log n + n + m + n^2) = O(m \\log n + n^2)\\).</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.6_Union_Find_pokra%C4%8Dov%C3%A1n%C3%AD/#implementace-struktury-union-find-pomoci-keriku","title":"Implementace struktury Union-Find pomoc\u00ed ke\u0159\u00edk\u016f","text":"<ul> <li>Ka\u017edou mno\u017einu, budeme reprezentovat stromem orientovan\u00fdm sm\u011brem do ko\u0159ene \u2013 budeme jim \u0159\u00edkat ke\u0159\u00edky.</li> <li>Zalo\u017een\u00e1 struktura je les, kter\u00fd m\u00e1 jednovrcholov\u00fd strom za ka\u017ed\u00fd element universa.</li> <li>Vrcholy ke\u0159\u00edku odpov\u00eddaj\u00ed element\u016fm p\u0159\u00edslu\u0161n\u00e9 mno\u017einy.</li> <li>Jako identifik\u00e1tory mno\u017ein pou\u017eijeme element ulo\u017een\u00fd v ko\u0159eni dan\u00e9ho ke\u0159\u00edku.</li> <li>V pam\u011bti budeme ke\u0159\u00edky reprezentovat \u00fasporn\u011b: ka\u017ed\u00fd element v si pamatuje \u201epouze\u201c identifik\u00e1tor sv\u00e9ho otce \\(p(v)\\).</li> <li>Ko\u0159eny ke\u0159\u00edk\u016f \\(v\\) maj\u00ed \\(p(v) = \\bot\\).</li> </ul>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.6_Union_Find_pokra%C4%8Dov%C3%A1n%C3%AD/#find-s-keriky","title":"Find s ke\u0159\u00edky","text":"<ul> <li>Operace Find(u) postupn\u011b vystoup\u00e1 ze zadan\u00e9ho elementu u do ko\u0159ene ke\u0159\u00edku a vr\u00e1t\u00ed tento ko\u0159en.</li> </ul> <p>Algoritmus 11.4 (Union-Find: Find s ke\u0159\u00edky)  </p> Algoritmus Find(u):<pre><code>Dokud p(u) \u0338= \u22a5:\n    u := p(u)\n Vra\u0165 u\n</code></pre> <p>Pozorov\u00e1n\u00ed</p> <p>\u010casov\u00e1 slo\u017eitost Find(\\(u\\)) je \\(O(\\)hloubka ke\u0159\u00edku elementu \\(u)\\).</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.6_Union_Find_pokra%C4%8Dov%C3%A1n%C3%AD/#union-s-keriky","title":"Union s ke\u0159\u00edky","text":"<ul> <li>Do ko\u0159ene \\(v\\) ka\u017ed\u00e9ho ke\u0159\u00edku ulo\u017e\u00edme hloubku ke\u0159\u00edku \\(H(v)\\).</li> <li>Na po\u010d\u00e1tku maj\u00ed v\u0161echny ke\u0159\u00edky hloubku \\(1\\).</li> <li>P\u0159i slu\u010dov\u00e1n\u00ed r\u016fzn\u011b hlubok\u00fdch ke\u0159\u00edk\u016f p\u0159ipoj\u00edme m\u011bl\u010d\u00ed ke\u0159\u00edk pod ko\u0159en toho hlub\u0161\u00edho a hloubka toho hlub\u0161\u00edho se nezm\u011bn\u00ed.</li> <li>Jsou-li oba ke\u0159\u00edky stejn\u011b hlubok\u00e9, rozhodneme se libovoln\u011b a v\u00fdsledn\u00fd ke\u0159\u00edk m\u00e1 hloubku o jedna v\u011bt\u0161\u00ed.</li> </ul> <p>Algoritmus 11.4 (Union-Find: Union s ke\u0159\u00edky)  </p> Algoritmus Union(u, v):<pre><code>a := Find(u)\nb := Find(v)\nJe-li a = b, skon\u010di\nPokud H(a) = H(b):\n    H(a) := H(a) + 1\n    p(b) := a\n    skon\u010di\nPokud H(a) &lt; H(b):\n    p(a) := b\nPokud H(a) &gt; H(b):\n    p(b) := a\n</code></pre>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.6_Union_Find_pokra%C4%8Dov%C3%A1n%C3%AD/#hloubka-keriku","title":"Hloubka ke\u0159\u00edk\u016f","text":"<p>Lemma 11.8 (o hloubce ke\u0159\u00edk\u016f)</p> <p>V\u00fd\u0161e popsan\u00fd algoritmus Union zachov\u00e1v\u00e1 invariant, \u017ee ke\u0159\u00edk s \\(h\\) hladinami obsahuje nejm\u00e9n\u011b \\(2^{h\u22121}\\) vrchol\u016f.</p> D\u016fkaz lemmatu 11.8 <ul> <li>Indukc\u00ed podle po\u010dtu operac\u00ed Union.</li> <li>Na po\u010d\u00e1tku algoritmu maj\u00ed v\u0161echny ke\u0159\u00edky jednu hladinu a \\(1\\) vrchol a \\(( 1 \\ge 2^{1\u22121} = 1)\\).</li> <li>Nech\u0165 nyn\u00ed prov\u00e1d\u00edme Union\\((u,v)\\) a po\u010det hladin obou ke\u0159\u00edk\u016f je r\u016fzn\u00fd.</li> <li>P\u0159ipojen\u00edm m\u011bl\u010d\u00edho ke\u0159\u00edku pod ko\u0159en toho hlub\u0161\u00edho se po\u010det hladin nezm\u011bn\u00ed a po\u010det vrchol\u016f neklesne, tak\u017ee nerovnost   st\u00e1le plat\u00ed.</li> <li>Pokud maj\u00ed oba ke\u0159\u00edky \\(h\\) hladin, plat\u00ed z induk\u010dn\u00edho p\u0159edpokladu, \u017ee ka\u017ed\u00fd z nich obsahuje minim\u00e1ln\u011b \\(2^{h\u22121}\\) vrchol\u016f.</li> <li>Jejich slou\u010den\u00edm tud\u00ed\u017e vznikne ke\u0159\u00edk s \\(h + 1\\) hladinami o alespo\u0148 \\(2 \\cdot 2^{h\u22121} = 2^h\\) vrcholech.</li> </ul> <p>D\u016fsledek</p> <p>Hloubka ke\u0159\u00edk\u016f b\u011bhem prov\u00e1d\u011bn\u00ed v\u00fd\u0161e popsan\u00e9ho algoritmu Union\\((u,v)\\) nep\u0159ekro\u010d\u00ed \\(\\log n\\).</p> D\u016fkaz d\u016fsledku <p>Strom s v\u011bt\u0161\u00edm po\u010dtem hladin by podle invariantu obsahoval v\u00edce ne\u017e n vrchol\u016f</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.6_Union_Find_pokra%C4%8Dov%C3%A1n%C3%AD/#slozitost-kruskalova-algoritmu-s-keriky","title":"Slo\u017eitost Kruskalova algoritmu s ke\u0159\u00edky","text":"<ul> <li> <p>Z p\u0159edchoz\u00edho plyne, \u017ee v ke\u0159\u00edkov\u00e9 reprezentaci je \u010dasov\u00e1 slo\u017eitost operace</p> <ul> <li>Init \\(T_i(n) = O(n)\\),</li> <li>Find \\(T_f(n) = O(\\log n)\\) a</li> <li>Union \\(T_u(n) = O(\\log n)\\) (my dokonce vol\u00e1me jen na ko\u0159eny, tak\u017ee lze po\u010d\u00edtat \\(O(1)\\)).</li> </ul> </li> <li> <p>A proto dostaneme</p> </li> </ul> \\[O(m \\log n + T_i(n) + m \\cdot T_f(n) + n \\cdot T_u(n)) =\\] \\[O(m \\log(n) + n + m \\cdot log(n) + n \\cdot log(n)) \\in O(m \\log n)\\] <p>D\u016fsledek  (v\u011bty o \u010dasov\u00e9 slo\u017eitosti Kruskalova algoritmu)</p> <p>Kruskal\u016fv algoritmus s ke\u0159\u00edkovou strukturou pro Union-Find vytvo\u0159\u00ed minim\u00e1ln\u00ed kostru v \u010dase \\(O(|E| \\log|V|)\\).</p>"},{"location":"11_Minim%C3%A1ln%C3%AD_kostry_grafu/11.6_Union_Find_pokra%C4%8Dov%C3%A1n%C3%AD/#struktura-union-find-obecne","title":"Struktura Union-Find obecn\u011b","text":"<ul> <li>Kruskal\u016fv algoritmus je velmi zn\u00e1m\u00e1 aplikace datov\u00e9 struktury Union-Find, ale ne jedin\u00e1.</li> <li>Struktura Union-Find je vhodn\u00e1 a p\u0159irozen\u00e1 pro algoritmick\u00e9 (snadno paralelizovateln\u00e9) \u0159e\u0161en\u00ed dal\u0161\u00edch probl\u00e9m\u016f, nap\u0159.<ul> <li>Konstrukce souvisl\u00fdch komponent grafu.</li> <li>Detekce cyklu v grafu.</li> <li>Konstrukce bludi\u0161t\u011b.</li> <li>Odvozov\u00e1n\u00ed typu prom\u011bnn\u00fdch v dynamick\u00fdch programovac\u00edch jazyc\u00edch.</li> </ul> </li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.1_Ohodnocen%C3%BD_graf/","title":"12.1 Ohodnocen\u00fd graf","text":"<p>Definice 12.1 (Ohodnocen\u00fd orientovan\u00fd graf)</p> <p></p> <p>Definice 12.2 (Vzd\u00e1lenost v ohodnocen\u00e9m grafu)</p> <p></p> <p>Definice 12.3 (Nejkrat\u0161\u00ed cesta v ohodnocen\u00e9m grafu)</p> <p></p> <p>Definice 12.4 (Sled v ohodnocen\u00e9m grafu)</p> <p></p> <p>Lemma (o zjednodu\u0161en\u00ed sled\u016f)</p> <p>D\u016fsledek - Nejkrat\u0161\u00ed cesta</p> <p>Pokud jsou d\u00e9lky hran v \\(G = (V, E)\\) kladn\u00e9, pak pro libovoln\u00e9 dva vrcholy \\(u, v \u2208 V\\) existuje nejkrat\u0161\u00ed \\(uv\\)-sled a ten je sou\u010dasn\u011b nejkrat\u0161\u00ed \\(uv\\)-cestou.</p> D\u016fkaz <ul> <li>Nejkrat\u0161\u00ed cesta je jedn\u00edm ze sled\u016f.</li> <li>Pokud by tvrzen\u00ed neplatilo, musel by existovat n\u011bjak\u00fd krat\u0161\u00ed sled. Ten by ov\u0161em, podle p\u0159edchoz\u00edho lemmatu, \u0161el zjednodu\u0161it na je\u0161t\u011b krat\u0161\u00ed cestu.</li> </ul> <p>D\u016fsledek - Troj\u00faheln\u00edkov\u00e1 nerovnost</p> <p>Jsou-li d\u00e9lky hran kladn\u00e9, plat\u00ed pro vzd\u00e1lenosti troj\u00faheln\u00edkov\u00e1 nerovnost: \\(d(u, v) \u2264 d(u, w) + d(w, v)\\) pro libovoln\u00e9 \\(u, v, w \u2208 V\\) .</p> <p></p> D\u016fkaz <ul> <li>Pokud je \\(d(u, w)\\) nebo \\(d(w, v)\\) nekone\u010dn\u00e1, nerovnost trivi\u00e1ln\u011b plat\u00ed.</li> <li>V opa\u010dn\u00e9m p\u0159\u00edpad\u011b uva\u017eme spojen\u00ed nejkrat\u0161\u00ed \\(uw\\)-cesty s nejkrat\u0161\u00ed \\(wv\\)-cestou. To je n\u011bjak\u00fd \\(uv\\)-sled d\u00e9lky \\(d(u, w) + d(w, v)\\) a ten, podle p\u0159edchoz\u00edho d\u016fsledku, nem\u016f\u017ee b\u00fdt krat\u0161\u00ed ne\u017e nejkrat\u0161\u00ed \\(uv\\)-cesta, kter\u00e1 m\u00e1 d\u00e9lku \\(d(u, v)\\).</li> </ul> <p>D\u016fsledek - Vrcholy na nejkrat\u0161\u00ed cest\u011b</p> <p>Nech\u0165 jsou d\u00e9lky hran kladn\u00e9, \\(P\\) je nejkrat\u0161\u00ed \\(uv\\)-cesta a \\(w\\) le\u017e\u00ed na \\(P\\). Ozna\u010dme \\(P_{uw}\\) \u010d\u00e1st \\(P\\) mezi \\(u\\) a \\(w\\) a \\(P_{wv}\\) \u010d\u00e1st \\(P\\) mezi \\(w\\) a \\(v\\). Pak \\(P_{uw}\\) je nejkrat\u0161\u00ed \\(uw\\)-cesta a \\(P_{wv}\\) je nejkrat\u0161\u00ed \\(wv\\)-cesta.</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.1_Ohodnocen%C3%BD_graf/#def-12.1","title":"Ohodnocen\u00fd orientovan\u00fd graf","text":"<ul> <li>M\u011bjme orientovan\u00fd graf \\(G = (V, E)\\).  Ka\u017ed\u00e9 hran\u011b \\(e \\in E\\) p\u0159i\u0159ad\u00edme \u010d\u00edselnou v\u00e1hu \\(w(e)\\), kde \\(w: E \\to R\\). Takov\u00fd graf se naz\u00fdv\u00e1 hranov\u011b ohodnocen\u00fd.</li> <li>V\u00e1hovou funkci m\u016f\u017eeme p\u0159irozen\u011b roz\u0161\u00ed\u0159it na podgrafy: V\u00e1ha \\(w(H)\\) podgrafu \\(H \\subseteq G\\) je sou\u010det vah jeho hran.</li> <li>Vstup pro probl\u00e9m nejkrat\u0161\u00edch cest je podobn\u00fd. Ohodnocen\u00ed hrany interpretujeme jako jej\u00ed d\u00e9lku, zna\u010d\u00edme \u2113(e).</li> <li>D\u00e9lku hrany m\u016f\u017eeme p\u0159irozen\u011b roz\u0161\u00ed\u0159it i na cesty: d\u00e9lka cesty je sou\u010det d\u00e9lek jej\u00edch hran. <p>V p\u0159edn\u00e1\u0161ce definov\u00e1no pomoc\u00ed definice z probl\u00e9mu minim\u00e1ln\u00ed kostry.</p> </li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.1_Ohodnocen%C3%BD_graf/#def-12.1","title":"Vzd\u00e1lenost v ohodnocen\u00e9m grafu","text":"<p>Pro libovoln\u00e9 dva vrcholy u a v ohodnocen\u00e9ho orientovan\u00e9ho grafu, vzd\u00e1lenost \\(d(u, v)\\) je minimum z d\u00e9lek v\u0161ech \\(uv\\)-cest (cest z \\(u\\) do \\(v\\)), p\u0159\u00edpadn\u011b +\u221e, pokud \u017e\u00e1dn\u00e1 \\(uv\\)-cesta neexistuje.</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.1_Ohodnocen%C3%BD_graf/#def-12.3","title":"Nejkrat\u0161\u00ed cesta v ohodnocen\u00e9m grafu","text":"<p>je libovoln\u00e1 \\(uv\\)-cesta, jej\u00ed\u017e d\u00e9lka je rovn\u00e1 vzd\u00e1lenosti \\(d(u, v)\\).</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.1_Ohodnocen%C3%BD_graf/#def-12.4","title":"Sled v ohodnocen\u00e9m grafu","text":"<p>Posloupnost (\\(v_0\\), \\(e_1\\), \\(v_1\\), . . . , \\(e_k\\), \\(v_k\\)) v orientovan\u00e9m grafu \\(G = (V, E)\\) se naz\u00fdv\u00e1 \\(v_0v_k\\)-sled (nebo kr\u00e1tce sled), pokud \\(vi \u2208 V\\) pro v\u0161echna \\(i \u2208 {0, . . . , k}\\) a \\(e_i = (v_{i\u22121}, v_i) \u2208 E\\) pro v\u0161echna \\(i \u2208 {1, . . . , k}\\).</p> <p>D\u00e9lka \\(\u2113(S)\\) sledu \\(S\\) je sou\u010det d\u00e9lek jeho hran.</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.1_Ohodnocen%C3%BD_graf/#theorem-12.1","title":"Lemma (o zjednodu\u0161en\u00ed sled\u016f)","text":"<p>Pokud jsou d\u00e9lky hran kladn\u00e9, pak pro ka\u017ed\u00fd \\(uv\\)-sled existuje \\(uv\\)-cesta stejn\u00e9 nebo men\u0161\u00ed d\u00e9lky.</p> <p></p> D\u016fkaz v\u011bty 12.1 <ul> <li>Pokud sled nen\u00ed cestou, znamen\u00e1 to, \u017ee se v n\u011bm opakuj\u00ed vrcholy.</li> <li>Ozna\u010dme tedy t prvn\u00ed vrchol (v po\u0159ad\u00ed od u), kter\u00fd se opakuje.</li> <li>\u010c\u00e1st sledu mezi prvn\u00edm a posledn\u00edm v\u00fdskytem vrcholu \\(t\\) vyst\u0159ihneme a z\u00edsk\u00e1me \\(uv\\)-sled stejn\u00e9 nebo men\u0161\u00ed d\u00e9lky, proto\u017ee d\u00e9lky hran jsou kladn\u00e9.</li> <li>P\u0159itom ubyla alespo\u0148 jedna hrana, tak\u017ee opakov\u00e1n\u00edm tohoto postupu \u010dasem dostaneme cestu.</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/","title":"12.2 Dijkstr\u016fv algoritmus","text":""},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#hledani-nejkratsich-cest","title":"Hled\u00e1n\u00ed nejkrat\u0161\u00edch cest","text":"<p>Fakt (bez d\u016fkazu)</p> <p>Probl\u00e9m nalezen\u00ed d\u00e9lky nejkrat\u0161\u00ed cesty mezi dv\u011bma vrcholy pro graf ohodnocen\u00fd obecn\u00fdmi (tedy i z\u00e1porn\u00fdmi) d\u00e9lkami je NP-t\u011b\u017ek\u00fd \u2013 proto pro n\u011bj neo\u010dek\u00e1v\u00e1me existenci efektivn\u00edho algoritmu.</p> <ul> <li>Pro n\u011bkter\u00e1 speci\u00e1ln\u00ed ohodnocen\u00ed grafu efektivn\u00ed algoritmy existuj\u00ed. Dva nejpou\u017e\u00edvan\u011bj\u0161\u00ed jsou:<ul> <li>Dijkstr\u016fv, kter\u00fd p\u0159edpokl\u00e1d\u00e1 kladn\u00e9 d\u00e9lky hran (p\u0159\u00edpadn\u011b nez\u00e1porn\u00e9).</li> <li>Bellman\u016fv-Ford\u016fv, kter\u00fd p\u0159ipou\u0161t\u00ed z\u00e1porn\u00e9 d\u00e9lky, ale p\u0159edpokl\u00e1d\u00e1 neexistenci z\u00e1porn\u00fdch cykl\u016f v grafu.</li> </ul> </li> </ul> <p></p> <p>\u00daprava BFS pro p\u0159irozen\u00e9 v\u00e1hy</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#algo-12.1","title":"\u00daprava BFS pro p\u0159irozen\u00e9 v\u00e1hy","text":"<p>Ka\u017edou hranu \"podrozd\u011bl\u00edme\" \u2013 nahrad\u00edme ji cestou tvo\u0159enou tolika jednotkov\u00fdmi hranami, kolik \u010dinila d\u00e9lka hrany. </p> <p>T\u00edm vznikne neohodnecon\u00fd graf, ve kter\u00e9m lze pou\u017e\u00edt BFS pro hled\u00e1n\u00ed nejkrat\u0161\u00edch cest.</p> <ul> <li>Tento algoritmus je funk\u010dn\u00ed, ale neefektivn\u00ed<ul> <li>Ozna\u010d\u00edme-li L maxim\u00e1ln\u00ed d\u00e9lku hrany, podrozd\u011blen\u00edm vznikne \\(O(L \u00b7 m)\\) nov\u00fdch vrchol\u016f a hran.</li> <li>Slo\u017eitost BFS algoritmu tedy bude \\(\u0398(L \u00b7 m + n)\\).</li> </ul> </li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#dijkstruv-algoritmus","title":"Dijkstr\u016fv algoritmus","text":"<p>Dijkstra je zobecn\u011bn\u00edm pr\u016fchodu grafu do \u0161\u00ed\u0159ky.</p> <p>M\u00edsto simulace pr\u016fchodu BFS vlny v line\u00e1rn\u00edm \u010dase vzhledem k d\u00e9lce hran, Dijkstra zpracuje ka\u017edou hranu v \\(O(1)\\) \u010dase.</p> <p>Vstup: Orientovan\u00fd graf \\(G = (V, E)\\) s kladn\u00fdmi d\u00e9lkami hran \\(\\ell : E \\to \\mathbb{R}^+\\) a po\u010d\u00e1te\u010dn\u00ed vrchol \\(v_0\\).</p> <p>V\u00fdstup:Vzd\u00e1lenosti z vrcholu \\(v_0\\) do v\u0161ech vrchol\u016f grafu \\(G\\).</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#zakladni-idea-dijkstra","title":"Z\u00e1kladn\u00ed idea Dijkstra","text":"<ul> <li>U ka\u017ed\u00e9ho p\u016fvodn\u00edho vrcholu si udr\u017eujeme \"bud\u00edk\" - kdy by do vrcholu dorazila BFS vlna.</li> <li>Poka\u017ed\u00e9 vybereme sousedn\u00ed vrchol s nejmen\u0161\u00ed hodnotou bud\u00edku a pod\u00edv\u00e1me se na jeho n\u00e1sledn\u00edky.</li> <li>Pokud by se n\u011bkter\u00fd z nich dostal do vrcholu d\u0159\u00edve, aktualizujeme jeho bud\u00edk.</li> <li>Toto opakujeme dokud \"nezazvon\u00ed bud\u00edk\" v\u0161ech vrchol\u016f.</li> </ul> <ul> <li>\u010cas na bud\u00edku vrcholu \\(v\\) ozn. \\(h(v)\\).</li> <li>Po\u010d\u00e1te\u010dn\u00ed hodnota \\(h(v_0) = 0\\). a \\(h(v) = \u221e\\) pro v\u0161echny ostatn\u00ed vrcholy.</li> <li>Podobn\u011b jako u BFS m\u016f\u017ee m\u00edt vrchol t\u0159i stavy:<ul> <li>Nenalezen\u00e9</li> <li>Otev\u0159en\u00e9 (bud\u00edk je nastaven\u00fd)</li> <li>Uzav\u0159en\u00e9 (bud\u00edk ji\u017e zazvonil)</li> </ul> </li> <li>D\u00e1le si pamatujeme, kter\u00fd vrchol je p\u0159edch\u016fdce dan\u00e9ho vrcholu na nejkrat\u0161\u00ed cest\u011b.</li> </ul> <p>Dijkstr\u016fv algoritmus (pseudok\u00f3d)</p> <p></p> <p>Relaxace vrchol\u016f</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#algo-12.3","title":"Dijkstr\u016fv algoritmus (pseudok\u00f3d)","text":"<pre><code>Algoritmus Dijkstra(G, \u2113 : E \u2192 R+, v0)\n Pro v\u0161echny vrcholy v:\n     stav(v) := nenalezen\u00fd\n     h(v) := +\u221e; P (v) := \u22a5\n stav(v0) := otev\u0159en\u00fd\n h(v0) := 0\n Dokud existuj\u00ed n\u011bjak\u00e9 otev\u0159en\u00e9 vrcholy:\n     Vyber otev\u0159en\u00fd vrchol v, jeho\u017e h(v) je nejmen\u0161\u00ed.\n     Pro v\u0161echny n\u00e1sledn\u00edky w vrcholu v: //relaxace v\n         Pokud h(w) &gt; h(v) + \u2113((v, w)):\n             h(w) := h(v) + \u2113((v, w))\n             stav(w) := otev\u0159en\u00fd\n             P (w) := v\n     stav(v) := uzav\u0159en\u00fd\n Vra\u0165 pole vzd\u00e1lenost\u00ed h a pole p\u0159edch\u016fdc\u016f P\n</code></pre>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#def-12.5","title":"Relaxace vrchol\u016f","text":"<ul> <li>P\u0159epo\u010d\u00edt\u00e1n\u00ed ohodnocen\u00ed \\(h(w)\\) pro v\u0161echny n\u00e1sledn\u00edky \\(w\\) vrcholu \\(v\\) v Dijkstra na \u0159\u00e1dc\u00edch (9)\u00a0\u2013\u00a0(14) budeme naz\u00fdvat relaxace vrcholu \\(v\\) <pre><code>    Pro v\u0161echny n\u00e1sledn\u00edky w vrcholu v: //relaxace v\n        Pokud h(w) &gt; h(v) + \u2113((v, w)):\n            h(w) := h(v) + \u2113((v, w))\n            stav(w) := otev\u0159en\u00fd\n            P (w) := v\n    stav(v) := uzav\u0159en\u00fd\n</code></pre></li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#konecnost-a-spravnost-dijkstra","title":"Kone\u010dnost a spr\u00e1vnost Dijkstra","text":"<p>V\u011bta o kone\u010dnosti Dijkstrova algoritmu</p> <p>Tuto v\u011btu dok\u00e1\u017eeme kombinac\u00ed 4 vlastnost\u00ed Dijkstra:</p> <ul> <li>Vlastnost O (Ohodnocen\u00ed)</li> <li>Vlastnost M (Monotonie)</li> <li>Vlastnost D (Dosa\u017eitelnost)</li> <li>Vlastnost V (Vzd\u00e1lenost)</li> </ul> <p></p> <p>Vlastnost O (Ohodnocen\u00ed)</p> <p></p> <p>Vlastnost M (Monotonie)</p> <p></p> <p>Vlastnost D (Dosa\u017eitelnost)</p> <p></p> <p>Vlastnost V (Vzd\u00e1lenost)</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#theorem-12.2","title":"V\u011bta o kone\u010dnosti Dijkstrova algoritmu","text":"<p>Dijkstra na grafu s kladn\u00fdmi d\u00e9lkami hran se v kone\u010dn\u00e9m \u010dase zastav\u00ed a po jeho skon\u010den\u00ed budou v\u0161echny dosa\u017eiteln\u00e9 vrcholy \\(v\\) uzav\u0159eny s \\(h(v) = d(v_0, v)\\).</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#def-12.6","title":"Vlastnost O (Ohodnocen\u00ed)","text":"<p>Ohodnocen\u00ed \\(h(v)\\) v pr\u016fb\u011bhu Dijkstra nikdy neroste a je-li kone\u010dn\u00e9, rovn\u00e1 se d\u00e9lce n\u011bjak\u00e9ho sledu z \\(v_0\\) do \\(v\\).</p> D\u016fkaz vlastnosti O <ul> <li>Indukc\u00ed podle doby b\u011bhu Dijkstra.</li> <li>Na po\u010d\u00e1tku v\u00fdpo\u010dtu tvrzen\u00ed ur\u010dit\u011b plat\u00ed, proto\u017ee jedin\u00e9 kone\u010dn\u00e9 ohodnocen\u00ed je \\(h(v_0) = 0\\).</li> <li>Kdykoliv Dijkstra sni\u017euje ohodnocen\u00ed \\(h(w)\\), stane se tak relaxac\u00ed otev\u0159en\u00e9ho vrcholu \\(v\\) s kone\u010dn\u00fdm \\(h(v)\\), jeho\u017e n\u00e1sledn\u00edkem je \\(w\\).</li> <li>Podle induk\u010dn\u00edho p\u0159edpokladu tedy existuje \\(v_0-v\\)-sled d\u00e9lky \\(h(v)\\).</li> <li>Jeho roz\u0161\u00ed\u0159en\u00edm o hranu \\(vw\\) vznikne \\(v_0w\\)-sled d\u00e9lky \\(h(v) + \u2113((v, w))\\), co\u017e je p\u0159esn\u011b nov\u00e1 kone\u010dn\u00e1 hodnota \\(h(w)\\).     </li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#def-12.7","title":"Vlastnost M (Monotonie)","text":"<p>V ka\u017ed\u00e9m kroku v\u00fdpo\u010dtu plat\u00ed, \u017ee \\(h(z) \u2264 h(o)\\) pro \\(z\\) uzav\u0159en\u00fd vrchol a \\(o\\) otev\u0159en\u00fd vrchol. Speci\u00e1ln\u011b pak plat\u00ed, \u017ee Dijkstra nikdy neotev\u0159e ji\u017e uzav\u0159en\u00fd vrchol.</p> D\u016fkaz vlastnosti M <ul> <li>V\u017edy vybereme otev\u0159en\u00fd vrchol \\(v\\) s nejmen\u0161\u00edm \\(h(v)\\).</li> <li>P\u0159ed relaxac\u00ed \\(v\\) tedy mus\u00ed platit \\(h(z) \u2264 h(v) \u2264 h(o)\\) pro libovoln\u00fd \\(z\\) uzav\u0159en\u00fd a \\(o\\) otev\u0159en\u00fd.</li> <li>Nyn\u00ed vrchol \\(v\\) relaxujeme:<ul> <li>Pokud \\(w\\) byl uzav\u0159en\u00fd, nem\u016f\u017ee se jeho hodnota zm\u011bnit, nebo\u0165 ji\u017e p\u0159ed relaxac\u00ed platilo \\(h(w) \u2264 h(v)\\).</li> <li>Pokud \\(w\\) byl otev\u0159en\u00fd nebo nenalezen\u00fd, jeho hodnota se sice m\u016f\u017ee sn\u00ed\u017eit na \\(h(v) + \u2113(v, w)\\), ale nikdy ne pod \\(h(v)\\), tak\u017ee ani pod \\(h(z)\\) \u017e\u00e1dn\u00e9ho uzav\u0159en\u00e9ho \\(z\\).</li> </ul> </li> <li>Kdybychom otev\u0159eli ji\u017e uzav\u0159en\u00fd vrchol \\(z\\), muselo by platit \\(h(v) + \u2113(v, z) \u2264 h(z)\\), co\u017e nelze.</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#def-12.8","title":"Vlastnost D (Dosa\u017eitelnost)","text":"<p>Kdy\u017e se Dijkstra zastav\u00ed, uzav\u0159en\u00e9 jsou pr\u00e1v\u011b vrcholy dosa\u017eiteln\u00e9 z \\(v_0\\). </p> D\u016fkaz vlastnosti D <ul> <li>Dok\u00e1\u017eeme stejn\u011b jako obdobnou vlastnost BFS.</li> <li>Prvn\u00ed otev\u0159en\u00fdm a n\u00e1sledn\u011b uzav\u0159en\u00fdm vrcholem je \\(v_0\\).</li> <li>Vrchol je otev\u0159en, pr\u00e1v\u011b kdy\u017e je do t\u00e9 doby nenalezen\u00fdm n\u00e1sledn\u00edkem d\u0159\u00edve otev\u0159en\u00e9ho vrcholu a tud\u00ed\u017e je dosa\u017eiteln\u00fd z \\(v_0\\).</li> <li>Proto\u017ee Dijkstra dle Vlastnosti M, nikdy neotev\u0159e ji\u017e uzav\u0159en\u00fd vrchol, zbytek d\u016fkazu je toto\u017en\u00fd s BFS:<ul> <li>Kdyby tedy existoval n\u011bjak\u00fd dosa\u017eiteln\u00fd, ale neuzav\u0159en\u00fd vrchol, existoval by ten \u201enejbli\u017e\u0161\u00ed\u201c (co do po\u010dtu hran na nejkrat\u0161\u00ed cest\u011b) a to by vedlo ke sporu.</li> </ul> </li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#def-12.9","title":"Vlastnost V (Vzd\u00e1lenost)","text":"<p>Kdy\u017e se Dijkstra zastav\u00ed, je \\(h(w) = d(v_0, w)\\) pro v\u0161echny \\(w \u2208 V\\).</p> D\u016fkaz vlastnosti V <p>Vrchol \\(w\\) dosa\u017eiteln\u00fd z \\(v_0\\) nazveme \u0161patn\u00fd, pokud \\(h(w) \\ne d(v0, w)\\). Z Vlastnosti O v\u00edme, \u017ee \\(h(w)\\) odpov\u00edd\u00e1 d\u00e9lce n\u011bjak\u00e9ho \\(v_0w\\)-sledu a tedy \\(h(w) &gt; d(v_0, w)\\).</p> <ul> <li>Pro spor p\u0159edpokl\u00e1dejme, \u017ee existuje n\u011bjak\u00fd \u0161patn\u00fd vrchol \\(w\\) (Podobn\u011b jako u BFS).</li> <li>V\u00edme, \u017ee v0 nen\u00ed \u0161patn\u00fd, proto\u017ee \\(h(v_0) = 0 = d(v_0, v_0)\\).</li> <li>Bu\u010f \\(w\\) \u0161patn\u00fd vrchol takov\u00fd, \u017ee nejkrat\u0161\u00ed cesta v \\(G\\) z \\(v_0\\) do \\(w\\) pou\u017e\u00edv\u00e1 nejmen\u0161\u00ed mo\u017en\u00fd po\u010det hran.</li> <li>Bu\u010f \\(v\\) p\u0159edch\u016fdce \\(w\\) na t\u00e9to cest\u011b z \\(v_0\\).</li> <li>Kdyby \\(v\\) byl \u0161patn\u00fd, volili bychom \\(v\\) nam\u00edsto \\(w\\). Tedy plat\u00ed  \\(h(v) = d(v_0, v)\\).</li> <li>Vrchol \\(v\\) byl jist\u011b n\u011bkdy otev\u0159en\u00fd a pozd\u011bji relaxovan\u00fd. P\u0159i jeho relaxaci byla aktu\u00e1ln\u00ed hodnota \\(h(w)\\) v\u011bt\u0161\u00ed ne\u017e \\(d(v_0, w)\\) (nebo\u0165 toto plat\u00ed dokonce a\u017e po zastaven\u00ed Dijkstra).</li> <li>V tom p\u0159\u00edpad\u011b ale po relaxaci \\(v\\) muselo platit \\(h(w) = d(v_0, v) + \u2113((v, w)) = d(v_0, w)\\). Spor.</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#vlastnost-sledu-v-dijkstra","title":"Vlastnost sled\u016f v Dijkstra","text":"<p>Lemma</p> <p>Je-li po uzav\u0159en\u00ed vrcholu v algoritmu Dijkstra \\(h(v)\\) kone\u010dn\u00e9 pro n\u011bjak\u00fd vrchol \\(v\\), rovn\u00e1 se d\u00e9lce nejkrat\u0161\u00ed \\(v_0v\\)-cesty, kter\u00e1 jako vnit\u0159n\u00ed vrcholy pou\u017e\u00edv\u00e1 pouze uzav\u0159en\u00e9 vrcholy.</p> D\u016fkaz vlastnosti sled\u016f v Dijkstra <ul> <li>Indukc\u00ed podle po\u010dtu uzav\u0159en\u00fdch vrchol\u016f.</li> <li>Pro \\(k = 0\\) plat\u00ed, nebo\u0165 jedin\u00e9 kone\u010dn\u00e9 je \\(h(v_0) = 0\\).</li> <li>Pro induk\u010dn\u00ed krok, kdy relaxujeme a tedy uzav\u00edr\u00e1me \\(v\\), uv\u00e1\u017e\u00edme dva p\u0159\u00edpady:<ul> <li>Relaxace \\(v\\) nezm\u011bnila \\(h(w)\\). Pak z IP tvrzen\u00ed plat\u00ed.</li> <li>Relaxace \\(v\\) zm\u011bnila \\(h(w)\\). Pak dle Vlastnosti O \\(h(w)\\) odpov\u00edd\u00e1 d\u00e9lce nejkrat\u0161\u00ed \\(v_0v\\)-cesty prota\u017een\u00e9 o hranu \\((v, w)\\).</li> <li>Proto\u017ee nyn\u00ed ale je \\(v\\) uzav\u0159en\u00fd a \\(v_0v\\)-cesta (dle IP) pou\u017e\u00edvala jako vnit\u0159n\u00ed vrcholy jen uzav\u0159en\u00e9 vrcholy, plat\u00ed tato vlastnost i pro \\(w\\).</li> </ul> </li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#slozitost-dijkstra-bez-binarni-haldy-priority-queue","title":"Slo\u017eitost Dijkstra bez bin\u00e1rn\u00ed haldy (priority queue)","text":"<p>Pokud jsou d\u00e9lky hran kladn\u00e9, potom Dijkstra nad souvisl\u00fdm grafem o \\(n\\) vrcholech b\u011b\u017e\u00ed v \u010dase \\(O(n^2)\\).</p> <p>V grafech s mal\u00fdm po\u010dtem hran je odhad \\(O(n^2)\\) zbyte\u010dn\u011b nadhodnocen\u00fd. Celkov\u00fd po\u010det operac\u00ed na \u0159\u00e1dku (11) je pouze \\(O(m)\\), ale brzd\u00ed n\u00e1s hled\u00e1n\u00ed minima: \\(O(n)\\).</p> D\u016fkaz slo\u017eitosti Dijkstrova algoritmu <ul> <li>Inicializace trv\u00e1 \\(O(n)\\).</li> <li>Ka\u017ed\u00fd vrchol uzav\u0159eme nejv\u00fd\u0161e jednou.</li> <li>Vn\u011bj\u0161\u00edm cyklem projdeme nejv\u00fd\u0161e \\(n\\)-kr\u00e1t.</li> <li>Poka\u017ed\u00e9 hled\u00e1me minimum a\u017e z \\(n\\) ohodnocen\u00ed vrchol\u016f a proch\u00e1z\u00edme a\u017e \\(n\\) n\u00e1sledn\u00edk\u016f.</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#dijkstra-s-binarni-haldou","title":"Dijkstra s bin\u00e1rn\u00ed haldou","text":"<p>Podobn\u011b jako u Jarn\u00edkova algoritmu, pou\u017eijeme (bin\u00e1rn\u00ed) haldu, kl\u00ed\u010dem \\(v\\) bude hodnocen\u00ed \\(h(v)\\).</p> <p></p> <p>Dijkstra s bin\u00e1rn\u00ed haldou</p> <p></p> <p>V\u011bta o \u010dasov\u00e9 slo\u017eitosti Dijkstra s bin\u00e1rn\u00ed haldou</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#algo-12.4","title":"Dijkstra s bin\u00e1rn\u00ed haldou","text":"<pre><code>Algoritmus DijkstraHalda(G, \u2113 : E \u2192 R+, v0)\nPro v\u0161echny v \u2208 V:\n    h(v) := +\u221e; P(v) := \u22a5\nh(v0) := 0\nH := HeapBuild(V) uspo\u0159\u00e1danou podle kl\u00ed\u010d\u016f h\nDokud H nepr\u00e1zdn\u00e1:\n    v := HeapExtractMin(H)\n    Pro v\u0161echny n\u00e1sledn\u00edky w vrcholu v:\n        Pokud w \u2208 H &amp; h(w) &gt; h(v) + \u2113((v, w)):\n            P(w) := v\n            HeapDecreaseKey(H, w, h(v) + \u2113((v, w)))\nVra\u0165 P a h\n</code></pre>"},{"location":"12_Ohodnocen%C3%BD_graf/12.2_Dijkstr%C5%AFv_algoritmus/#theorem-12.3","title":"V\u011bta o \u010dasov\u00e9 slo\u017eitosti Dijkstra s bin\u00e1rn\u00ed haldou","text":"<p>\u010casov\u00e1 slo\u017eitost DijkstraHalda je \\(O(|E| \\log |V|)\\).</p> D\u016fkaz <ul> <li>\u0158\u00e1dky (2)-(5) trvaj\u00ed \\(O(|V|)\\).</li> <li>Celkov\u00e1 slo\u017eitost na \u0159\u00e1dku (7) je \\(O(|V| \\log |V|)\\).</li> <li>Celkov\u00e1 slo\u017eitost na \u0159\u00e1dku (11) je \\(O(|E| \\log |V|)\\), nebo\u0165 po\u010det vol\u00e1n\u00ed operace <code>HeapDecreaseKey</code> je nejv\u00fd\u0161e \\(|E|\\).</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.3_Relaxa%C4%8Dn%C3%AD_algoritmy/","title":"12.3 Relaxa\u010dn\u00ed algoritmy","text":""},{"location":"12_Ohodnocen%C3%BD_graf/12.3_Relaxa%C4%8Dn%C3%AD_algoritmy/#hrany-s-nulovymi-ci-zapornymi-delkami","title":"Hrany s nulov\u00fdmi, \u010di z\u00e1porn\u00fdmi d\u00e9lkami","text":"<ul> <li>Samotn\u00e9 z\u00e1porn\u00e9 hrany probl\u00e9m nezp\u016fsobuj\u00ed, pokud v grafu nevznike z\u00e1porn\u00fd cyklus. V takov\u00e9m p\u0159\u00edpad\u011b nen\u00ed definov\u00e1n nejkrat\u0161\u00ed sled, proto\u017ee ke ka\u017ed\u00e9mu sledu existuje sled je\u0161t\u011b krat\u0161\u00ed.</li> <li>Pokud tedy graf m\u00e1 z\u00e1porn\u00e9 hrany, ale neobsahuje z\u00e1porn\u00fd cyklus, lemma o zjednodu\u0161en\u00ed sled\u016f a jeho d\u016fsledky plat\u00ed.</li> </ul> <p>Fakt (bez d\u016fkazu)</p> <p>Dijkstra na grafech s hranami z\u00e1porn\u00fdch d\u00e9lek bez z\u00e1porn\u00fdch cykl\u016f m\u016f\u017ee vrcholy otev\u00edrat opakovan\u011b a existuj\u00ed grafy, na kter\u00fdch m\u00e1 exponenci\u00e1ln\u00ed \u010dasovou slo\u017eitost vzhledem k \\(n\\).</p> <p></p> <p>Lemma (o zjednodu\u0161ov\u00e1n\u00ed sled\u016f 2)</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.3_Relaxa%C4%8Dn%C3%AD_algoritmy/#theorem-12.4","title":"Lemma o zjednodu\u0161ov\u00e1n\u00ed sled\u016f 2","text":"<p>Uva\u017eujme orientovan\u00fd graf se z\u00e1porn\u00fdmi d\u00e9lkami hran bez z\u00e1porn\u00fdch cykl\u016f. Pak pro ka\u017ed\u00fd \\(uv\\)-sled existuje \\(uv\\)-cesta stejn\u00e9 nebo men\u0161\u00ed d\u00e9lky.</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.3_Relaxa%C4%8Dn%C3%AD_algoritmy/#algoritmus-relaxace","title":"Algoritmus Relaxace","text":"<ul> <li>Porovn\u00e1me-li Jarn\u00edk\u016fv algoritmus s Dijkstrov\u00fdm, zjist\u00edme, \u017ee se li\u0161\u00ed pouze v definici kl\u00ed\u010d\u016f prvk\u016f haldy a n\u00e1sledn\u011b tedy i v aritmetick\u00e9m v\u00fdrazu pro relaxaci.</li> <li>Oba pat\u0159\u00ed do t\u0159\u00eddy tzv. relaxa\u010dn\u00edch algoritm\u016f.</li> </ul> <p>Algortimus Relaxace</p> <ul> <li>Zobecn\u011bn\u00ed Dijkstrova algoritmu, kter\u00e9 p\u0159ipou\u0161t\u00ed obecn\u00e9 ohodnocen\u00ed hran.</li> <li>Druh\u00e9 zobecn\u011bn\u00ed bude spo\u010d\u00edvat v tom, \u017ee m\u00edsto otev\u0159en\u00e9ho vrcholu s nejmen\u0161\u00ed hodnotou \\(h(v)\\) vybereme libovoln\u00fd vrchol \\(v\\) s kone\u010dn\u00fdm ohodnocen\u00edm \\(h(v)\\), ten relaxujeme a n\u00e1sledn\u011b uzav\u0159eme.</li> <li>M\u016f\u017ee se st\u00e1t, \u017ee uzav\u0159en\u00fd vrchol bude znovu otev\u0159en.</li> <li>Stavy tedy znamenaj\u00ed:</li> <li>Otev\u0159en\u00fd - hodnota vrcholu se zm\u011bnila a je pot\u0159eba ho relaxovat.</li> <li> <p>Uzav\u0159en\u00fd - vrchol byl relaxov\u00e1n.</p> <pre><code>Pro v\u0161echny vrcholy v:\n    stav(v) := nenalezen\u00fd\n    h(v) := +\u221e; P(v) := \u22a5\nstav(v0) := otev\u0159en\u00fd\nh(v0) := 0\nDokud existuj\u00ed otev\u0159en\u00e9 vrcholy:\n    v := n\u011bjak\u00fd otev\u0159en\u00fd vrchol\n    Pro v\u0161echny n\u00e1sledn\u00edky w vrcholu v: // relaxace v\n        Pokud h(w) &gt; h(v) + \u2113((v, w)):\n            h(w) := h(v) + \u2113((v, w))\n            stav(w) := otev\u0159en\u00fd\n            P(w) := v\n    stav(v) := uzav\u0159en\u00fd\nVra\u0165 pole vzd\u00e1lenost\u00ed h a pole p\u0159edch\u016fdc\u016f P\n</code></pre> </li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.3_Relaxa%C4%8Dn%C3%AD_algoritmy/#vlastnosti-algoritmu-relaxace","title":"Vlastnosti algoritmu Relaxace","text":"<p>N\u00e1sleduj\u00edc\u00ed 3 vlastnosti plat\u00ed pro jakoukoli strategii v\u00fdb\u011bru otev\u0159en\u00fdch vrchol\u016f pro relaxaci:</p> <ul> <li>Vlastnost O: Ohodnocen\u00ed \\(h(v)\\) nikdy neroste. Je-li \\(h(v)\\) kone\u010dn\u00e9 \u010d\u00edslo, rovn\u00e1 se d\u00e9lce n\u011bjak\u00e9ho sledu z \\(v_0\\) do \\(v\\).</li> <li>Vlastnost D: Pokud se v\u00fdpo\u010det zastav\u00ed, uzav\u0159en\u00e9 jsou pr\u00e1v\u011b vrcholy dosa\u017eiteln\u00e9 z \\(v_0\\).</li> <li>Vlastnost V: Pokud se v\u00fdpo\u010det zastav\u00ed, \\(h(v)\\) uzav\u0159en\u00e9ho vrcholu je rovno vzd\u00e1lenosti \\(d(v_0, v)\\).</li> </ul> <p></p> <p>Vlastnost O (ohodnocen\u00ed)</p> <p></p> <p>Vlastnost D (dosa\u017eitelnost)</p> <p></p> <p>Vlastnost V (vzd\u00e1lenost)</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.3_Relaxa%C4%8Dn%C3%AD_algoritmy/#def-12.10","title":"Vlastnost O (ohodnocen\u00ed)","text":"<p>Ohodnocen\u00ed \\(h(v)\\) nikdy neroste. Je-li \\(h(v)\\) kone\u010dn\u00e9 \u010d\u00edslo, rovn\u00e1 se d\u00e9lce n\u011bjak\u00e9ho sledu z \\(v_0\\) do \\(v\\).</p> D\u016fkaz (stejn\u00fd jako u Dijkstra) <ul> <li>Indukc\u00ed podle doby b\u011bhu algoritmu.</li> <li>Na po\u010d\u00e1tku v\u00fdpo\u010dtu tvrzen\u00ed ur\u010dit\u011b plat\u00ed, proto\u017ee jedin\u00e9 kone\u010dn\u00e9 ohodnocen\u00ed je \\(h(v_0) = 0\\).</li> <li>Kdykoliv algoritmus sni\u017euje ohodnocen\u00ed \\(h(w)\\), stane se tak relaxac\u00ed otev\u0159en\u00e9ho vrcholu \\(v\\) s kone\u010dn\u00fdm \\(h(v)\\), jeho\u017e n\u00e1sledn\u00edkem je \\(w\\).</li> <li>Podle induk\u010dn\u00edho p\u0159edpokladu tedy existuje \\(v_0v\\)-sled d\u00e9lky \\(h(v)\\).</li> <li>Jeho roz\u0161\u00ed\u0159en\u00edm o hranu \\(vw\\) vznikne \\(v_0w\\)-sled d\u00e9lky \\(h(v) + \u2113((v, w))\\), co\u017e je p\u0159esn\u011b nov\u00e1 kone\u010dn\u00e1 hodnota \\(h(w)\\).</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.3_Relaxa%C4%8Dn%C3%AD_algoritmy/#def-12.11","title":"Vlastnost D (dosa\u017eitelnost)","text":"<p>Pokud se v\u00fdpo\u010det zastav\u00ed, uzav\u0159en\u00e9 jsou pr\u00e1v\u011b vrcholy dosa\u017eiteln\u00e9 z \\(v_0\\).</p> D\u016fkaz <ul> <li>Dok\u00e1\u017eeme stejn\u011b jako obdobnou vlastnost BFS, s t\u00edm rozd\u00edlem, \u017ee uzav\u0159en\u00fd vrchol je mo\u017en\u00e9 znovu otev\u0159\u00edt.</li> <li>Prvn\u00edm otev\u0159en\u00fdm a n\u00e1sledn\u011b uzav\u0159en\u00fdm vrcholem je \\(v_0\\).</li> <li>Vrchol je poprv\u00e9 otev\u0159en, pr\u00e1v\u011b kdy\u017e je do t\u00e9 doby nenalezen\u00fdm n\u00e1sledn\u00edkem d\u0159\u00edve otev\u0159en\u00e9ho vrcholu a tud\u00ed\u017e je dosa\u017eiteln\u00fd z \\(v_0\\).</li> <li>Naopak kdyby existoval n\u011bjak\u00fd dosa\u017eiteln\u00fd, ale neuzav\u0159en\u00fd vrchol, existoval by ten \u201enejbli\u017e\u0161\u00ed\u201c vrchol \\(v\\) (co do po\u010dtu hran na nejkrat\u0161\u00ed cest\u011b).</li> <li>Pokud se Relaxace zastav\u00ed, znovu otev\u0159e ji\u017e uzav\u0159en\u00fd vrchol jen kone\u010dn\u011b-kr\u00e1t, tak\u017ee sta\u010d\u00ed uv\u00e1\u017eit situaci p\u0159i posledn\u00edm uzav\u0159en\u00ed p\u0159edch\u016fdce \\(v\\) na nejkrat\u0161\u00ed cest\u011b.</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.3_Relaxa%C4%8Dn%C3%AD_algoritmy/#def-12.12","title":"Vlastnost V (vzd\u00e1lenost)","text":"<p>Pokud se v\u00fdpo\u010det zastav\u00ed, je \\(h(w) = d(v_0, w)\\) pro v\u0161echny \\(w \\in V\\).</p> D\u016fkaz (t\u00e9m\u011b\u0159 stejn\u00fd jako u Dijkstra) <p>Vrchol \\(w\\) dosa\u017eiteln\u00fd z \\(v_0\\) nazveme \u0161patn\u00fd, pokud \\(h(w) \\ne d(v0, w)\\). Z Vlastnosti O v\u00edme, \u017ee \\(h(w)\\) odpov\u00edd\u00e1 d\u00e9lce n\u011bjak\u00e9ho \\(v_0w\\)-sledu a tedy \\(h(w) &gt; d(v_0, w)\\).</p> <ul> <li>V\u00edme, \u017ee \\(v_0\\) nen\u00ed \u0161patn\u00fd, proto\u017ee \\(h(v_0) = 0 = d(v_0, v_0)\\).</li> <li>Bu\u010f \\(w\\) \u0161patn\u00fd vrchol takov\u00fd, \u017ee nejkrat\u0161\u00ed cesta v \\(G\\) z \\(v_0\\) do \\(w\\) pou\u017e\u00edv\u00e1 nejmen\u0161\u00ed mo\u017en\u00fd po\u010det hran.</li> <li>Bu\u010f \\(v\\) p\u0159edch\u016fdce \\(w\\) na t\u00e9to cest\u011b z \\(v_0\\).</li> <li>Kdyby \\(v\\) byl \u0161patn\u00fd, volili bychom jej m\u00edsto \\(w\\), tedy plat\u00ed \\(h(v) = d(v_0, v)\\).</li> <li>Vrchol \\(v\\) byl jist\u011b n\u011bkdy otev\u0159en\u00fd a p\u0159i jeho posledn\u00ed relaxaci (tj. ne\u017e byl naposledy uzav\u0159en) muselo platit, \u017ee aktu\u00e1ln\u00ed hodnota \\(h(w)\\) byla v\u011bt\u0161\u00ed ne\u017e \\(d(v_0, w)\\) (nebo\u0165 toto plat\u00ed dokonce a\u017e po zastaven\u00ed Relaxace).</li> <li>V tom p\u0159\u00edpad\u011b ale prob\u011bhla zm\u011bna ohodnocen\u00ed \\(h(w)\\) a tedy mus\u00ed platit \\(h(w) = d(v_0, v) + \u2113((v, w)) = d(v_0, w)\\). Spor.</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.4_Bellman%C5%AFv-Ford%C5%AFv_algoritmus/","title":"12.4 Bellman\u016fv Ford\u016fv algoritmus","text":"<p>Bellman\u016fv-Ford\u016fv algoritmus</p> <p></p> <p>F\u00e1ze v\u00fdpo\u010dtu Bellman-Ford</p> <p>Pozorov\u00e1n\u00ed</p> <ul> <li>Pokud se zm\u011bn\u00ed hodnota uzav\u0159en\u00e9ho vrcholu, je znovu otev\u0159en.</li> <li>Hodnota otev\u0159en\u00e9ho vrcholu se m\u016f\u017ee zm\u011bnit v\u00edcekr\u00e1t, d\u0159\u00edve ne\u017e je vyjmut z fronty, relaxov\u00e1n a uzav\u0159en.</li> <li>B\u011bhem v\u00fdpo\u010dtu m\u016f\u017ee tedy dan\u00fd vrchol postupn\u011b pat\u0159it do v\u00edce \\(A_i\\).</li> </ul> <p></p> <p>V\u00fdznam \\(h(v)\\) v Bellman-Ford</p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.4_Bellman%C5%AFv-Ford%C5%AFv_algoritmus/#algo-12.5","title":"Bellman\u016fv-Ford\u016fv algoritmus","text":"<ul> <li>Relaxa\u010dn\u00ed algoritmus pro v\u00fdpo\u010det vzd\u00e1lenost\u00ed v grafech s hranami z\u00e1porn\u00fdch d\u00e9lek, ale bez z\u00e1porn\u00fdch cykl\u016f.</li> <li>Nam\u00edsto haldy (tj . prioritn\u00ed fronty) jsou otev\u0159en\u00e9 vrcholy ukl\u00e1d\u00e1ny do oby\u010dejn\u00e9 fronty.</li> <li>Jin\u00fdmi slovy, otev\u0159en\u00fd vrchol k relaxaci zvol\u00edme v\u017edy jako nejstar\u0161\u00ed (tedy prvn\u00ed) vrchol ve front\u011b otev\u0159en\u00fdch vrchol\u016f.</li> <li>Prvn\u011b otev\u0159en\u00e9 vrcholy \u0159ad\u00edme na konec fronty.</li> </ul> <pre><code>Pro v\u0161echny vrcholy v:\n    stav(v) := nenalezen\u00fd; h(v) := +\u221e; P(v) := \u22a5\nstav(v0) := otev\u0159en\u00fd; h(v0) := 0\nVlo\u017e v0 do fronty\nDokud je fronta nepr\u00e1zdn\u00e1:\n    Vyjmi prvn\u00ed vrchol z fronty a ozna\u010d ho v\n    Pro v\u0161echny n\u00e1sledn\u00edky w vrcholu v:\n        Pokud h(w) &gt; h(v) + \u2113((v, w)):\n            h(w) := h(v) + \u2113((v, w))\n            Pokud stav(w) != otev\u0159en\u00fd: \n                P\u0159idej w do fronty\n            stav(w) := otev\u0159en\u00fd\n            P(w) := v\n    stav(v) := uzav\u0159en\u00fd\nVra\u0165 pole vzd\u00e1lenost\u00ed h a pole p\u0159edch\u016fdc\u016f P\n</code></pre>"},{"location":"12_Ohodnocen%C3%BD_graf/12.4_Bellman%C5%AFv-Ford%C5%AFv_algoritmus/#def-12.12","title":"F\u00e1ze v\u00fdpo\u010dtu Bellman-Ford","text":"<ul> <li>Nech\u0165 \\(A_0 = \\{v_0\\}\\).</li> <li>F\u00e1ze \\(F_0\\) je otev\u0159en\u00ed po\u010d\u00e1te\u010dn\u00edho vrcholu \\(v_0\\), \u010dili v\u0161ech prvk\u016f mno\u017einy \\(A_0 = \\{v_0\\}\\).</li> <li>\\(A_i\\) je mno\u017eina vrchol\u016f, kter\u00e9 byly otev\u0159eny p\u0159i relaxov\u00e1n\u00ed vrchol\u016f z mno\u017einy \\(A_{i-1}\\).</li> <li>Vytvo\u0159en\u00ed mno\u017einy vrchol\u016f \\(A_i\\) se naz\u00fdv\u00e1 f\u00e1ze \\(F_i\\).</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.4_Bellman%C5%AFv-Ford%C5%AFv_algoritmus/#def-12.13","title":"V\u00fdznam h(v) v Bellman-Ford","text":"<p>Pro ka\u017ed\u00fd nalezen\u00fd vrchol \\(v\\) plat\u00ed na konci f\u00e1ze \\(F_i\\), \u017ee \\(h(v) \\leq \\ell(S)\\), kde \\(S\\) je nejkrat\u0161\u00ed \\(v_0v\\)-sled o nejv\u00fd\u0161e \\(i\\) hran\u00e1ch.</p> D\u016fkaz <ul> <li>Tvrzen\u00ed dok\u00e1\u017eeme indukc\u00ed podle \\(i\\).</li> <li>Pro \\(i = 0\\) tvrzen\u00ed plat\u00ed: jedin\u00fd vrchol dosa\u017eiteln\u00fd z \\(v_0\\) sledem s 0 hranami je \\(v_0\\) s\u00e1m; \\(h(v_0) = 0\\) a pro ostatn\u00ed vrcholy \\(v\\) je \\(h(v) = +\\infty\\).</li> <li>D\u00e1le nech\u0165 \\(i &gt; 0\\).</li> <li>Zvolme n\u011bjak\u00fd nalezen\u00fd vrchol \\(v\\) na konci f\u00e1ze \\(F_i\\). Ozna\u010dme \\(S\\) nejkrat\u0161\u00ed \\(v_0v\\)-sled o nejv\u00fd\u0161e \\(i\\) hran\u00e1ch. D\u00e1le ozna\u010dme \\(e(S)\\) po\u010det hran v sledu \\(S\\).</li> <li>Pokud \\(e(S) &lt; i\\), platilo \\(h(v) \\leq \\ell(S)\\) u\u017e na konci p\u0159edchoz\u00ed f\u00e1ze \\(F_{i-1}\\) a jeliko\u017e ohodnocen\u00ed vrchol\u016f nerostou, plat\u00ed nad\u00e1le.</li> <li>Pokud \\(e(S) = i\\), ozna\u010dme \\(uv\\) jeho posledn\u00ed hranu a \\(S'\\) podsled z \\(v_0\\) do \\(u\\).</li> <li>Na konci f\u00e1ze \\(F_{i-1}\\) je z indukce \\(h(u) \\leq \\ell(S')\\). </li> <li>Na tuto hodnotu muselo b\u00fdt \\(h(u)\\) nastaveno nejpozd\u011bji ve f\u00e1zi \\(F_{i-1}\\), \u010d\u00edm\u017e byl vrchol \\(u\\) otev\u0159en. </li> <li>Nejpozd\u011bji ve f\u00e1zi \\(F_i\\) proto musel b\u00fdt vrchol \\(u\\) relaxov\u00e1n. </li> <li>Na za\u010d\u00e1tku relaxace muselo st\u00e1le platit \\(h(u) \\leq \\ell(S')\\), hodnota \\(h(u)\\) se sice mohla zm\u011bnit, ale ne zv\u00fd\u0161it. </li> <li>Po relaxaci tedy muselo platit \\(h(v) \\leq h(u) + \\ell((u, v)) \\leq \\ell(S') + \\ell((u, v)) = \\ell(S)\\).</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.4_Bellman%C5%AFv-Ford%C5%AFv_algoritmus/#konecnost-bellman-ford","title":"Kone\u010dnost Bellman-Ford","text":"<p>D\u016fsledek</p> <p>Nech\u0165 \\(G = (V, E)\\) a \\(n = |V|\\). Pokud \\(G\\) neobsahuje z\u00e1porn\u00e9 cykly, po f\u00e1zi \\(F_n\\) se Bellman-Ford zastav\u00ed.</p> D\u016fkaz <ul> <li>Po f\u00e1zi \\(F_{n-1}\\) jsou ohodnocen\u00ed v\u0161ech vrchol\u016f shora omezena d\u00e9lkami nejkrat\u0161\u00edch cest, proto\u017ee nejkrat\u0161\u00ed cesty maj\u00ed nejv\u00fd\u0161e \\(n - 1\\) hran.</li> <li>Ve f\u00e1zi \\(F_n\\) se tedy ohodnocen\u00ed vrchol\u016f ji\u017e nemohou zm\u011bnit a algoritmus u\u017e \u017e\u00e1dn\u00fd vrchol neotev\u0159e a zastav\u00ed se.</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.4_Bellman%C5%AFv-Ford%C5%AFv_algoritmus/#slozitost-bellman-ford","title":"Slo\u017eitost Bellman-Ford","text":"<p>V\u011bta</p> <p>V grafu bez z\u00e1porn\u00fdch cykl\u016f nalezne Bellman-Ford v\u0161echny vzd\u00e1lenosti z vrcholu \\(v_0\\) v \u010dase \\(O(|V| \\cdot |E|)\\).</p> D\u016fkaz <ul> <li>Podle p\u0159edchoz\u00edho d\u016fsledku se po \\(|V|\\) f\u00e1z\u00edch algoritmus zastav\u00ed a podle Vlastnosti 2 o dosa\u017eitelnosti vrchol\u016f a Vlastnosti 3 o v\u00fdznamu \\(h(v)\\) na konci relaxa\u010dn\u00edho algoritmu vyd\u00e1 spr\u00e1vn\u00fd v\u00fdsledek.</li> <li>B\u011bhem jedn\u00e9 f\u00e1ze je p\u0159itom ka\u017ed\u00fd vrchol relaxov\u00e1n nejv\u00fd\u0161e jednou, tak\u017ee cel\u00e1 f\u00e1ze dohromady trv\u00e1 \\(O(|E|)\\).</li> </ul>"},{"location":"12_Ohodnocen%C3%BD_graf/12.4_Bellman%C5%AFv-Ford%C5%AFv_algoritmus/#jednoducha-implementace-bellman-ford","title":"Jednoduch\u00e1 implementace Bellman-Ford","text":"<p>SimpleBellman-Ford</p> <p>Algoritmus SimpleBellman-Ford(G, \u2113 : E \u2192 R, v0) <pre><code>Pro v\u0161echny vrcholy v:\n    h(v) := +\u221e; P(v) := \u22a5\nh(v0) := 0\nPro i := 1, . . . , n:\n    Pro ka\u017edou hranu (u, v) \u2208 E(G):\n        Pokud h(v) &gt; h(u) + \u2113((u, v)):\n            h(v) := h(u) + \u2113((u, v))\n            P(v) := u\nVra\u0165 pole vzd\u00e1lenost\u00ed h a pole p\u0159edch\u016fdc\u016f P\n</code></pre></p>"},{"location":"12_Ohodnocen%C3%BD_graf/12.4_Bellman%C5%AFv-Ford%C5%AFv_algoritmus/#vlastnosti-algoritmu-simplebellman-ford","title":"Vlastnosti algoritmu SimpleBellman-Ford","text":"<p>Obdobn\u011b jako pro algoritmus Bellman-Ford bychom pro algoritmus SimpleBellman-Ford mohli dok\u00e1zat:</p> <ul> <li>Ohodnocen\u00ed \\(h(v)\\) nikdy neroste.</li> <li>Je-li \\(h(v)\\) kone\u010dn\u00e9, rovn\u00e1 se d\u00e9lce n\u011bjak\u00e9ho sledu z \\(v_0\\) do \\(v\\).</li> <li>Pro ka\u017ed\u00fd vrchol \\(v\\) na konci \\(i\\)-t\u00e9 iterace cyklu na \u0159\u00e1dku (4) plat\u00ed, \u017ee \\(h(v)\\) je shora omezeno d\u00e9lkou nejkrat\u0161\u00edho \\(v_0v\\)-sledu o nejv\u00fd\u0161e \\(i\\) hran\u00e1ch.</li> </ul> <p>V\u011bta</p> <p>Algoritmus SimpleBellman-Ford je korektn\u00ed a pracuje v \u010dase \\(O(|V| \\cdot |E|)\\).</p>"}]}